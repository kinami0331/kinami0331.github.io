{"meta":{"title":"kinami's blog","subtitle":"一点微小的贡献","description":"普通的CS学生/一般通过音游玩家","author":"kinami","url":"http://www.kinami.cc","root":"/"},"pages":[{"title":"categories","date":"2021-04-13T10:44:24.000Z","updated":"2021-04-13T11:10:49.691Z","comments":true,"path":"categories/index.html","permalink":"http://www.kinami.cc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-13T10:44:38.000Z","updated":"2021-04-13T11:11:05.267Z","comments":true,"path":"tags/index.html","permalink":"http://www.kinami.cc/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-04-13T10:48:11.000Z","updated":"2021-04-13T10:48:29.949Z","comments":true,"path":"about/index.html","permalink":"http://www.kinami.cc/about/index.html","excerpt":"","text":"啦啦啦"}],"posts":[{"title":"计算机网络概论lab 1 滑动窗口","slug":"计算机网络概论lab-1-滑动窗口","date":"2021-04-13T12:51:26.000Z","updated":"2021-04-13T13:09:11.946Z","comments":true,"path":"2021/04/13/计算机网络概论lab-1-滑动窗口/","link":"","permalink":"http://www.kinami.cc/2021/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BAlab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"实验流程实验要求本次实验要求在一个数据链路层的模拟实现环境下，用C语言实现三个数据链路层协议：1比特滑动窗口协议、回退N帧滑动窗口协议、选择性重传协议。 实验思路通过阅读实验指导书可以发现，回退N帧滑动窗口协议是最重要的一个，其他两个协议都可以看作在此基础上的一点小修改，所以本次实验中最重要的一点是实现回退N帧滑动窗口协议。在回退N帧实验中，系统和我需要实现的函数的函数交互方式如下： 等停协议和回退N帧协议：当发送端需要发送帧时，会调用学生测试函数，并置参数messageType为MSG_TYPE_SEND，测试函数应该将该帧缓存，存入发送队列中。若发送窗口还未打开到规定限度，则打开一个窗口，并将调用SendFRAMEPacket函数将该帧发送。若发送窗口已开到限度，则直接返回，相当于直接进入等待状态。 当发送端收到接收端的ACK 后，会调用学生测试函数，并置参数messageType为MSG_TYPE_RECEIVE，测试函数应该检查ACK值后，将该ACK 对应的窗口关闭。由于关闭了窗口，等待发送的帧可以进入窗口并发送，因此，此时若发送队列中存在等待发送的帧应该将一个等待发送的帧发送并打开一个新的窗口。 发送每发送一个帧，系统都会为他创建一个定时器，当被成功ACK 后，定时器会被取消，若某个帧在定时器超时时间仍未被ACK，系统则会调用测试函数，并置参数messageType 为MSG_TYPE_TIMEOUT，告知测试函数某帧超时，测试函数应该将根据帧序号将该帧以及后面发送过的帧重新发送。 可见，系统通过反复调用我实现的函数，通过messageType来标注是什么样的操作要求。因此我们可以考虑通过switch来区分开不同的操作，每个操作进行单独的实现。除此之外，在运行过程中，还有数据保存要求，所以我们需要全局变量或者静态变量来存储一些数据，考虑到每个函数功能的单独性，用静态变量实现会更优雅，在本次实验中选择这样实现。 实验细节正如之前所述，我将以回退N帧数函数为基础完成整个实验，在此部分进行一些代码细节的说明。首先，定义的一些常量以及结构如下： 两个窗口大小的常量 12#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4 表示帧状态的枚举型 12345typedef enum &#123; data, ack, nak&#125; frame_kind; 系统中定义的frame结构 12345678910typedef struct frame_head &#123; frame_kind kind; // 帧类型 unsigned int seq; // 序列号 unsigned int ack; // 确认号 unsigned char data[100];//数据&#125;;typedef struct frame &#123; frame_head head; //帧头 unsigned int size; //帧的大小&#125;; 自定义的用于存储帧的Buffer结构。其中pBuffer和pFrame指针指向同一片地方只是生命的类型不同，主要是便于之后调用时不再手动强制类型转换。 123456789101112131415161718typedef struct Buffer &#123; unsigned char *pBuffer; // 向`SendFRAMEPacket`函数传的第一个参数 frame *pFrame; // 存储的frame的指针 int bufferSize; // size，向`SendFRAMEPacket`函数传的第二个参数 Buffer() &#123; // 分配一块储存frame的空间 pFrame = new frame(); // 将分配的地址指针赋值给pBuffer pBuffer = (unsigned char *) pFrame; &#125; // 用于储存frame的工具成员函数 void save(char *_pBuffer, int _bufferSize) &#123; // 注意不能是复制指针，而是需要把内容复制过来 (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;; 一个用于通过指针获得ACK的宏函数 1#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack) 之后，回退N帧测试函数stud_slide_window_back_n_frame内定义的用于存储数据的静态变量如下： 12345678910int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; // switch body ....... &#125;&#125; 其中各变量的意义如下： lower: 滑动窗口的下界 upper: 滑动窗口上界的下一个 wait_queue: 由于窗口打开到上限不能直接send的帧的等待队列 WINDOW_SIZE: 在本函数中的窗口大小，每个函数中可能不一样 windows[WINDOW_SIZE]: 用于存储各窗口发出的帧的数组，大小和窗口大小一样 此外，需要注意的是，实际打开的窗口的窗口号下界为lower % WINDOW_SIZE，上界的下一个窗口号为(upper + 1) % WINDOW_SIZE。因为实际窗口号是在一定范围内轮流使用，例如0,1,2,3,0,1,2,...这样，但是如果将下界和上界直接这样表示有时会带来额外的麻烦，例如当窗口大小为1时，只存在一个窗口号0，此时上界的下一个窗口号也还是0，刚开始实现时就是因为这样，导致回退N帧测试函数不能直接修改WINDOW_SIZE来用在等停测试函数中。 之后便是swtich中各个功能的实现，实现细节如下： MSG_TYPE_SEND 123456789101112131415161718case MSG_TYPE_SEND: &#123; // 保存帧的内容 Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); // 发送等待序列中的帧 // 当队列不为空且窗口大小小于最大大小时进行发送。 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; // 从队列头取出一个并发送 Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); // 将发送的帧储存在对应窗口中 windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_RECEIVE 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取收到的ack int ack = GET_ACK(pBuffer); // 从目前的打开的窗口中寻找seq=ack的窗口 for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; // 如果找到，说明i窗口以及之前的窗口已经被成功接受，则下界应当更新为i + 1 lower = i + 1; break; &#125; &#125; // 此时如果能继续发送则继续发送，该部分发送函数的逻辑和`case MSG_TYPE_SEND`中的对应部分一模一样 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_TIMEOUT: 1234567case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break;&#125; 以上便是回退N帧协议的实现细节。在实现中要注意的几个点，从pFrame中读取数据时（在本次实验中要读取的为seq、ack、kind），要注意大小端的转换，直接用ntohl()函数即可。在这种实现中，实现等停协议只需要将WINDOW_SIZE设置成WINDOW_SIZE_STOP_WAIT（即为1）即可，此外不需要任何的修改。 选择性重传函数中，取消了MSG_TYPE_TIMEOUT这种类型，只需要对case MSG_TYPE_RECEIVE做一些修改即可，修改如下： 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取`kind`区分是`ack`还是`nak` int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); // 如果kind是`ack`，和之前的处理一模一样，此处略 if (kind == ack) &#123; /* ... */ &#125; // 如果kind是`nak`，则将帧中的`ack`表示的帧号找出来重发 else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; // 遍历找到缓存的帧中seq等于读出的ack（在这里用变量nak表示）的帧 if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break;&#125; 至此，该实验结束。 实验中遇到的问题 不熟悉实验系统，实验系统对一些错误也不能很好的反馈。例如刚开始的时候，由于代码实现中将Buffer这个辅助结构当成一个class来使用，写了析构函数，并在析构函数中进行了delete操作，但是由于忽略了局部变量作用域的问题，导致了某些指针被重复释放，出了错误，但是在实验系统中并没有报错，只是单纯的卡住不动，最后因为过去的一点点经验想到了可能是指针相关的错误，最后才找到了这个问题。 还没找到很方便的debug方法，在做实验时还是通过最原始的输出log来寻找问题，实验系统中的单步调试功能也没太用习惯。 对大小端转换的问题还没有形成习惯，漏了好几次转换，运行出错了才发现没写。 完整代码由于三个函数的代码重复性很高，而且前面已经给出了详解，因此在完整代码部分删去了注释。代码说明见前面实验细节部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &quot;sysinclude.h&quot;#include &lt;queue&gt;extern void SendFRAMEPacket(unsigned char *pData, unsigned int len);#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4typedef enum &#123; data, ack, nak&#125; frame_kind;typedef struct frame_head &#123; frame_kind kind; unsigned int seq; unsigned int ack; unsigned char data[100];&#125;;typedef struct frame &#123; frame_head head; unsigned int size;&#125;;typedef struct Buffer &#123; unsigned char *pBuffer; frame *pFrame; int bufferSize; Buffer() &#123; pFrame = new frame(); pBuffer = (unsigned char *) pFrame; &#125; void save(char *_pBuffer, int _bufferSize) &#123; (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;;#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)/** 停等协议测试函数*/int stud_slide_window_stop_and_wait(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_STOP_WAIT; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower++; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 回退n帧测试函数*/int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 选择性重传测试函数*/int stud_slide_window_choice_frame_resend(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); if (kind == ack) &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; &#125; else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break; &#125; default: break; &#125; return 0;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]}],"categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]}