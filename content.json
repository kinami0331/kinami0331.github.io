{"meta":{"title":"kinami's","subtitle":"一点微小的贡献","description":"普通的CS学生/一般通过音游玩家","author":"kinami","url":"http://www.kinami.cc","root":"/"},"pages":[{"title":"about","date":"2021-04-13T10:48:11.000Z","updated":"2021-04-13T10:48:29.949Z","comments":true,"path":"about/index.html","permalink":"http://www.kinami.cc/about/index.html","excerpt":"","text":"啦啦啦"},{"title":"categories","date":"2021-04-13T10:44:24.000Z","updated":"2021-04-13T11:10:49.691Z","comments":true,"path":"categories/index.html","permalink":"http://www.kinami.cc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-13T10:44:38.000Z","updated":"2021-04-13T11:11:05.267Z","comments":true,"path":"tags/index.html","permalink":"http://www.kinami.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机网络概论lab 2 ipv4分组收发","slug":"计算机网络概论lab-2-ipv4分组收发","date":"2021-04-13T16:38:41.000Z","updated":"2021-04-13T16:40:26.674Z","comments":true,"path":"2021/04/14/计算机网络概论lab-2-ipv4分组收发/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BAlab-2-ipv4%E5%88%86%E7%BB%84%E6%94%B6%E5%8F%91/","excerpt":"","text":"实验流程实验要求根据计算机网络实验系统所提供的上下层接口函数和协议中分组收发的主要流程，独立设计实现一个简单的IPv4分组收发模块。要求实现的主要功能包括： IPv4分组的基本接收处理； IPv4分组的封装发送。 实验思路在本次实验中，最重要的部分是理解IPv4的头部结构，应当使用合适的方法对头部信息进行读取、校验、写入等操作。在实验指导书中给出的头部信息结构如下： 在接收时，使用合适的方法读取并验证头部信息，写入时用合适的方法写入正确的值，就是我们本次实验需要完成的内容。 实验细节IPv4分组的基本接收处理正如之前所述，本次实验的关键在于读取头部信息，首先我们对头部信息进行读取，代码如下： 读取头部信息 在本次实验中，只需读取下列我们感兴趣的信息即可。需要注意的是在读取超过1个字节的值时需要将网络序转换为本地序。 123456// 读取头部信息int version = pBuffer[0] &gt;&gt; 4;int headLength = pBuffer[0] &amp; 0xf; //0b00001111int timeToLive = (unsigned short) pBuffer[8];int headCheckSum = ntohs(*(unsigned short *) (pBuffer + 10));int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); 判断timeToLive值是否出错 12345// TTL值出错if (timeToLive &lt;= 0) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_TTL_ERROR); return 1;&#125; 判断IP版本号是否出错 12345// IP版本号错if (version != 4) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_VERSION_ERROR); return 1;&#125; 判断头部长度是否出错 12345// 头部长度错if (headLength &lt; 5) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_HEADLEN_ERROR); return 1;&#125; 校验checksum，直接把头部的长度按照规则相加，和应该为0xffff 这里要注意的细节是，由于我们用unsigned short进行计算，而checksum的规则要求如果相加大于0xffff，需要把高16位的值加到低16位上，因此，每次相加前我们需要判断相加是否大于0xffff，需要采用判断0xffff - sum和temp的关系来实现来避免溢出，如代码的11行所示。 1234567891011121314151617// 校验checksum// sum为计算的和unsigned short sum = 0;// temp用于辅助计算unsigned short temp = 0;// 每16字节为一组for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) pBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) pBuffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp;&#125;// 如果和不为0xffff，说明出错if (sum != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR); return 1;&#125; 如果经过上面的操作都没有返回，说明该分组没有问题，可以接受，如下 123//成功接受ip_SendtoUp(pBuffer, length);return 0; IPv4分组的封装发送该部分主要需要实现对头部信息的写入。流程如下： 首先，需要创建一个完整的分组结构 1234// 分配空间，头需要20字节，内容字节数为lenchar *IPBuffer = (char *) malloc((20 + len) * sizeof(char));// 将数据初始化为0memset(IPBuffer, 0, len + 20); 填充Version和IHL，内容为0b10001001=0x45，如下 1IPBuffer[0] = 0x45; 计算分组长度，转换成网络序后填写 1234 //分组总长度，需要转换成网络序unsigned short totalLength = htons(len + 20); // 填写total_length信息memcpy(IPBuffer + 2, &amp;totalLength, 2); 填写timeToLive和protocol 12IPBuffer[8] = timeToLive; //timeToLiveIPBuffer[9] = protocol; //协议 填写源地址和目标地址，注意转换成网络序 1234unsigned int src = htonl(srcAddr);unsigned int dst = htonl(dstAddr);memcpy(IPBuffer + 12, &amp;src, 4);memcpy(IPBuffer + 16, &amp;dst, 4); 计算checksum，由于我们在刚开始就使用memset将所有位初始化为了0，因此我们在这里可以用和第一个实验一模一样的代码来计算checksum，放置checksum的字节现在值为0，并不会影响计算，之后，用0xffff减去我们计算的结果就是应该填充的checksum。代码如下： 12345678unsigned short sum = 0;unsigned short temp = 0;// 计算sum// 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以for (int i = 0; i &lt; 10; i++) &#123; temp = (((unsigned char) IPBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) IPBuffer[i * 2 + 1]); 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp;&#125; 以上代码为求和，以下为填充。 1234unsigned short headCheckSum = 0;headCheckSum = htons(0xffff - sum);// 填充checksum值memcpy(IPBuffer + 10, &amp;headCheckSum, 2); 最后，将携带的信息填充并发送即可 123memcpy(IPBuffer + 20, pBuffer, len);ip_SendtoLower(IPBuffer, len + 20);return 0; 至此，实验代码结束，在测试平台上测试通过。 实验中遇到的问题 本次实验较为顺利，没遇到太多的疑难问题。 完整代码完整代码即为将实验细节部分的代码拼凑而成，但还是在这里给出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &quot;sysInclude.h&quot;#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;extern void ip_DiscardPkt(char *pBuffer, int type);extern void ip_SendtoLower(char *pBuffer, int length);extern void ip_SendtoUp(char *pBuffer, int length);extern unsigned int getIpv4Address();// 头部一共有20个字节，以字节为单位结构如下:// pBuffer[0] 高4位为Version 低4位为IHL// pBuffer[1] 高6位为TypeOfService// pBuffer[2]-pBuffer[3] Total Length// pBuffer[4]-pBuffer[5] Identification// pBuffer[6]的第6位第7位分别为MF和DF// pBuffer[6]的前5位+pBuffer[7] 为Fragment offset// pBuffer[8] : time to live// pBuffer[9]: Protocol// pBuffer[10]-pBuffer[11] Header checksum// pBuffer[12]-pBuffer[15] source address // pBuffer[16]-pBuffer[19] destination addressint stud_ip_recv(char *pBuffer, unsigned short length) &#123; // 读取头部信息 int version = pBuffer[0] &gt;&gt; 4; int headLength = pBuffer[0] &amp; 0xf; //0b00001111 int timeToLive = (unsigned short) pBuffer[8]; int headCheckSum = ntohs(*(unsigned short *) (pBuffer + 10)); int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); // TTL值出错 if (timeToLive &lt;= 0) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_TTL_ERROR); return 1; &#125; // IP版本号错 if (version != 4) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_VERSION_ERROR); return 1; &#125; // 头部长度错 if (headLength &lt; 5) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_HEADLEN_ERROR); return 1; &#125; // 目的地址错 if (dstAddr != getIpv4Address() &amp;&amp; dstAddr != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_DESTINATION_ERROR); return 1; &#125; // 校验checksum // sum为计算的和 unsigned short sum = 0; // temp用于辅助计算 unsigned short temp = 0; // 每16字节为一组 for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) pBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) pBuffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; if (sum != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR); return 1; &#125; //成功接受 ip_SendtoUp(pBuffer, length); return 0;&#125;int stud_ip_Upsend(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr, byte protocol, byte timeToLive) &#123; // 分配空间，头需要20字节，内容字节数为len char *IPBuffer = (char *) malloc((20 + len) * sizeof(char)); memset(IPBuffer, 0, len + 20); // pBuffer[0] 高4位为Version 低4位为IHL // 0b10001001 IPBuffer[0] = 0x45; //分组总长度，需要转换成网络序 unsigned short totalLength = htons(len + 20); // 填写total_length信息 memcpy(IPBuffer + 2, &amp;totalLength, 2); IPBuffer[8] = timeToLive; //timeToLive IPBuffer[9] = protocol; //协议 unsigned int src = htonl(srcAddr); unsigned int dst = htonl(dstAddr); memcpy(IPBuffer + 12, &amp;src, 4); //源与目的IP地址 memcpy(IPBuffer + 16, &amp;dst, 4); unsigned short sum = 0; unsigned short temp = 0; // 计算checksum // 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以 for (int i = 0; i &lt; 10; i++) &#123; temp = (((unsigned char) IPBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) IPBuffer[i * 2 + 1]); 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; unsigned short headCheckSum = 0; headCheckSum = htons(0xffff - sum); memcpy(IPBuffer + 10, &amp;headCheckSum, 2); memcpy(IPBuffer + 20, pBuffer, len); ip_SendtoLower(IPBuffer, len + 20); return 0;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"计算机网络概论lab 1 滑动窗口","slug":"计算机网络概论lab-1-滑动窗口","date":"2021-04-13T12:51:26.000Z","updated":"2021-04-13T13:09:11.946Z","comments":true,"path":"2021/04/13/计算机网络概论lab-1-滑动窗口/","link":"","permalink":"http://www.kinami.cc/2021/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BAlab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"实验流程实验要求本次实验要求在一个数据链路层的模拟实现环境下，用C语言实现三个数据链路层协议：1比特滑动窗口协议、回退N帧滑动窗口协议、选择性重传协议。 实验思路通过阅读实验指导书可以发现，回退N帧滑动窗口协议是最重要的一个，其他两个协议都可以看作在此基础上的一点小修改，所以本次实验中最重要的一点是实现回退N帧滑动窗口协议。在回退N帧实验中，系统和我需要实现的函数的函数交互方式如下： 等停协议和回退N帧协议：当发送端需要发送帧时，会调用学生测试函数，并置参数messageType为MSG_TYPE_SEND，测试函数应该将该帧缓存，存入发送队列中。若发送窗口还未打开到规定限度，则打开一个窗口，并将调用SendFRAMEPacket函数将该帧发送。若发送窗口已开到限度，则直接返回，相当于直接进入等待状态。 当发送端收到接收端的ACK 后，会调用学生测试函数，并置参数messageType为MSG_TYPE_RECEIVE，测试函数应该检查ACK值后，将该ACK 对应的窗口关闭。由于关闭了窗口，等待发送的帧可以进入窗口并发送，因此，此时若发送队列中存在等待发送的帧应该将一个等待发送的帧发送并打开一个新的窗口。 发送每发送一个帧，系统都会为他创建一个定时器，当被成功ACK 后，定时器会被取消，若某个帧在定时器超时时间仍未被ACK，系统则会调用测试函数，并置参数messageType 为MSG_TYPE_TIMEOUT，告知测试函数某帧超时，测试函数应该将根据帧序号将该帧以及后面发送过的帧重新发送。 可见，系统通过反复调用我实现的函数，通过messageType来标注是什么样的操作要求。因此我们可以考虑通过switch来区分开不同的操作，每个操作进行单独的实现。除此之外，在运行过程中，还有数据保存要求，所以我们需要全局变量或者静态变量来存储一些数据，考虑到每个函数功能的单独性，用静态变量实现会更优雅，在本次实验中选择这样实现。 实验细节正如之前所述，我将以回退N帧数函数为基础完成整个实验，在此部分进行一些代码细节的说明。首先，定义的一些常量以及结构如下： 两个窗口大小的常量 12#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4 表示帧状态的枚举型 12345typedef enum &#123; data, ack, nak&#125; frame_kind; 系统中定义的frame结构 12345678910typedef struct frame_head &#123; frame_kind kind; // 帧类型 unsigned int seq; // 序列号 unsigned int ack; // 确认号 unsigned char data[100];//数据&#125;;typedef struct frame &#123; frame_head head; //帧头 unsigned int size; //帧的大小&#125;; 自定义的用于存储帧的Buffer结构。其中pBuffer和pFrame指针指向同一片地方只是生命的类型不同，主要是便于之后调用时不再手动强制类型转换。 123456789101112131415161718typedef struct Buffer &#123; unsigned char *pBuffer; // 向`SendFRAMEPacket`函数传的第一个参数 frame *pFrame; // 存储的frame的指针 int bufferSize; // size，向`SendFRAMEPacket`函数传的第二个参数 Buffer() &#123; // 分配一块储存frame的空间 pFrame = new frame(); // 将分配的地址指针赋值给pBuffer pBuffer = (unsigned char *) pFrame; &#125; // 用于储存frame的工具成员函数 void save(char *_pBuffer, int _bufferSize) &#123; // 注意不能是复制指针，而是需要把内容复制过来 (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;; 一个用于通过指针获得ACK的宏函数 1#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack) 之后，回退N帧测试函数stud_slide_window_back_n_frame内定义的用于存储数据的静态变量如下： 12345678910int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; // switch body ....... &#125;&#125; 其中各变量的意义如下： lower: 滑动窗口的下界 upper: 滑动窗口上界的下一个 wait_queue: 由于窗口打开到上限不能直接send的帧的等待队列 WINDOW_SIZE: 在本函数中的窗口大小，每个函数中可能不一样 windows[WINDOW_SIZE]: 用于存储各窗口发出的帧的数组，大小和窗口大小一样 此外，需要注意的是，实际打开的窗口的窗口号下界为lower % WINDOW_SIZE，上界的下一个窗口号为(upper + 1) % WINDOW_SIZE。因为实际窗口号是在一定范围内轮流使用，例如0,1,2,3,0,1,2,...这样，但是如果将下界和上界直接这样表示有时会带来额外的麻烦，例如当窗口大小为1时，只存在一个窗口号0，此时上界的下一个窗口号也还是0，刚开始实现时就是因为这样，导致回退N帧测试函数不能直接修改WINDOW_SIZE来用在等停测试函数中。 之后便是swtich中各个功能的实现，实现细节如下： MSG_TYPE_SEND 123456789101112131415161718case MSG_TYPE_SEND: &#123; // 保存帧的内容 Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); // 发送等待序列中的帧 // 当队列不为空且窗口大小小于最大大小时进行发送。 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; // 从队列头取出一个并发送 Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); // 将发送的帧储存在对应窗口中 windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_RECEIVE 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取收到的ack int ack = GET_ACK(pBuffer); // 从目前的打开的窗口中寻找seq=ack的窗口 for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; // 如果找到，说明i窗口以及之前的窗口已经被成功接受，则下界应当更新为i + 1 lower = i + 1; break; &#125; &#125; // 此时如果能继续发送则继续发送，该部分发送函数的逻辑和`case MSG_TYPE_SEND`中的对应部分一模一样 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_TIMEOUT: 1234567case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break;&#125; 以上便是回退N帧协议的实现细节。在实现中要注意的几个点，从pFrame中读取数据时（在本次实验中要读取的为seq、ack、kind），要注意大小端的转换，直接用ntohl()函数即可。在这种实现中，实现等停协议只需要将WINDOW_SIZE设置成WINDOW_SIZE_STOP_WAIT（即为1）即可，此外不需要任何的修改。 选择性重传函数中，取消了MSG_TYPE_TIMEOUT这种类型，只需要对case MSG_TYPE_RECEIVE做一些修改即可，修改如下： 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取`kind`区分是`ack`还是`nak` int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); // 如果kind是`ack`，和之前的处理一模一样，此处略 if (kind == ack) &#123; /* ... */ &#125; // 如果kind是`nak`，则将帧中的`ack`表示的帧号找出来重发 else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; // 遍历找到缓存的帧中seq等于读出的ack（在这里用变量nak表示）的帧 if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break;&#125; 至此，该实验结束。 实验中遇到的问题 不熟悉实验系统，实验系统对一些错误也不能很好的反馈。例如刚开始的时候，由于代码实现中将Buffer这个辅助结构当成一个class来使用，写了析构函数，并在析构函数中进行了delete操作，但是由于忽略了局部变量作用域的问题，导致了某些指针被重复释放，出了错误，但是在实验系统中并没有报错，只是单纯的卡住不动，最后因为过去的一点点经验想到了可能是指针相关的错误，最后才找到了这个问题。 还没找到很方便的debug方法，在做实验时还是通过最原始的输出log来寻找问题，实验系统中的单步调试功能也没太用习惯。 对大小端转换的问题还没有形成习惯，漏了好几次转换，运行出错了才发现没写。 完整代码由于三个函数的代码重复性很高，而且前面已经给出了详解，因此在完整代码部分删去了注释。代码说明见前面实验细节部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &quot;sysinclude.h&quot;#include &lt;queue&gt;extern void SendFRAMEPacket(unsigned char *pData, unsigned int len);#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4typedef enum &#123; data, ack, nak&#125; frame_kind;typedef struct frame_head &#123; frame_kind kind; unsigned int seq; unsigned int ack; unsigned char data[100];&#125;;typedef struct frame &#123; frame_head head; unsigned int size;&#125;;typedef struct Buffer &#123; unsigned char *pBuffer; frame *pFrame; int bufferSize; Buffer() &#123; pFrame = new frame(); pBuffer = (unsigned char *) pFrame; &#125; void save(char *_pBuffer, int _bufferSize) &#123; (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;;#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)/** 停等协议测试函数*/int stud_slide_window_stop_and_wait(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_STOP_WAIT; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower++; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 回退n帧测试函数*/int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 选择性重传测试函数*/int stud_slide_window_choice_frame_resend(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); if (kind == ack) &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; &#125; else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break; &#125; default: break; &#125; return 0;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]}],"categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]}