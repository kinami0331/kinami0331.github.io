{"meta":{"title":"kinami's","subtitle":"一点微小的贡献","description":"普通的CS学生/一般通过音游玩家","author":"kinami","url":"http://www.kinami.cc","root":"/"},"pages":[{"title":"内容分类","date":"2021-04-13T10:44:24.000Z","updated":"2021-04-13T16:57:57.483Z","comments":true,"path":"categories/index.html","permalink":"http://www.kinami.cc/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-04-13T10:48:11.000Z","updated":"2021-04-13T16:59:57.261Z","comments":true,"path":"about/index.html","permalink":"http://www.kinami.cc/about/index.html","excerpt":"","text":"随便写写"},{"title":"标签","date":"2021-04-13T10:44:38.000Z","updated":"2021-04-13T16:57:54.066Z","comments":true,"path":"tags/index.html","permalink":"http://www.kinami.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《操作系统》xv6阅读报告之进程模型","slug":"《操作系统》xv6阅读报告之进程模型","date":"2021-04-15T08:21:50.000Z","updated":"2021-04-15T15:02:55.396Z","comments":true,"path":"2021/04/15/《操作系统》xv6阅读报告之进程模型/","link":"","permalink":"http://www.kinami.cc/2021/04/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"概述本次XV6源码阅读主要关注XV6中的进程模型的实现，包括XV6中的PCB（进程控制块）结构、进程常用方法的实现、系统对进程的调度等。与该功能实现有关的主要代码文件以及该文件的主要内容如下表格所示。 文件名 主要功能 proc.h 主要声明了三个struct:cpu,context,proc，分别是内核中的CPU、上下文以及我们重点关注的PCB信息，除此之外还定义了一个枚举型，定义了xv6中进程的可能状态 proc.c 声明了进程表的数据结构ptable以及与进程有关的核心函数，在本次报告中会对这些函数详细解读 vm.c 实现了一些与虚拟内存有关的函数，其中与进程有关的部分包括为内核和用户分配内存，切换到当前进程页面的switchuvm()，切换到内核页面的switchkvm()，以及用于拷贝父进程空间到子进程空间的copyuvm()等 swtch.S 用汇编实现的一个用于切换上下文的函数 kalloc.c 主要实现了用于分配和释放物理内存的kalloc()以及kfree() 除此之外，还有定义了一些数据结构的其他头文件，这里不特别列出，在用到的时候会说明。在本次报告中，我们主要关注进程相关的内容，即proc.h和proc.c这两个文件中的内容。 核心代码解读proc.h在proc.h中，定义了以下数据： struct cpu：这是CPU在呢何种的表示，在这个结构体中，会有一个指向struct proc的指针，用于表示当前正在执行的进程。此外还声明了一个cpus数组，用于支持多核处理器。 struct context，表示上下文信息的一个结构体，如下所示： 1234567struct context &#123; uint edi; uint esi; uint ebx; uint ebp; uint eip;&#125;; struct proc，这是XV6中的进程控制块（PCB），如下所示： 12345678910111213141516struct proc &#123; uint sz; pde_t* pgdir; char *kstack; enum procstate state; volatile int pid; struct proc *parent; struct trapframe *tf; struct context *context; void *chan; int killed; struct file *ofile[NOFILE]; struct inode *cwd; char name[16];&#125;; 其中各个数据项的详细意义如下： 数据 功能 uint sz 进程内存空间的大小，单位为byte pde_t* pgdir 指向进程的page table char *kstack 指向内核栈的底部 enum procstate state 表示内核当前的状态，其中enum procstate是一个枚举结构，该枚举结构的定义为 enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;除了未使用（UNUSED）状态之外，进程共有五种状态。 volatile int pid 进程的id struct proc *parent 指向父进程结构 struct trapframe *tf 指向一个中断帧（trapframe），这个结构体定义在x86.h这个文件中。当进程中断时，这个变量指向进程对应的中断帧。 struct context *context 切换进程时需要保存的上下文信息，其中context结构体已经在之前介绍过。 void *chan 这是一个与睡眠&amp;唤醒有关的数据，如果chan不为空，说明当前进程在chan上休眠，其中chan指的是一个等待队列（wait channel），在xv6中通过调用sleep(chan)来让进程在一个chan上休眠，用wakeup(chan)唤醒一个chan上的进程。 int killed 当killed不为0时，说明这个进程被杀死 struct file *ofile[NOFILE] 打开的文件，其中struct file是一个与文件有关的结构，这里暂且不详细说明。 struct inode *cwd 当前工作目录 char name[16] 进程的名称，debug用 proc.c 在proc.c中，首先定义了一个重要的数据结构ptable，在xv6中，所有的进程信息都储存在这个结构中，这个结构体如下所示： 1234struct &#123; struct spinlock lock; struct proc proc[NPROC];&#125; ptable; 其中spinloc lock是一个互斥锁。NPROC为xv6中进程数量的上限，定义在param.h中，在xv6，进程的上限数为64。 allocproc()函数，该函数的主要功能为在ptable中寻找一个空位，如果找到空位，则创建一个新的进程，并返回指向该进程的一个指针。 该函数的声明为static struct proc* allocproc(void)。 首先，函数遍历ptable中的proc数组，如果找到了一个空位置，则继续之后的工作，如果遍历全部之后还没有找到则直接返回0（NULL指针），代码如下所示。其中涉及到了acquire()和release()这两个与锁有关的函数，不是我们这一节的重点，暂时忽略。 1234567891011121314static struct proc*allocproc(void)&#123; /* part 1 */ struct proc *p; char *sp; acquire(&amp;ptable.lock); for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) if(p-&gt;state == UNUSED) goto found; release(&amp;ptable.lock); return 0;&#125; 在运行goto found之后，p即为一个状态为UNUSED的proc位置，将这个进程设置为EMBRYO状态，并且分配一个pid。其中pid由全局变量nextpid来分配，每分配一个新的pid，nextpid进行一次自增操作。该部分代码如下。 123456789static struct proc*allocproc(void)&#123; /* part 2 */found: p-&gt;state = EMBRYO; p-&gt;pid = nextpid++; release(&amp;ptable.lock);&#125; 之后，需要为内核栈分配空间，需要调用定义在kalloc.c中的kalloc()函数，如果分配失败，该进程并不能顺利创建，则将进程的状态重新设置为UNUSED并返回空指针。代码如下。 123456789static struct proc*allocproc(void)&#123; /* part 3 */ if((p-&gt;kstack = kalloc()) == 0)&#123; p-&gt;state = UNUSED; return 0; &#125;&#125; 之后，要对内核栈的其他部分进行建立，最终结构如下图所示（代码略） 在allocproc()中的最后一步为p-&gt;context-&gt;eip = (uint)forkret，使得新进程首先运行在forkret这个函数中，该函数中判断了是否为第一个创建的线程，之后就没有做别的事情，直接返回，返回后会进入trapret函数，trapret为从中断中返回的函数，该函数定义在trapasm.S中，用于恢复用户寄存器，恢复后使用iret从中断中返回。 userinit()函数，用于创建第一个进程。在xv6中，main()函数初始化了一些设备和子系统后，会调用该函数创建第一个进程。在该函数中，首先调用allocproc()在分配一个进程并进行初始化，之后调用setupkvm()创建一个映射内核区的页表，这个函数设计虚拟内存相关知识，这里不详细说明。最终得到如下结构： 之后，userinit()函数将trapframe设为初始的用户模式状态，该部分代码如下： 1234567p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; 3) | DPL_USER; p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; 3) | DPL_USER; p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds; p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds; p-&gt;tf-&gt;eflags = FL_IF; p-&gt;tf-&gt;esp = PGSIZE; p-&gt;tf-&gt;eip = 0; // beginning of initcode.S 这里我们主要关注最后一行代码，将trapframe的eip设为了0，这是初始化代码initcode.S的入口 最后，设置进程状态为RUNNABLE，正式开始工作。 fork()函数。除了第一个进程之外，其他的进程都是由父进程调用fork()创建的，实现过程如下。 首先，分配一个进程。 123// Allocate process.if ((np = allocproc()) == 0) return -1; 之后复制父进程的地址空间，如果失败（返回值不为0）则回收进程空间并返回一个错误。 1234567891011if ((np-&gt;pgdir = copyuvm(proc-&gt;pgdir, proc-&gt;sz)) == 0) &#123; kfree(np-&gt;kstack); np-&gt;kstack = 0; np-&gt;state = UNUSED; return -1; &#125;// 如果成功，则复制以下信息np-&gt;sz = proc-&gt;sz;np-&gt;parent = proc;*np-&gt;tf = *proc-&gt;tf; 之后，设置np-&gt;tf-&gt;eax = 0，当子进程从中断返回时，会返回0。 然后子进程继承父进程打开的文件、当前工作目录以及父进程的名字。 12345678for (i = 0; i &lt; NOFILE; i++) if (proc-&gt;ofile[i]) np-&gt;ofile[i] = filedup(proc-&gt;ofile[i]);np-&gt;cwd = idup(proc-&gt;cwd); pid = np-&gt;pid;np-&gt;state = RUNNABLE;safestrcpy(np-&gt;name, proc-&gt;name, sizeof(proc-&gt;name)); 最后，在父进程中返回pid，其中pid由pid = np-&gt;pid得到，是子进程的pid。 exit()函数，退出当前进程，退出的进程会变为ZOMBIE状态直到它的父进程调用wait()来发现它已经退出。实现过程如下。 首先关闭所有的文件，之后调用wakeup1()来唤醒父进程（这里会先加锁所以父进程并不会马上唤醒）。如果当前进程有子进程，则需要设置子进程的父进程变为initproc。最后，将当前进程的状态设置为ZOMBIE。 wait()函数，等待一个子进程退出，返回子进程的pid，如果没有子进程则返回-1。实现流程如下。（代码略） 遍历ptable中的proc数组，查找是否有子进程，如果有子进程则会将一个havekids标记为1，如果循环了一遍后havekids还是0，则直接返回-1。如果有子进程但是子进程未退出，则会调用sleep()来等待子进程唤醒。在发现处于ZOMBIE状态的子进程之后会释放子进程空间的使用，将这个进程块的状态设置为UNUSED，最后返回子进程的pid。 scheduler()函数，该函数会被每个CPU都调用，该函数会遍历进程表，找到一个状态为RUNNABLE的进程来执行，如果没找到则会把当前CPU的proc（表示当前CPU正在执行的进程）设为空指针。其核心代码如下 1234567891011for (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123; if (p-&gt;state != RUNNABLE) continue; proc = p; switchuvm(p); p-&gt;state = RUNNING; swtch(&amp;cpu-&gt;scheduler, proc-&gt;context); switchkvm(); proc = 0;&#125; 当找到一个处于RUNNABLE状态的进程后，会调用三个重要的函数switchuvm(),swtch()以及switchkvm()。其中switchuvm()会根据proc结构中的pgdir来找到当前进程需要使用的页表，并进行切换。swtch是一个使用汇编编写的函数，在swtch.S中编写，用于保存当前进程的上下文，然后返回到要切换的进程的上下文（cpu-&gt;scheduler）中。switchkvm()用于切换到内核页表。 在xv6中的实现里，这个调度函数采用了最简单的实现方法：直接遍历进程数组寻找，在真实的操作系统中往往会采用更复杂的调度算法来获得更好的体验。 总结及收获略","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"课程作业/操作系统","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.kinami.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"《操作系统》xv6阅读报告之进程调度","slug":"《操作系统》xv6阅读报告之进程调度","date":"2021-04-13T17:08:05.000Z","updated":"2021-04-13T17:11:11.619Z","comments":true,"path":"2021/04/14/《操作系统》xv6阅读报告之进程调度/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/","excerpt":"","text":"概述本次XV6源码阅读，主要是在上次阅读进程模型的基础上，进一步研究xv6中在进程调度方面的细节。主要需要阅读的代码文件和上次类似，有以下这些：| 文件名 | 主要功能 || ———- | ———————————————————— || proc.h | 主要声明了三个struct:cpu,context,proc，分别是内核中的CPU、上下文以及我们重点关注的PCB信息，除此之外还定义了一个枚举型，定义了xv6中进程的可能状态 || proc.c | 声明了进程表的数据结构ptable以及与进程有关的核心函数，在本次报告中会对这些函数详细解读 || vm.c | 实现了一些与虚拟内存有关的函数，其中与进程有关的部分包括为内核和用户分配内存，切换到当前进程页面的switchuvm()，切换到内核页面的switchkvm()，以及用于拷贝父进程空间到子进程空间的copyuvm()等 || swtch.S | 用汇编实现的一个用于切换上下文的函数 || kalloc.c | 主要实现了用于分配和释放物理内存的kalloc()以及kfree() |除此之外，还有定义了一些数据结构的其他头文件，这里不特别列出，在用到的时候会说明。在本次报告中，我们主要关注进程相关的内容，即proc.h和proc.c这两个文件中的内容。 核心代码解读proc.h该部分说明直接复用上次阅读报告，因为定义的结构体之后要用到。在proc.h中，定义了以下数据： struct cpu：这是CPU在呢何种的表示，在这个结构体中，会有一个指向struct proc的指针，用于表示当前正在执行的进程。此外还声明了一个cpus数组，用于支持多核处理器。 struct context，表示上下文信息的一个结构体，如下所示： 1234567struct context &#123; uint edi; uint esi; uint ebx; uint ebp; uint eip;&#125;; struct proc，这是XV6中的进程控制块（PCB），如下所示： 12345678910111213141516struct proc &#123; uint sz; pde_t* pgdir; char *kstack; enum procstate state; volatile int pid; struct proc *parent; struct trapframe *tf; struct context *context; void *chan; int killed; struct file *ofile[NOFILE]; struct inode *cwd; char name[16];&#125;; 其中各个数据项的详细意义如下： 数据 功能 uint sz 进程内存空间的大小，单位为byte pde_t* pgdir 指向进程的page table char *kstack 指向内核栈的底部 enum procstate state 表示内核当前的状态，其中enum procstate是一个枚举结构，该枚举结构的定义为 enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;除了未使用（UNUSED）状态之外，进程共有五种状态。 volatile int pid 进程的id struct proc *parent 指向父进程结构 struct trapframe *tf 指向一个中断帧（trapframe），这个结构体定义在x86.h这个文件中。当进程中断时，这个变量指向进程对应的中断帧。 struct context *context 切换进程时需要保存的上下文信息，其中context结构体已经在之前介绍过。 void *chan 这是一个与睡眠&amp;唤醒有关的数据，如果chan不为空，说明当前进程在chan上休眠，其中chan指的是一个等待队列（wait channel），在xv6中通过调用sleep(chan)来让进程在一个chan上休眠，用wakeup(chan)唤醒一个chan上的进程。 int killed 当killed不为0时，说明这个进程被杀死 struct file *ofile[NOFILE] 打开的文件，其中struct file是一个与文件有关的结构，这里暂且不详细说明。 struct inode *cwd 当前工作目录 char name[16] 进程的名称，debug用 proc.c scheduler()函数 在proc.c中，实现了一个跟进程调度有关的函数scheduler()，该函数不接受参数也没有返回值，作用为遍历进程表，找到一个状态为RUNNABLE的进程来执行。代码如下： 1234567891011for (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) &#123; if (p-&gt;state != RUNNABLE) continue; proc = p; switchuvm(p); p-&gt;state = RUNNING; swtch(&amp;cpu-&gt;scheduler, proc-&gt;context); switchkvm(); proc = 0; &#125; 其中ptable.proc是一个储存着所有proc结构体的数组，该函数从数组的第一个元素开始进行遍历（在实际的工作中其实是从前一次切换的位置开始遍历，这个我们之后说明），当找到一个状态为RUNNABLE的进程之后，会调用三个重要的函数switchuvm(),swtch()以及switchkvm()。其中switchuvm()会根据proc结构中的pgdir来找到当前进程需要使用的页表，并进行切换。swtch是一个使用汇编编写的函数，在swtch.S中编写，用于保存当前进程的上下文，然后返回到要切换的进程的上下文（cpu-&gt;scheduler）中。switchkvm()用于切换到内核页表。由代码可见，在xv6的实现里，这个调度函数采用了最简单的实现方法：通过遍历储存着所有进程proc结构的数组来寻找下一个可以开始工作的进程。 在上次报告中，对该部分的解读到此为止，这次我们继续探寻一些细节。 yield()函数 yield()函数代码如下： 1234567void yield(void)&#123; acquire(&amp;ptable.lock); //DOC: yieldlock proc-&gt;state = RUNNABLE; sched(); release(&amp;ptable.lock);&#125; 可见其中的逻辑很简单，主要就是将当前进程的状态设置为RUNNABLE，然后再调用sched()函数 sched()函数 12345678910111213141516void sched(void)&#123; int intena; if (!holding(&amp;ptable.lock)) panic(&quot;sched ptable.lock&quot;); if (cpu-&gt;ncli != 1) panic(&quot;sched locks&quot;); if (proc-&gt;state == RUNNING) panic(&quot;sched running&quot;); if (readeflags() &amp; FL_IF) panic(&quot;sched interruptible&quot;); intena = cpu-&gt;intena; swtch(&amp;proc-&gt;context, cpu-&gt;scheduler); cpu-&gt;intena = intena;&#125; 在该函数中，最重要的一句为swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);即进行上下文切换的语句，关于这里的工作逻辑，在我们分析完下面的代码后进行说明。 swtch.S在这个汇编文件中，实现了一个由汇编写的函数swtch，它是在进程调度时用于保存上下文的核心内容，代码如下 swtch()函数 123456789101112131415161718192021.globl swtchswtch: movl 4(%esp), %eax movl 8(%esp), %edx # Save old callee-save registers pushl %ebp pushl %ebx pushl %esi pushl %edi # Switch stacks movl %esp, (%eax) movl %edx, %esp # Load new callee-save registers popl %edi popl %esi popl %ebx popl %ebp ret 代码的注释中指出，swtch函数接受两个参数:void swtch(struct context **old, struct context *new);，注意两个参数的类型不一样，前一个参数是一个指向context结构指针的指针。 首先3,4两行代码取出了传给swtch的两个参数，其中%eax为old，%edx为new。 7,8,9,10四行则按顺序保存四个寄存器，在保存之前，%esp中存储的内容为返回地址，之后按顺序压入ebp,ebx,esi,edi。操作完成后栈中结构如下： 1234567地址高位 返回地址 ebp ebx esi edi # 现在的栈顶地址地位 可以发现这个结构对应的正是一个context结构，所以此时的%esp可以看作是一个指向一个context结构的指针。之后第13行，将这个指针保存在第一个参数指向的地方（第一个参数是一个指向context指针的指针），这里的实现相对我们做过的Nachos来说不太一样，所以后面会给出整理后的具体调度流程。 之后，第14行将用第二个参数替换栈顶，然后在17-20行恢复寄存器数据，此时的返回地址是要切换到的线程的返回地址，返回后另一个线程直接开始工作。 调度逻辑总结由于xv6是一个支持多核心的操作系统，在xv6中，每个核心都会有自己的一套上下文以及调度器。在上一部分的代码实现中可以看到，swtch函数的一个参数为cpu-&gt;scheduler。这是struct cpu中的一个成员变量，类型为context *，事实上，它指向的是调度器的上下文。 在xv6工作时，每个CPU会启动一个调度器，在main()函数中调用，调度器的完整代码如下所示： scheduler()完整代码 123456789void scheduler(void)&#123; struct proc *p; for (;;) &#123; // 这里是我们之前解读过的核心代码 &#125;&#125; 可见，这个调度器是不会返回的，一直在循环。代码在调度器中运行时，其实是main()函数的上下文，可以认为是主进程的上下文中（之后称为调度器上下文），然后从这里切换到其他的进程。所以在scheduler()中调用swtch函数时第一个参数为&amp;cpu-&gt;scheduler，将当前调度器进程的上下文保存在cpu-&gt;scheduler中，然后切换到目标进程的上下文中。 在当前工作的进程yield()时调用了sched()函数，而在这个函数中，我们可以看到调用swtch的函数为swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);实际上当一个进程yield()之后，是先回到调度器进程中，之后再由调度器进程负责找到下一个进程再切换一次，实际上是两次切换，切换到目标进程的工作是由调度器进程完成的。 总结及收获懂得都懂","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"课程作业/操作系统","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.kinami.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"《计算机网络概论》lab 4 TCP客户端","slug":"《计算机网络概论》lab-4-TCP客户端","date":"2021-04-13T16:49:56.000Z","updated":"2021-04-13T17:10:06.411Z","comments":true,"path":"2021/04/14/《计算机网络概论》lab-4-TCP客户端/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-4-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF/","excerpt":"","text":"实验流程实验要求该次实验主要包含以下四部分 设计TCB结构 处理TCP协议的包的接收（实现stud_tcp_input()函数） 封装TCP包（实现stud_tcp_output()函数） 实现Socket的几个接口函数 需要注意的是，本次实验中只实现了一个客户端角色的TCP协议并使用等停模式。因此客户端的状态可以做以下简化，如实验指导书上所示 然而这里的图画的又跟后面实验指导书上说的有自相矛盾的地方，具体的要求当然是自己去试试怎么样才对（？） 所以本次实验的核心在于定义这些状态并实现这里的状态转换。 实验思路本次实验中，我们首先要定义一个TCP结构如下，我们并不考虑选项部分，所以可以认为urgentPointer之后都是数据段，我们只要原封不动的处理即可。 需要注意的是，在本次实验中，TCP结构统一用网络序表示 123456789101112131415struct TCP&#123; uint16_t srcPort; uint16_t dstPort; uint32_t seqNum; uint32_t ackNum; uint8_t headLen; uint8_t flags; uint16_t windowSize; uint16_t checkSum; uint16_t urgentPointer; char data[2000]; void debugPrint()&#123; /* debug用，这里略 */ &#125;&#125;; 然后，我们设计的TCB结构如下。在本次实验中，我们TCB中的数据以本地序表示。 12345678910111213struct TCB&#123; int sockfd; // 套接字描述符 uint32_t srcAddr; // 源地址 uint16_t srcPort; // 源端口 uint32_t dstAddr; // 目的地址 uint16_t dstPort; // 目的端口 uint32_t seq; // seq uint32_t ack; // ack unsigned int ackExpect; // 应该收到的ack TCPStatus status; // 当前状态 char *data; // 数据段&#125;; 其中TCPStatus是一个枚举类，用于表示各种状态，如下，与实验指导书上给出的状态示例相同。 123456789enum TCPStatus&#123; CLOSED, SYN_SENT, ESTABLISHED, FIN_WAIT1, FIN_WAIT2, TIME_WAIT&#125;; 作为客户端，需要处理当前连接的状态，我们可以在客户端的本地使用一个全局变量来存储状态，如下： 1TCB *currentTCB; 该变量记录了当前的连接信息，每次操作时会查找这里的状态。 另外，由于客户端可能会发起多个连接，拥有多个套接字连接符，因此我们还需要一个机构存储多个连接信息，本次实验中我们使用std::vector来完成，如下： 1vector&lt;TCB *&gt; TCBTable; 另外，在实现各个函数时一定要非常注意字节序的问题。 实验细节实现用于计算check sum的工具函数该函数主要用于计算checkSum，在本次实验中，我们采用所有数据均为网络序的方法来计算checkSum，在实现时要注意。 首先，给出函数定义如下： 1234unsigned int getCheckSum(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr); 其中pBuffer传来的是一个网络序的tcp包，len是这个包的总长度（包括头部），srcAddr和dstAddr是本地序的源地址和目标地址，用于计算伪头信息。 计算伪头部分 这里需要注意的是，由于srcAddr，dstAddr，len都是本地序，因此这里要做一次转换 12345678// 伪头部分unsigned int srcAddr_n = htonl(srcAddr);unsigned int dstAddr_n = htonl(dstAddr);unsigned short len_n = htons(len);checkSum += (srcAddr_n &gt;&gt; 16) + (srcAddr_n &amp; 0xFFFF); // 源地址checkSum += (dstAddr_n &gt;&gt; 16) + (dstAddr_n &amp; 0xFFFF); // 目标地址checkSum += (TCP_PROTOCOL_NUM &lt;&lt; 8); // TCP协议号checkSum += len_n; 计算TCP部分如下，由于pBuffer是一整个结构，而且本身就是网络序，因此我们可以直接转成一个16位整数的数组来操作，会很方便。需要注意跳过原来结构中的checkSum部分，该部分对应第8个16位整数。当TCP的数据部分是奇数字节时，我们需要在末尾补一个全0字节，因此需要特判奇数，代码如下： 12345678910uint16_t *TCPBuffer = (uint16_t *)pBuffer;for (int i = 0; i &lt; len / 2; i++)&#123; if (i == 8) continue; checkSum += TCPBuffer[i]; &#125; // 注意长度的奇偶，要特判奇数 if (len % 2) checkSum += ((uint16_t)(pBuffer[len_h]) &lt;&lt; 8); 最后，我们需要处理高位，将高16位加到低16位上 123// 清除高位while (checkSum &gt;&gt; 16) checkSum = (checkSum &amp; 0xffff) + (checkSum &gt;&gt; 16); 最后的结果应该是现在计算出的值的取反，返回即可 1return (~checkSum) &amp; 0xffff; 实现stud_tcp_input注意！！！！系统调用该函数的时候传进来的地址是网络序！（但是调用系统提供的一些接口函数时却需要传本地序，果然很奇怪啊）。 首先，将传入的pBuffer转换成一个TCP指针，便于之后操作 1TCP *tcp = (TCP *)pBuffer; 首先，检查checksum 这里调用我们刚才的那个函数即可 然而，实际上并不会有这个东西出错的时候，而且实验指导书上也没说出错时应该怎么处理，所以这个不写也没问题（在该系统上） 1234567if (getCheckSum(pBuffer, len, ntohl(srcAddr), ntohl(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum)&#123; // 省略了一些debug显示 // 实验指导书上没定义这个错误？ // tcp_DiscardPkt(pBuffer, checksum_error); return -1;&#125; 然后，检查ack 12345678&#x2F;&#x2F; 检查ackuint32_t ackNum &#x3D; ntohl(tcp-&gt;ackNum);uint32_t seqNum &#x3D; ntohl(tcp-&gt;seqNum);if (ackNum !&#x3D; currentTCB-&gt;ackExpect)&#123; tcp_DiscardPkt(pBuffer, STUD_TCP_TEST_SEQNO_ERROR); return -1;&#125; 之后，是最核心的状态转化的一步，如下： 当前状态为SYN_SENT，接收到的flag为PACKET_TYPE_SYN_ACK，状态转换到ESTABLISHED 123456789101112if (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK)&#123; currentTCB-&gt;status = ESTABLISHED; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0;&#125; 当前状态为ESTABLISHED，继续进行通信 1234567891011if (currentTCB-&gt;status == ESTABLISHED)&#123; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH); stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0;&#125; 当前状态为FIN_WAIT1，接收到的flag为PACKET_TYPE_ACK，状态转化到FIN_WAIT2。 123456if (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK) &#123; currentTCB-&gt;status = FIN_WAIT2; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; return 0;&#125; 当前状态为FIN_WAIT2，接收到的flag为PACKET_TYPE_FIN_ACK，状态转换到TIME_WAIT 12345678910if (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)&#123; currentTCB-&gt;status = TIME_WAIT; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; 实现stud_tcp_output在我们自己实现自己调用的该函数中，参数里的IP地址均为本地序（主要是一开始我以为input那个函数中也是这样） 另外一个需要注意的是，在第一部分的测试中，由于该部分会认为没有实现socket接口，所以不会调用相应的函数，也不会有创建TCB这个过程，所以在调用这个函数时会出错（空指针），因此我们需要在这里加一个surrentPCB的初始化。 初始化currentTCB（只针对第一部分的测试） 1234567891011if (currentTCB == NULL)&#123; currentTCB = new TCB; currentTCB-&gt;status = CLOSED; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcAddr = srcAddr; currentTCB-&gt;dstAddr = dstAddr; currentTCB-&gt;srcPort = srcPort; currentTCB-&gt;dstPort = dstPort;&#125; 创建一个新的tcp结构，并且将pData中的数据复制过去 12TCP *tcp = new TCP;memcpy(tcp-&gt;data, pData, len); 构建TCP头，一定要注意使用网络序 123456789101112131415// 构造TCP头tcp-&gt;srcPort = htons(srcPort);tcp-&gt;dstPort = htons(dstPort);tcp-&gt;seqNum = htonl(currentTCB-&gt;seq);tcp-&gt;ackNum = htonl(currentTCB-&gt;ack);// 注意低四位为空，头长度为5 * 4字节// 二进制格式0x10010000tcp-&gt;headLen = 0x50;tcp-&gt;flags = flag;// 注意这里也要进行一次字节序转换！tcp-&gt;windowSize = htons(1);tcp-&gt;urgentPointer = 0;tcp-&gt;checkSum = 0; // 预清零checkSum// 这里要加上一个头长度！！！！！tcp-&gt;checkSum = getCheckSum((char *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr); 之后，同样是进行状态转换的判断 从CLOSE状态转换到SYN_SENT 123if (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN) currentTCB-&gt;status = SYN_SENT;&#125; 从ESTABLISHED状态转换到FIN_WAIT1 1234if (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)&#123; currentTCB-&gt;status = FIN_WAIT1;&#125; 之后，我们需要根据本次的发送来计算下次应当受到的ack值，以便于之后的校验，如下： 123456789if (currentTCB-&gt;status == ESTABLISHED)&#123; currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len;&#125;else&#123; DebugPrint(&quot;---&gt; Status: %d\\n&quot;, currentTCB-&gt;status); currentTCB-&gt;ackExpect = currentTCB-&gt;seq + 1;&#125; 最后，调用系统提供的函数进行发送 1tcp_sendIpPkt((unsigned char *)tcp, 20 + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, 60); 至此，该函数实现完毕。 实现stud_tcp_socket该函数并不建立连接，只是分配一个套接字标识符。在Linux中，返回的其实就是一个文件描述符，而Linux中文件描述符的0,1,2已经被占用，因此我们这里从3开始分配（虽然没什么差）。实现如下 12345678910111213141516171819202122232425int stud_tcp_socket(int domain, int type, int protocol)&#123; DebugPrint(&quot;---&gt; stud_tcp_socket():\\n&quot;); // 如果TCB表为空，插入三个NULL // socket的返回值应该是一个文件描述符 // Linux中，文件描述符的0,1,2分别为std_in std_out std_err // 所以我们返回的值从3开始 // 另外，我们希望能根据sockfd直接定位TCB，因此这样实现 if (TCBTable.empty()) &#123; TCBTable.push_back(NULL); TCBTable.push_back(NULL); TCBTable.push_back(NULL); &#125; currentTCB = new TCB; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcPort = gSrcPort++; currentTCB-&gt;sockfd = TCBTable.size(); currentTCB-&gt;status = CLOSED; TCBTable.push_back(currentTCB); return currentTCB-&gt;sockfd;&#125; 实现stud_tcp_connect需要注意这个函数参数中的sockaddr_in结构是一个用来存套接字中的IP地址信息的结构，内部一定是大端存储IP地址，因此需要注意字节序转换。 在连接时，需要发送一个包，并且在连接时设置currentTCB 123456789101112131415161718192021222324int stud_tcp_connect(int sockfd, struct sockaddr_in *addr, int addrlen)&#123; currentTCB = TCBTable[sockfd]; // 注意这里的字节序转换 currentTCB-&gt;dstPort = ntohs(addr-&gt;sin_port); currentTCB-&gt;status = SYN_SENT; currentTCB-&gt;srcAddr = getIpv4Address(); currentTCB-&gt;dstAddr = ntohl(addr-&gt;sin_addr.s_addr); // 发送 stud_tcp_output(NULL, 0, PACKET_TYPE_SYN, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); // 等待对方发送的包 TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; // 接收到服务端的包之后调用`stud_tcp_input`处理 return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));&#125; 实现stud_tcp_send由于我们之前已经实现好了stud_tcp_output和stud_tcp_input，因此这里我们直接调用即可。 123456789101112131415161718192021222324int stud_tcp_send(int sockfd, const unsigned char *pData, unsigned short datalen, int flags)&#123; currentTCB = TCBTable[sockfd]; // 当前必须为可以发消息的状态 if (currentTCB-&gt;status == ESTABLISHED) &#123; currentTCB-&gt;data = (char *)pData; stud_tcp_output((char *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); // 等待对方回复 TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; // 调用stud_tcp_input处理 return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125; 实现stud_tcp_recv在该函数中，等待一个对方发来的包并进行处理 123456789101112131415161718int stud_tcp_recv(int sockfd, unsigned char *pData, unsigned short datalen, int flags)&#123; currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; // 等待对方发来的包 TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; memcpy(pData, tcp-&gt;data, len); // 调用stud_tcp_input处理 return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125; 实现stud_tcp_close在本函数中，要注意关闭连接时的四次握手，需要注意我们的顺序问题。 首先，应当调用 stud_tcp_output发送一个flag为PACKET_TYPE_FIN_ACK的请求，之后对方会先发来一个PACKET_TYPE_ACK的包，接收到之后会进入FIN_WAIT2状态，然后需要继续等待对方发送的包，收到PACKET_TYPE_FIN_ACK才正式关闭，因此这里应该等待两次。实现如下： 12345678910111213141516171819202122232425262728293031int stud_tcp_close(int sockfd)&#123; currentTCB = TCBTable[sockfd]; // 在ESTABLISHED状态才能结束 if (currentTCB-&gt;status == ESTABLISHED) &#123; stud_tcp_output(NULL, 0, PACKET_TYPE_FIN_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); // 等待ACK TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); // 等待FIN_ACK tcp = new TCP; len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125; 至此，各实验函数编写完成，并且在系统上测试通过。 实验中遇到的问题 实验指导书上很多比较细节的地方都没说到，例如函数输入参数的字节序问题，在之前的ipv4实验中，参数中的ip地址是本地序，这次要求的stud_tcp_input的参数就成了网络序，但是提供的接口函数tcp_sendIpPkt还是本地序，我之前在宿舍自己写的时候觉得这两个地方要么都网络序要么都本地序，因为之前也是这样，但是去了之后因为这个问题头疼了半天。 实验指导书上有一些矛盾的地方，给出的一些函数（例如tcp_DiscardPkt）其实一直没用到，有些迷惑。 完整代码完整代码再次给出（包括了用于debug的语句等） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468/** THIS FILE IS FOR TCP TEST*//*struct sockaddr_in &#123; short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;;*/#include &quot;sysInclude.h&quot;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define DEBUG#ifdef DEBUG#define DebugPrint(...) printf(__VA_ARGS__)#else#define DebugPrint(...)#endif// ?int gSrcPort = 2005;int gDstPort = 2006;int gSeqNum = 1;int gAckNum = 1;// 外部函数声明extern void tcp_DiscardPkt(char *pBuffer, int type);extern void tcp_sendReport(int type);extern void tcp_sendIpPkt(unsigned char *pData, UINT16 len, unsigned int srcAddr, unsigned int dstAddr, UINT8 ttl);extern int waitIpPacket(char *pBuffer, int timeout);extern unsigned int getIpv4Address();extern unsigned int getServerIpv4Address();// TCP的头占20个字节const int TCP_HEADER_LENGTH = 20;// TCP协议号const int TCP_PROTOCOL_NUM = 0x6;// TCP结构// 永远用网络序！！// 永远用网络序！！// 永远用网络序！！struct TCP&#123; uint16_t srcPort; uint16_t dstPort; uint32_t seqNum; uint32_t ackNum; uint8_t headLen; uint8_t flags; uint16_t windowSize; uint16_t checkSum; uint16_t urgentPointer; char data[2000]; void debugPrint() &#123;#ifdef DEBUG printf(&quot;=========== tcp struct info ===========\\n&quot;); printf(&quot;srcPort = %d\\n&quot;, ntohs(srcPort)); printf(&quot;dstPort = %d\\n&quot;, ntohs(dstPort)); printf(&quot;seqNum = %d\\n&quot;, ntohl(seqNum)); printf(&quot;ackNum = %d\\n&quot;, ntohl(ackNum)); printf(&quot;headLen = %d\\n&quot;, ((headLen &gt;&gt; 4) &amp; 0xf)); printf(&quot;flags = %d\\n&quot;, flags); printf(&quot;windowSize = %d\\n&quot;, ntohl(windowSize))); printf(&quot;checkSum = %d\\n&quot;, ntohl(checkSum)); printf(&quot;urgentPointer = %d\\n&quot;, ntohl(urgentPointer));#endif &#125;&#125;;// TCP状态enum TCPStatus&#123; CLOSED, SYN_SENT, ESTABLISHED, FIN_WAIT1, FIN_WAIT2, TIME_WAIT&#125;;// 传输控制快// 这是保存在本机的结构，永远用主机序！！！struct TCB&#123; int sockfd; // 套接字描述符 uint32_t srcAddr; // 源地址 uint16_t srcPort; // 源端口 uint32_t dstAddr; // 目的地址 uint16_t dstPort; // 目的端口 uint32_t seq; // seq uint32_t ack; // ack unsigned int ackExpect; // 应该收到的ack TCPStatus status; // 当前状态 char *data; // 数据段&#125;;vector&lt;TCB *&gt; TCBTable;TCB *currentTCB;union IpAddr&#123; unsigned int num; struct &#123; unsigned char c1; unsigned char c2; unsigned char c3; unsigned char c4; &#125; ip;&#125;;void printAddr(unsigned int addr)&#123;#ifdef DEBUG union IpAddr ip; ip.num = addr; printf(&quot;%d.%d.%d.%d&quot;, ip.ip.c4, ip.ip.c3, ip.ip.c2, ip.ip.c1);#endif&#125;// 约定传来的pBuffer是网络序// 其他几个应该都是主机序unsigned int getCheckSum(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr)&#123; DebugPrint(&quot;---&gt; In getCheckNum():\\n&quot;); DebugPrint(&quot;---&gt; srcAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n---&gt; dstAddr is :&quot;); printAddr(dstAddr); DebugPrint(&quot;\\n&quot;); unsigned int checkSum = 0; // 伪头部分 unsigned int srcAddr_n = htonl(srcAddr); unsigned int dstAddr_n = htonl(dstAddr); unsigned short len_n = htons(len); checkSum += (srcAddr_n &gt;&gt; 16) + (srcAddr_n &amp; 0xFFFF); // 源地址 checkSum += (dstAddr_n &gt;&gt; 16) + (dstAddr_n &amp; 0xFFFF); // 目标地址 checkSum += (TCP_PROTOCOL_NUM &lt;&lt; 8); // TCP协议号 checkSum += len_n; // TCP长度 uint16_t *TCPBuffer = (uint16_t *)pBuffer; // 计算主机序下的len // 遍历计算 for (int i = 0; i &lt; len / 2; i++) &#123; if (i == 8) continue; checkSum += TCPBuffer[i]; &#125; // 注意长度的奇偶，要特判奇数 if (len % 2) checkSum += ((uint16_t)(pBuffer[len_h]) &lt;&lt; 8); // 清除高位 while (checkSum &gt;&gt; 16) checkSum = (checkSum &amp; 0xffff) + (checkSum &gt;&gt; 16); DebugPrint(&quot;---&gt; Return from getCheckNum(), return value checkSum=%d (hex is %x):\\n&quot;, (~checkSum) &amp; 0xffff, (~checkSum) &amp; 0xffff); // 返回取反的值 return (~checkSum) &amp; 0xffff;&#125;// 传来的是网络序！// 注意这里的srcAddr和dstAddr也是网络序int stud_tcp_input(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); DebugPrint(&quot;---&gt; len is %d:\\n&quot;, len); DebugPrint(&quot;---&gt; srcAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n---&gt; dstAddr is :&quot;); printAddr(dstAddr); DebugPrint(&quot;\\n&quot;); TCP *tcp = (TCP *)pBuffer; // 检查CheckSum if (getCheckSum(pBuffer, len, ntohl(srcAddr), ntohl(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum) &#123; DebugPrint(&quot;---&gt; check sum error\\n&quot;); tcp-&gt;debugPrint(); DebugPrint(&quot;---&gt; your ans: %d\\n&quot;, getCheckSum(pBuffer, len, ntohs(srcAddr), ntohs(dstAddr))); DebugPrint(&quot;---&gt; correct ans: %d\\n&quot;, tcp-&gt;checkSum); // 实验指导书上没定义这个错误？ // tcp_DiscardPkt(pBuffer, checksum_error); return -1; &#125; // 检查ack uint32_t ackNum = ntohl(tcp-&gt;ackNum); uint32_t seqNum = ntohl(tcp-&gt;seqNum); if (ackNum != currentTCB-&gt;ackExpect) &#123; DebugPrint(&quot;---&gt; Error!!! ackNum != currentTCB-&gt;ackExpect\\n&quot;); tcp_DiscardPkt(pBuffer, STUD_TCP_TEST_SEQNO_ERROR); return -1; &#125; // if (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: SYN_SENT to ESTABLISHED\\n&quot;); currentTCB-&gt;status = ESTABLISHED; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; &#125; if (currentTCB-&gt;status == ESTABLISHED) &#123; DebugPrint(&quot;---&gt; Transfer data at Status ESTABLISHED\\n&quot;); currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH); stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; &#125; if (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: FIN_WAIT1 to FIN_WAIT2\\n&quot;); currentTCB-&gt;status = FIN_WAIT2; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; return 0; &#125; if (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: FIN_WAIT2 to TIME_WAIT\\n&quot;); currentTCB-&gt;status = TIME_WAIT; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; &#125; return -1;&#125;// 约定传来的是网络序！（指pData）void stud_tcp_output(char *pData, unsigned short len, unsigned char flag, unsigned short srcPort, unsigned short dstPort, unsigned int srcAddr, unsigned int dstAddr)&#123; DebugPrint(&quot;---&gt; stud_tcp_output():\\n&quot;); DebugPrint(&quot;---&gt; srcAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n---&gt; dstAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n&quot;); if (currentTCB == NULL) &#123; currentTCB = new TCB; currentTCB-&gt;status = CLOSED; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcAddr = srcAddr; currentTCB-&gt;dstAddr = dstAddr; currentTCB-&gt;srcPort = srcPort; currentTCB-&gt;dstPort = dstPort; &#125; TCP *tcp = new TCP; memcpy(tcp-&gt;data, pData, len); // 构造TCP头 tcp-&gt;srcPort = htons(srcPort); tcp-&gt;dstPort = htons(dstPort); tcp-&gt;seqNum = htonl(currentTCB-&gt;seq); tcp-&gt;ackNum = htonl(currentTCB-&gt;ack); // 注意低四位为空，头长度为5 * 4字节 // 二进制格式0x10010000 tcp-&gt;headLen = 0x50; tcp-&gt;flags = flag; // 注意这里也要进行一次字节序转换！ tcp-&gt;windowSize = htons(1); tcp-&gt;urgentPointer = 0; tcp-&gt;checkSum = 0; // 预清零checkSum // 这里要加上一个长度！！！！！ tcp-&gt;checkSum = getCheckSum((char *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr); if (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN) &#123; DebugPrint(&quot;---&gt; Status Change: CLOSED to SYN_SENT\\n&quot;); currentTCB-&gt;status = SYN_SENT; &#125; if (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: ESTABLISHED to FIN_WAIT1\\n&quot;); currentTCB-&gt;status = FIN_WAIT1; &#125; if (currentTCB-&gt;status == ESTABLISHED) &#123; currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len; &#125; else &#123; DebugPrint(&quot;---&gt; Status: %d\\n&quot;, currentTCB-&gt;status); currentTCB-&gt;ackExpect = currentTCB-&gt;seq + 1; &#125; tcp_sendIpPkt((unsigned char *)tcp, 20 + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, 60);&#125;int stud_tcp_socket(int domain, int type, int protocol)&#123; DebugPrint(&quot;---&gt; stud_tcp_socket():\\n&quot;); // 如果TCB表为空，插入三个NULL // socket的返回值应该是一个文件描述符 // Linux中，文件描述符的0,1,2分别为std_in std_out std_err // 所以我们返回的值从3开始 // 另外，我们希望能根据sockfd直接定位TCB，因此这样实现 if (TCBTable.empty()) &#123; TCBTable.push_back(NULL); TCBTable.push_back(NULL); TCBTable.push_back(NULL); &#125; currentTCB = new TCB; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcPort = gSrcPort++; currentTCB-&gt;sockfd = TCBTable.size(); currentTCB-&gt;status = CLOSED; TCBTable.push_back(currentTCB); return currentTCB-&gt;sockfd;&#125;/*struct sockaddr_in &#123; short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;;struct in_addr &#123; in_addr_t s_addr;&#125;;*/int stud_tcp_connect(int sockfd, struct sockaddr_in *addr, int addrlen)&#123; DebugPrint(&quot;---&gt; stud_tcp_connect():\\n&quot;); currentTCB = TCBTable[sockfd]; currentTCB-&gt;dstPort = ntohs(addr-&gt;sin_port); currentTCB-&gt;status = SYN_SENT; currentTCB-&gt;srcAddr = getIpv4Address(); currentTCB-&gt;dstAddr = ntohl(addr-&gt;sin_addr.s_addr); stud_tcp_output(NULL, 0, PACKET_TYPE_SYN, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));&#125;int stud_tcp_send(int sockfd, const unsigned char *pData, unsigned short datalen, int flags)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; currentTCB-&gt;data = (char *)pData; stud_tcp_output((char *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125;int stud_tcp_recv(int sockfd, unsigned char *pData, unsigned short datalen, int flags)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; memcpy(pData, tcp-&gt;data, len); return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125;int stud_tcp_close(int sockfd)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; stud_tcp_output(NULL, 0, PACKET_TYPE_FIN_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); tcp = new TCP; len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"《计算机网络概论》lab 3 ipv4路由","slug":"《计算机网络概论》lab-3-ipv4路由","date":"2021-04-13T16:43:33.000Z","updated":"2021-04-13T17:09:58.982Z","comments":true,"path":"2021/04/14/《计算机网络概论》lab-3-ipv4路由/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-3-ipv4%E8%B7%AF%E7%94%B1/","excerpt":"","text":"实验流程实验要求在前面IPv4分组收发实验的基础上，增加分组转发功能。具体来说，对于每一个到达本机的IPv4分组，根据其目的IPv4地址决定分组的处理行为，对该分组进行如下的几类操作： 向上层协议上交目的地址为本机地址的分组； 根据路由查找结果，丢弃查不到路由的分组； 根据路由查找结果，向相应接口转发不是本机接收的分组。 实验思路在本次实验中，我们首先需要定义一个路由表结构，并且实现一个增加路由的函数。在实验指导书中给出了一种路由结构如下： 123456typedef struct stud_route_msg&#123; unsigned int dest; unsigned int masklen; unsigned int nexthop;&#125; stud_route_msg; 其中，masklen应当指子网掩码中从左往右数的1的个数而不是子网掩码的内容，这一点需要注意。因此，我们的路由表也仿照这样的结构设计即可。需要注意的是，由上层传来的路由表的数据是网络序，为了方便我们转换成本地序处理。 在接受分组时，首先应该查看目的地址是否为本机，然后查看该分组是否已经失效（例如TTL值小于等于0），然后在路由表中查找，查找不到则丢弃。 实验细节路由表的设计路由表设计如下，和实验系统中的设计一致。 123456789struct RouteInfo &#123; unsigned int dest; unsigned int masklen; // 子网掩码的长度（1的个数） unsigned int nexthop; RouteInfo(int d, int m, int n) &#123; dest = d, masklen = m, nexthop = n; &#125;&#125;;vector&lt;RouteInfo&gt; routeTable; //路由表 初始化路由表函数初始化时清空路由表即可。 12345// 初始化路由表void stud_Route_Init() &#123; routeTable.clear(); return;&#125; 增加一条新的路由信息注意需要将网络序转换为本地序。 123456// 增加路由void stud_route_add(stud_route_msg *proute) &#123; RouteInfo t(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop)); routeTable.push_back(t); return;&#125; 系统处理收到的IP分组的函数 首先，读取我们感兴趣的头部信息 12345678// 头部长度 int headerLength = pBuffer[0] &amp; 0xf; // timeToLive int timeToLive = (int) pBuffer[8]; // 头部校验和 int IHL = ntohs(*(unsigned short *) (pBuffer + 10)); // 目的IP地址 int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); 判断timeToLive值是否出错 123456// 判断timeToLiveif (timeToLive &lt;= 0) &#123; // 错误 fwd_DiscardPkt(pBuffer,STUD_FORWARD_TEST_TTLERROR); return 1;&#125; 遍历路由表进行查找 1234567891011121314151617181920212223242526272829303132333435// 遍历路由表for (vector&lt;RouteInfo&gt;::iterator it = routeTable.begin(); it != routeTable.end(); it++) &#123; // 计算子网掩码 unsigned int subnetMask = 0xffffffff &lt;&lt; (32 - it-&gt;masklen); // 查找路由表 if ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123; // 如果找到了应该更新新的head信息 // 构造新的ipv4头部内容 char *buffer = new char[length]; memcpy(buffer, pBuffer, length); // timeToLive-1 buffer[8]--; // 清空checksum，便于之后求和计算 buffer[10] = buffer[11] = 0; // 计算校验和 // sum为计算的和 unsigned short sum = 0; // temp用于辅助计算 unsigned short temp = 0; // 每16字节为一组 for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) buffer[i * 2]) &lt;&lt; 8) + ((unsigned char) buffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; // 计算并填充checkNum unsigned short headCheckSum = htons(0xffff - sum); memcpy(buffer + 10, &amp;headCheckSum, 2); // 发送信息 fwd_SendtoLower(buffer, length, it-&gt;nexthop); return 0; &#125;&#125; 如果遍历之后还没返回，说明没找到路由信息，丢弃。 123// 没有路由器fwd_DiscardPkt(pBuffer, STUD_FORWARD_TEST_NOROUTE);return 1; 至此，实验代码结束，在测试平台上测试通过。 实验中遇到的问题 本次实验较为顺利，没遇到太多的疑难问题。 完整代码完整代码在这里给出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &quot;sysInclude.h&quot;#include &lt;vector&gt;using std::vector;// system supportextern void fwd_LocalRcv(char *pBuffer, int length);extern void fwd_SendtoLower(char *pBuffer, int length, unsigned int nexthop);extern void fwd_DiscardPkt(char *pBuffer, int type);extern unsigned int getIpv4Address();struct RouteInfo &#123; unsigned int dest; unsigned int masklen; // 子网掩码的长度（1的个数） unsigned int nexthop; RouteInfo(int d, int m, int n) &#123; dest = d, masklen = m, nexthop = n; &#125;&#125;;vector&lt;RouteInfo&gt; routeTable; //路由表// 初始化路由表void stud_Route_Init() &#123; routeTable.clear(); return;&#125;// 增加路由void stud_route_add(stud_route_msg *proute) &#123; RouteInfo t(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop)); routeTable.push_back(t); return;&#125;int stud_fwd_deal(char *pBuffer, int length) &#123; // 头部长度 int headerLength = pBuffer[0] &amp; 0xf; // timeToLive int timeToLive = (int) pBuffer[8]; // 头部校验和 int Head_Checksum = ntohs(*(unsigned short *) (pBuffer + 10)); // 目的IP地址 int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); // 如果本机地址等于目的IP地址， 接收 if (dstAddr == getIpv4Address()) &#123; fwd_LocalRcv(pBuffer, length); return 0; &#125; // 判断timeToLive if (timeToLive &lt;= 0) &#123; // 错误 fwd_DiscardPkt(pBuffer, STUD_FORWARD_TEST_TTLERROR); return 1; &#125; // 遍历路由表 for (vector&lt;RouteInfo&gt;::iterator it = routeTable.begin(); it != routeTable.end(); it++) &#123; // 计算子网掩码 unsigned int subnetMask = 0xffffffff &lt;&lt; (32 - it-&gt;masklen); // 查找路由表 if ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123; // 构造新的ipv4头部内容 char *buffer = new char[length]; memcpy(buffer, pBuffer, length); // timeToLive-1 buffer[8]--; // 清空checksum buffer[10] = buffer[11] = 0; // 计算校验和 // sum为计算的和 unsigned short sum = 0; // temp用于辅助计算 unsigned short temp = 0; // 每16字节为一组 for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) buffer[i * 2]) &lt;&lt; 8) + ((unsigned char) buffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; // if (0xffff - sum &lt; temp) // sum = sum + temp + 1; // else // sum = sum + temp; &#125; unsigned short headCheckSum = htons(0xffff - sum); memcpy(buffer + 10, &amp;headCheckSum, 2); fwd_SendtoLower(buffer, length, it-&gt;nexthop); return 0; &#125; &#125; // 没有路由器 fwd_DiscardPkt(pBuffer, STUD_FORWARD_TEST_NOROUTE); return 1;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"《计算机网络概论》lab 2 ipv4分组收发","slug":"《计算机网络概论》lab-2-ipv4分组收发","date":"2021-04-13T16:38:41.000Z","updated":"2021-04-13T17:09:53.008Z","comments":true,"path":"2021/04/14/《计算机网络概论》lab-2-ipv4分组收发/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-2-ipv4%E5%88%86%E7%BB%84%E6%94%B6%E5%8F%91/","excerpt":"","text":"实验流程实验要求根据计算机网络实验系统所提供的上下层接口函数和协议中分组收发的主要流程，独立设计实现一个简单的IPv4分组收发模块。要求实现的主要功能包括： IPv4分组的基本接收处理； IPv4分组的封装发送。 实验思路在本次实验中，最重要的部分是理解IPv4的头部结构，应当使用合适的方法对头部信息进行读取、校验、写入等操作。在实验指导书中给出的头部信息结构如下： 在接收时，使用合适的方法读取并验证头部信息，写入时用合适的方法写入正确的值，就是我们本次实验需要完成的内容。 实验细节IPv4分组的基本接收处理正如之前所述，本次实验的关键在于读取头部信息，首先我们对头部信息进行读取，代码如下： 读取头部信息 在本次实验中，只需读取下列我们感兴趣的信息即可。需要注意的是在读取超过1个字节的值时需要将网络序转换为本地序。 123456// 读取头部信息int version = pBuffer[0] &gt;&gt; 4;int headLength = pBuffer[0] &amp; 0xf; //0b00001111int timeToLive = (unsigned short) pBuffer[8];int headCheckSum = ntohs(*(unsigned short *) (pBuffer + 10));int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); 判断timeToLive值是否出错 12345// TTL值出错if (timeToLive &lt;= 0) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_TTL_ERROR); return 1;&#125; 判断IP版本号是否出错 12345// IP版本号错if (version != 4) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_VERSION_ERROR); return 1;&#125; 判断头部长度是否出错 12345// 头部长度错if (headLength &lt; 5) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_HEADLEN_ERROR); return 1;&#125; 校验checksum，直接把头部的长度按照规则相加，和应该为0xffff 这里要注意的细节是，由于我们用unsigned short进行计算，而checksum的规则要求如果相加大于0xffff，需要把高16位的值加到低16位上，因此，每次相加前我们需要判断相加是否大于0xffff，需要采用判断0xffff - sum和temp的关系来实现来避免溢出，如代码的11行所示。 1234567891011121314151617// 校验checksum// sum为计算的和unsigned short sum = 0;// temp用于辅助计算unsigned short temp = 0;// 每16字节为一组for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) pBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) pBuffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp;&#125;// 如果和不为0xffff，说明出错if (sum != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR); return 1;&#125; 如果经过上面的操作都没有返回，说明该分组没有问题，可以接受，如下 123//成功接受ip_SendtoUp(pBuffer, length);return 0; IPv4分组的封装发送该部分主要需要实现对头部信息的写入。流程如下： 首先，需要创建一个完整的分组结构 1234// 分配空间，头需要20字节，内容字节数为lenchar *IPBuffer = (char *) malloc((20 + len) * sizeof(char));// 将数据初始化为0memset(IPBuffer, 0, len + 20); 填充Version和IHL，内容为0b10001001=0x45，如下 1IPBuffer[0] = 0x45; 计算分组长度，转换成网络序后填写 1234 //分组总长度，需要转换成网络序unsigned short totalLength = htons(len + 20); // 填写total_length信息memcpy(IPBuffer + 2, &amp;totalLength, 2); 填写timeToLive和protocol 12IPBuffer[8] = timeToLive; //timeToLiveIPBuffer[9] = protocol; //协议 填写源地址和目标地址，注意转换成网络序 1234unsigned int src = htonl(srcAddr);unsigned int dst = htonl(dstAddr);memcpy(IPBuffer + 12, &amp;src, 4);memcpy(IPBuffer + 16, &amp;dst, 4); 计算checksum，由于我们在刚开始就使用memset将所有位初始化为了0，因此我们在这里可以用和第一个实验一模一样的代码来计算checksum，放置checksum的字节现在值为0，并不会影响计算，之后，用0xffff减去我们计算的结果就是应该填充的checksum。代码如下： 12345678unsigned short sum = 0;unsigned short temp = 0;// 计算sum// 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以for (int i = 0; i &lt; 10; i++) &#123; temp = (((unsigned char) IPBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) IPBuffer[i * 2 + 1]); 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp;&#125; 以上代码为求和，以下为填充。 1234unsigned short headCheckSum = 0;headCheckSum = htons(0xffff - sum);// 填充checksum值memcpy(IPBuffer + 10, &amp;headCheckSum, 2); 最后，将携带的信息填充并发送即可 123memcpy(IPBuffer + 20, pBuffer, len);ip_SendtoLower(IPBuffer, len + 20);return 0; 至此，实验代码结束，在测试平台上测试通过。 实验中遇到的问题 本次实验较为顺利，没遇到太多的疑难问题。 完整代码完整代码即为将实验细节部分的代码拼凑而成，但还是在这里给出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &quot;sysInclude.h&quot;#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;extern void ip_DiscardPkt(char *pBuffer, int type);extern void ip_SendtoLower(char *pBuffer, int length);extern void ip_SendtoUp(char *pBuffer, int length);extern unsigned int getIpv4Address();// 头部一共有20个字节，以字节为单位结构如下:// pBuffer[0] 高4位为Version 低4位为IHL// pBuffer[1] 高6位为TypeOfService// pBuffer[2]-pBuffer[3] Total Length// pBuffer[4]-pBuffer[5] Identification// pBuffer[6]的第6位第7位分别为MF和DF// pBuffer[6]的前5位+pBuffer[7] 为Fragment offset// pBuffer[8] : time to live// pBuffer[9]: Protocol// pBuffer[10]-pBuffer[11] Header checksum// pBuffer[12]-pBuffer[15] source address // pBuffer[16]-pBuffer[19] destination addressint stud_ip_recv(char *pBuffer, unsigned short length) &#123; // 读取头部信息 int version = pBuffer[0] &gt;&gt; 4; int headLength = pBuffer[0] &amp; 0xf; //0b00001111 int timeToLive = (unsigned short) pBuffer[8]; int headCheckSum = ntohs(*(unsigned short *) (pBuffer + 10)); int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); // TTL值出错 if (timeToLive &lt;= 0) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_TTL_ERROR); return 1; &#125; // IP版本号错 if (version != 4) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_VERSION_ERROR); return 1; &#125; // 头部长度错 if (headLength &lt; 5) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_HEADLEN_ERROR); return 1; &#125; // 目的地址错 if (dstAddr != getIpv4Address() &amp;&amp; dstAddr != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_DESTINATION_ERROR); return 1; &#125; // 校验checksum // sum为计算的和 unsigned short sum = 0; // temp用于辅助计算 unsigned short temp = 0; // 每16字节为一组 for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) pBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) pBuffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; if (sum != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR); return 1; &#125; //成功接受 ip_SendtoUp(pBuffer, length); return 0;&#125;int stud_ip_Upsend(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr, byte protocol, byte timeToLive) &#123; // 分配空间，头需要20字节，内容字节数为len char *IPBuffer = (char *) malloc((20 + len) * sizeof(char)); memset(IPBuffer, 0, len + 20); // pBuffer[0] 高4位为Version 低4位为IHL // 0b10001001 IPBuffer[0] = 0x45; //分组总长度，需要转换成网络序 unsigned short totalLength = htons(len + 20); // 填写total_length信息 memcpy(IPBuffer + 2, &amp;totalLength, 2); IPBuffer[8] = timeToLive; //timeToLive IPBuffer[9] = protocol; //协议 unsigned int src = htonl(srcAddr); unsigned int dst = htonl(dstAddr); memcpy(IPBuffer + 12, &amp;src, 4); //源与目的IP地址 memcpy(IPBuffer + 16, &amp;dst, 4); unsigned short sum = 0; unsigned short temp = 0; // 计算checksum // 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以 for (int i = 0; i &lt; 10; i++) &#123; temp = (((unsigned char) IPBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) IPBuffer[i * 2 + 1]); 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; unsigned short headCheckSum = 0; headCheckSum = htons(0xffff - sum); memcpy(IPBuffer + 10, &amp;headCheckSum, 2); memcpy(IPBuffer + 20, pBuffer, len); ip_SendtoLower(IPBuffer, len + 20); return 0;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"《计算机网络概论》lab 1 滑动窗口","slug":"《计算机网络概论》lab-1-滑动窗口","date":"2021-04-13T12:51:26.000Z","updated":"2021-04-13T17:09:45.303Z","comments":true,"path":"2021/04/13/《计算机网络概论》lab-1-滑动窗口/","link":"","permalink":"http://www.kinami.cc/2021/04/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"实验流程实验要求本次实验要求在一个数据链路层的模拟实现环境下，用C语言实现三个数据链路层协议：1比特滑动窗口协议、回退N帧滑动窗口协议、选择性重传协议。 实验思路通过阅读实验指导书可以发现，回退N帧滑动窗口协议是最重要的一个，其他两个协议都可以看作在此基础上的一点小修改，所以本次实验中最重要的一点是实现回退N帧滑动窗口协议。在回退N帧实验中，系统和我需要实现的函数的函数交互方式如下： 等停协议和回退N帧协议：当发送端需要发送帧时，会调用学生测试函数，并置参数messageType为MSG_TYPE_SEND，测试函数应该将该帧缓存，存入发送队列中。若发送窗口还未打开到规定限度，则打开一个窗口，并将调用SendFRAMEPacket函数将该帧发送。若发送窗口已开到限度，则直接返回，相当于直接进入等待状态。 当发送端收到接收端的ACK 后，会调用学生测试函数，并置参数messageType为MSG_TYPE_RECEIVE，测试函数应该检查ACK值后，将该ACK 对应的窗口关闭。由于关闭了窗口，等待发送的帧可以进入窗口并发送，因此，此时若发送队列中存在等待发送的帧应该将一个等待发送的帧发送并打开一个新的窗口。 发送每发送一个帧，系统都会为他创建一个定时器，当被成功ACK 后，定时器会被取消，若某个帧在定时器超时时间仍未被ACK，系统则会调用测试函数，并置参数messageType 为MSG_TYPE_TIMEOUT，告知测试函数某帧超时，测试函数应该将根据帧序号将该帧以及后面发送过的帧重新发送。 可见，系统通过反复调用我实现的函数，通过messageType来标注是什么样的操作要求。因此我们可以考虑通过switch来区分开不同的操作，每个操作进行单独的实现。除此之外，在运行过程中，还有数据保存要求，所以我们需要全局变量或者静态变量来存储一些数据，考虑到每个函数功能的单独性，用静态变量实现会更优雅，在本次实验中选择这样实现。 实验细节正如之前所述，我将以回退N帧数函数为基础完成整个实验，在此部分进行一些代码细节的说明。首先，定义的一些常量以及结构如下： 两个窗口大小的常量 12#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4 表示帧状态的枚举型 12345typedef enum &#123; data, ack, nak&#125; frame_kind; 系统中定义的frame结构 12345678910typedef struct frame_head &#123; frame_kind kind; // 帧类型 unsigned int seq; // 序列号 unsigned int ack; // 确认号 unsigned char data[100];//数据&#125;;typedef struct frame &#123; frame_head head; //帧头 unsigned int size; //帧的大小&#125;; 自定义的用于存储帧的Buffer结构。其中pBuffer和pFrame指针指向同一片地方只是生命的类型不同，主要是便于之后调用时不再手动强制类型转换。 123456789101112131415161718typedef struct Buffer &#123; unsigned char *pBuffer; // 向`SendFRAMEPacket`函数传的第一个参数 frame *pFrame; // 存储的frame的指针 int bufferSize; // size，向`SendFRAMEPacket`函数传的第二个参数 Buffer() &#123; // 分配一块储存frame的空间 pFrame = new frame(); // 将分配的地址指针赋值给pBuffer pBuffer = (unsigned char *) pFrame; &#125; // 用于储存frame的工具成员函数 void save(char *_pBuffer, int _bufferSize) &#123; // 注意不能是复制指针，而是需要把内容复制过来 (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;; 一个用于通过指针获得ACK的宏函数 1#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack) 之后，回退N帧测试函数stud_slide_window_back_n_frame内定义的用于存储数据的静态变量如下： 12345678910int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; // switch body ....... &#125;&#125; 其中各变量的意义如下： lower: 滑动窗口的下界 upper: 滑动窗口上界的下一个 wait_queue: 由于窗口打开到上限不能直接send的帧的等待队列 WINDOW_SIZE: 在本函数中的窗口大小，每个函数中可能不一样 windows[WINDOW_SIZE]: 用于存储各窗口发出的帧的数组，大小和窗口大小一样 此外，需要注意的是，实际打开的窗口的窗口号下界为lower % WINDOW_SIZE，上界的下一个窗口号为(upper + 1) % WINDOW_SIZE。因为实际窗口号是在一定范围内轮流使用，例如0,1,2,3,0,1,2,...这样，但是如果将下界和上界直接这样表示有时会带来额外的麻烦，例如当窗口大小为1时，只存在一个窗口号0，此时上界的下一个窗口号也还是0，刚开始实现时就是因为这样，导致回退N帧测试函数不能直接修改WINDOW_SIZE来用在等停测试函数中。 之后便是swtich中各个功能的实现，实现细节如下： MSG_TYPE_SEND 123456789101112131415161718case MSG_TYPE_SEND: &#123; // 保存帧的内容 Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); // 发送等待序列中的帧 // 当队列不为空且窗口大小小于最大大小时进行发送。 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; // 从队列头取出一个并发送 Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); // 将发送的帧储存在对应窗口中 windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_RECEIVE 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取收到的ack int ack = GET_ACK(pBuffer); // 从目前的打开的窗口中寻找seq=ack的窗口 for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; // 如果找到，说明i窗口以及之前的窗口已经被成功接受，则下界应当更新为i + 1 lower = i + 1; break; &#125; &#125; // 此时如果能继续发送则继续发送，该部分发送函数的逻辑和`case MSG_TYPE_SEND`中的对应部分一模一样 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_TIMEOUT: 1234567case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break;&#125; 以上便是回退N帧协议的实现细节。在实现中要注意的几个点，从pFrame中读取数据时（在本次实验中要读取的为seq、ack、kind），要注意大小端的转换，直接用ntohl()函数即可。在这种实现中，实现等停协议只需要将WINDOW_SIZE设置成WINDOW_SIZE_STOP_WAIT（即为1）即可，此外不需要任何的修改。 选择性重传函数中，取消了MSG_TYPE_TIMEOUT这种类型，只需要对case MSG_TYPE_RECEIVE做一些修改即可，修改如下： 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取`kind`区分是`ack`还是`nak` int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); // 如果kind是`ack`，和之前的处理一模一样，此处略 if (kind == ack) &#123; /* ... */ &#125; // 如果kind是`nak`，则将帧中的`ack`表示的帧号找出来重发 else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; // 遍历找到缓存的帧中seq等于读出的ack（在这里用变量nak表示）的帧 if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break;&#125; 至此，该实验结束。 实验中遇到的问题 不熟悉实验系统，实验系统对一些错误也不能很好的反馈。例如刚开始的时候，由于代码实现中将Buffer这个辅助结构当成一个class来使用，写了析构函数，并在析构函数中进行了delete操作，但是由于忽略了局部变量作用域的问题，导致了某些指针被重复释放，出了错误，但是在实验系统中并没有报错，只是单纯的卡住不动，最后因为过去的一点点经验想到了可能是指针相关的错误，最后才找到了这个问题。 还没找到很方便的debug方法，在做实验时还是通过最原始的输出log来寻找问题，实验系统中的单步调试功能也没太用习惯。 对大小端转换的问题还没有形成习惯，漏了好几次转换，运行出错了才发现没写。 完整代码由于三个函数的代码重复性很高，而且前面已经给出了详解，因此在完整代码部分删去了注释。代码说明见前面实验细节部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &quot;sysinclude.h&quot;#include &lt;queue&gt;extern void SendFRAMEPacket(unsigned char *pData, unsigned int len);#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4typedef enum &#123; data, ack, nak&#125; frame_kind;typedef struct frame_head &#123; frame_kind kind; unsigned int seq; unsigned int ack; unsigned char data[100];&#125;;typedef struct frame &#123; frame_head head; unsigned int size;&#125;;typedef struct Buffer &#123; unsigned char *pBuffer; frame *pFrame; int bufferSize; Buffer() &#123; pFrame = new frame(); pBuffer = (unsigned char *) pFrame; &#125; void save(char *_pBuffer, int _bufferSize) &#123; (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;;#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)/** 停等协议测试函数*/int stud_slide_window_stop_and_wait(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_STOP_WAIT; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower++; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 回退n帧测试函数*/int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 选择性重传测试函数*/int stud_slide_window_choice_frame_resend(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); if (kind == ack) &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; &#125; else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break; &#125; default: break; &#125; return 0;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}],"categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"课程作业/操作系统","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.kinami.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}