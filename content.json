{"meta":{"title":"kinami's","subtitle":"一点微小的贡献","description":"普通的CS学生/一般通过音游玩家","author":"kinami","url":"http://www.kinami.cc","root":"/"},"pages":[{"title":"关于我","date":"2021-04-13T10:48:11.000Z","updated":"2021-04-13T16:59:57.261Z","comments":true,"path":"about/index.html","permalink":"http://www.kinami.cc/about/index.html","excerpt":"","text":"随便写写"},{"title":"内容分类","date":"2021-04-13T10:44:24.000Z","updated":"2021-04-13T16:57:57.483Z","comments":true,"path":"categories/index.html","permalink":"http://www.kinami.cc/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-13T10:44:38.000Z","updated":"2021-04-13T16:57:54.066Z","comments":true,"path":"tags/index.html","permalink":"http://www.kinami.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《计算机网络概论》lab 4 TCP客户端","slug":"《计算机网络概论》lab-4-TCP客户端","date":"2021-04-13T16:49:56.000Z","updated":"2021-04-13T16:56:32.018Z","comments":true,"path":"2021/04/14/《计算机网络概论》lab-4-TCP客户端/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-4-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF/","excerpt":"","text":"实验流程实验要求该次实验主要包含以下四部分 设计TCB结构 处理TCP协议的包的接收（实现stud_tcp_input()函数） 封装TCP包（实现stud_tcp_output()函数） 实现Socket的几个接口函数 需要注意的是，本次实验中只实现了一个客户端角色的TCP协议并使用等停模式。因此客户端的状态可以做以下简化，如实验指导书上所示 然而这里的图画的又跟后面实验指导书上说的有自相矛盾的地方，具体的要求当然是自己去试试怎么样才对（？） 所以本次实验的核心在于定义这些状态并实现这里的状态转换。 实验思路本次实验中，我们首先要定义一个TCP结构如下，我们并不考虑选项部分，所以可以认为urgentPointer之后都是数据段，我们只要原封不动的处理即可。 需要注意的是，在本次实验中，TCP结构统一用网络序表示 123456789101112131415struct TCP&#123; uint16_t srcPort; uint16_t dstPort; uint32_t seqNum; uint32_t ackNum; uint8_t headLen; uint8_t flags; uint16_t windowSize; uint16_t checkSum; uint16_t urgentPointer; char data[2000]; void debugPrint()&#123; /* debug用，这里略 */ &#125;&#125;; 然后，我们设计的TCB结构如下。在本次实验中，我们TCB中的数据以本地序表示。 12345678910111213struct TCB&#123; int sockfd; // 套接字描述符 uint32_t srcAddr; // 源地址 uint16_t srcPort; // 源端口 uint32_t dstAddr; // 目的地址 uint16_t dstPort; // 目的端口 uint32_t seq; // seq uint32_t ack; // ack unsigned int ackExpect; // 应该收到的ack TCPStatus status; // 当前状态 char *data; // 数据段&#125;; 其中TCPStatus是一个枚举类，用于表示各种状态，如下，与实验指导书上给出的状态示例相同。 123456789enum TCPStatus&#123; CLOSED, SYN_SENT, ESTABLISHED, FIN_WAIT1, FIN_WAIT2, TIME_WAIT&#125;; 作为客户端，需要处理当前连接的状态，我们可以在客户端的本地使用一个全局变量来存储状态，如下： 1TCB *currentTCB; 该变量记录了当前的连接信息，每次操作时会查找这里的状态。 另外，由于客户端可能会发起多个连接，拥有多个套接字连接符，因此我们还需要一个机构存储多个连接信息，本次实验中我们使用std::vector来完成，如下： 1vector&lt;TCB *&gt; TCBTable; 另外，在实现各个函数时一定要非常注意字节序的问题。 实验细节实现用于计算check sum的工具函数该函数主要用于计算checkSum，在本次实验中，我们采用所有数据均为网络序的方法来计算checkSum，在实现时要注意。 首先，给出函数定义如下： 1234unsigned int getCheckSum(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr); 其中pBuffer传来的是一个网络序的tcp包，len是这个包的总长度（包括头部），srcAddr和dstAddr是本地序的源地址和目标地址，用于计算伪头信息。 计算伪头部分 这里需要注意的是，由于srcAddr，dstAddr，len都是本地序，因此这里要做一次转换 12345678// 伪头部分unsigned int srcAddr_n = htonl(srcAddr);unsigned int dstAddr_n = htonl(dstAddr);unsigned short len_n = htons(len);checkSum += (srcAddr_n &gt;&gt; 16) + (srcAddr_n &amp; 0xFFFF); // 源地址checkSum += (dstAddr_n &gt;&gt; 16) + (dstAddr_n &amp; 0xFFFF); // 目标地址checkSum += (TCP_PROTOCOL_NUM &lt;&lt; 8); // TCP协议号checkSum += len_n; 计算TCP部分如下，由于pBuffer是一整个结构，而且本身就是网络序，因此我们可以直接转成一个16位整数的数组来操作，会很方便。需要注意跳过原来结构中的checkSum部分，该部分对应第8个16位整数。当TCP的数据部分是奇数字节时，我们需要在末尾补一个全0字节，因此需要特判奇数，代码如下： 12345678910uint16_t *TCPBuffer = (uint16_t *)pBuffer;for (int i = 0; i &lt; len / 2; i++)&#123; if (i == 8) continue; checkSum += TCPBuffer[i]; &#125; // 注意长度的奇偶，要特判奇数 if (len % 2) checkSum += ((uint16_t)(pBuffer[len_h]) &lt;&lt; 8); 最后，我们需要处理高位，将高16位加到低16位上 123// 清除高位while (checkSum &gt;&gt; 16) checkSum = (checkSum &amp; 0xffff) + (checkSum &gt;&gt; 16); 最后的结果应该是现在计算出的值的取反，返回即可 1return (~checkSum) &amp; 0xffff; 实现stud_tcp_input注意！！！！系统调用该函数的时候传进来的地址是网络序！（但是调用系统提供的一些接口函数时却需要传本地序，果然很奇怪啊）。 首先，将传入的pBuffer转换成一个TCP指针，便于之后操作 1TCP *tcp = (TCP *)pBuffer; 首先，检查checksum 这里调用我们刚才的那个函数即可 然而，实际上并不会有这个东西出错的时候，而且实验指导书上也没说出错时应该怎么处理，所以这个不写也没问题（在该系统上） 1234567if (getCheckSum(pBuffer, len, ntohl(srcAddr), ntohl(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum)&#123; // 省略了一些debug显示 // 实验指导书上没定义这个错误？ // tcp_DiscardPkt(pBuffer, checksum_error); return -1;&#125; 然后，检查ack 12345678&#x2F;&#x2F; 检查ackuint32_t ackNum &#x3D; ntohl(tcp-&gt;ackNum);uint32_t seqNum &#x3D; ntohl(tcp-&gt;seqNum);if (ackNum !&#x3D; currentTCB-&gt;ackExpect)&#123; tcp_DiscardPkt(pBuffer, STUD_TCP_TEST_SEQNO_ERROR); return -1;&#125; 之后，是最核心的状态转化的一步，如下： 当前状态为SYN_SENT，接收到的flag为PACKET_TYPE_SYN_ACK，状态转换到ESTABLISHED 123456789101112if (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK)&#123; currentTCB-&gt;status = ESTABLISHED; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0;&#125; 当前状态为ESTABLISHED，继续进行通信 1234567891011if (currentTCB-&gt;status == ESTABLISHED)&#123; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH); stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0;&#125; 当前状态为FIN_WAIT1，接收到的flag为PACKET_TYPE_ACK，状态转化到FIN_WAIT2。 123456if (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK) &#123; currentTCB-&gt;status = FIN_WAIT2; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; return 0;&#125; 当前状态为FIN_WAIT2，接收到的flag为PACKET_TYPE_FIN_ACK，状态转换到TIME_WAIT 12345678910if (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)&#123; currentTCB-&gt;status = TIME_WAIT; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; 实现stud_tcp_output在我们自己实现自己调用的该函数中，参数里的IP地址均为本地序（主要是一开始我以为input那个函数中也是这样） 另外一个需要注意的是，在第一部分的测试中，由于该部分会认为没有实现socket接口，所以不会调用相应的函数，也不会有创建TCB这个过程，所以在调用这个函数时会出错（空指针），因此我们需要在这里加一个surrentPCB的初始化。 初始化currentTCB（只针对第一部分的测试） 1234567891011if (currentTCB == NULL)&#123; currentTCB = new TCB; currentTCB-&gt;status = CLOSED; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcAddr = srcAddr; currentTCB-&gt;dstAddr = dstAddr; currentTCB-&gt;srcPort = srcPort; currentTCB-&gt;dstPort = dstPort;&#125; 创建一个新的tcp结构，并且将pData中的数据复制过去 12TCP *tcp = new TCP;memcpy(tcp-&gt;data, pData, len); 构建TCP头，一定要注意使用网络序 123456789101112131415// 构造TCP头tcp-&gt;srcPort = htons(srcPort);tcp-&gt;dstPort = htons(dstPort);tcp-&gt;seqNum = htonl(currentTCB-&gt;seq);tcp-&gt;ackNum = htonl(currentTCB-&gt;ack);// 注意低四位为空，头长度为5 * 4字节// 二进制格式0x10010000tcp-&gt;headLen = 0x50;tcp-&gt;flags = flag;// 注意这里也要进行一次字节序转换！tcp-&gt;windowSize = htons(1);tcp-&gt;urgentPointer = 0;tcp-&gt;checkSum = 0; // 预清零checkSum// 这里要加上一个头长度！！！！！tcp-&gt;checkSum = getCheckSum((char *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr); 之后，同样是进行状态转换的判断 从CLOSE状态转换到SYN_SENT 123if (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN) currentTCB-&gt;status = SYN_SENT;&#125; 从ESTABLISHED状态转换到FIN_WAIT1 1234if (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)&#123; currentTCB-&gt;status = FIN_WAIT1;&#125; 之后，我们需要根据本次的发送来计算下次应当受到的ack值，以便于之后的校验，如下： 123456789if (currentTCB-&gt;status == ESTABLISHED)&#123; currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len;&#125;else&#123; DebugPrint(&quot;---&gt; Status: %d\\n&quot;, currentTCB-&gt;status); currentTCB-&gt;ackExpect = currentTCB-&gt;seq + 1;&#125; 最后，调用系统提供的函数进行发送 1tcp_sendIpPkt((unsigned char *)tcp, 20 + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, 60); 至此，该函数实现完毕。 实现stud_tcp_socket该函数并不建立连接，只是分配一个套接字标识符。在Linux中，返回的其实就是一个文件描述符，而Linux中文件描述符的0,1,2已经被占用，因此我们这里从3开始分配（虽然没什么差）。实现如下 12345678910111213141516171819202122232425int stud_tcp_socket(int domain, int type, int protocol)&#123; DebugPrint(&quot;---&gt; stud_tcp_socket():\\n&quot;); // 如果TCB表为空，插入三个NULL // socket的返回值应该是一个文件描述符 // Linux中，文件描述符的0,1,2分别为std_in std_out std_err // 所以我们返回的值从3开始 // 另外，我们希望能根据sockfd直接定位TCB，因此这样实现 if (TCBTable.empty()) &#123; TCBTable.push_back(NULL); TCBTable.push_back(NULL); TCBTable.push_back(NULL); &#125; currentTCB = new TCB; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcPort = gSrcPort++; currentTCB-&gt;sockfd = TCBTable.size(); currentTCB-&gt;status = CLOSED; TCBTable.push_back(currentTCB); return currentTCB-&gt;sockfd;&#125; 实现stud_tcp_connect需要注意这个函数参数中的sockaddr_in结构是一个用来存套接字中的IP地址信息的结构，内部一定是大端存储IP地址，因此需要注意字节序转换。 在连接时，需要发送一个包，并且在连接时设置currentTCB 123456789101112131415161718192021222324int stud_tcp_connect(int sockfd, struct sockaddr_in *addr, int addrlen)&#123; currentTCB = TCBTable[sockfd]; // 注意这里的字节序转换 currentTCB-&gt;dstPort = ntohs(addr-&gt;sin_port); currentTCB-&gt;status = SYN_SENT; currentTCB-&gt;srcAddr = getIpv4Address(); currentTCB-&gt;dstAddr = ntohl(addr-&gt;sin_addr.s_addr); // 发送 stud_tcp_output(NULL, 0, PACKET_TYPE_SYN, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); // 等待对方发送的包 TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; // 接收到服务端的包之后调用`stud_tcp_input`处理 return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));&#125; 实现stud_tcp_send由于我们之前已经实现好了stud_tcp_output和stud_tcp_input，因此这里我们直接调用即可。 123456789101112131415161718192021222324int stud_tcp_send(int sockfd, const unsigned char *pData, unsigned short datalen, int flags)&#123; currentTCB = TCBTable[sockfd]; // 当前必须为可以发消息的状态 if (currentTCB-&gt;status == ESTABLISHED) &#123; currentTCB-&gt;data = (char *)pData; stud_tcp_output((char *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); // 等待对方回复 TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; // 调用stud_tcp_input处理 return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125; 实现stud_tcp_recv在该函数中，等待一个对方发来的包并进行处理 123456789101112131415161718int stud_tcp_recv(int sockfd, unsigned char *pData, unsigned short datalen, int flags)&#123; currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; // 等待对方发来的包 TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; memcpy(pData, tcp-&gt;data, len); // 调用stud_tcp_input处理 return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125; 实现stud_tcp_close在本函数中，要注意关闭连接时的四次握手，需要注意我们的顺序问题。 首先，应当调用 stud_tcp_output发送一个flag为PACKET_TYPE_FIN_ACK的请求，之后对方会先发来一个PACKET_TYPE_ACK的包，接收到之后会进入FIN_WAIT2状态，然后需要继续等待对方发送的包，收到PACKET_TYPE_FIN_ACK才正式关闭，因此这里应该等待两次。实现如下： 12345678910111213141516171819202122232425262728293031int stud_tcp_close(int sockfd)&#123; currentTCB = TCBTable[sockfd]; // 在ESTABLISHED状态才能结束 if (currentTCB-&gt;status == ESTABLISHED) &#123; stud_tcp_output(NULL, 0, PACKET_TYPE_FIN_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); // 等待ACK TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); // 等待FIN_ACK tcp = new TCP; len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125; 至此，各实验函数编写完成，并且在系统上测试通过。 实验中遇到的问题 实验指导书上很多比较细节的地方都没说到，例如函数输入参数的字节序问题，在之前的ipv4实验中，参数中的ip地址是本地序，这次要求的stud_tcp_input的参数就成了网络序，但是提供的接口函数tcp_sendIpPkt还是本地序，我之前在宿舍自己写的时候觉得这两个地方要么都网络序要么都本地序，因为之前也是这样，但是去了之后因为这个问题头疼了半天。 实验指导书上有一些矛盾的地方，给出的一些函数（例如tcp_DiscardPkt）其实一直没用到，有些迷惑。 完整代码完整代码再次给出（包括了用于debug的语句等） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468/** THIS FILE IS FOR TCP TEST*//*struct sockaddr_in &#123; short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;;*/#include &quot;sysInclude.h&quot;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define DEBUG#ifdef DEBUG#define DebugPrint(...) printf(__VA_ARGS__)#else#define DebugPrint(...)#endif// ?int gSrcPort = 2005;int gDstPort = 2006;int gSeqNum = 1;int gAckNum = 1;// 外部函数声明extern void tcp_DiscardPkt(char *pBuffer, int type);extern void tcp_sendReport(int type);extern void tcp_sendIpPkt(unsigned char *pData, UINT16 len, unsigned int srcAddr, unsigned int dstAddr, UINT8 ttl);extern int waitIpPacket(char *pBuffer, int timeout);extern unsigned int getIpv4Address();extern unsigned int getServerIpv4Address();// TCP的头占20个字节const int TCP_HEADER_LENGTH = 20;// TCP协议号const int TCP_PROTOCOL_NUM = 0x6;// TCP结构// 永远用网络序！！// 永远用网络序！！// 永远用网络序！！struct TCP&#123; uint16_t srcPort; uint16_t dstPort; uint32_t seqNum; uint32_t ackNum; uint8_t headLen; uint8_t flags; uint16_t windowSize; uint16_t checkSum; uint16_t urgentPointer; char data[2000]; void debugPrint() &#123;#ifdef DEBUG printf(&quot;=========== tcp struct info ===========\\n&quot;); printf(&quot;srcPort = %d\\n&quot;, ntohs(srcPort)); printf(&quot;dstPort = %d\\n&quot;, ntohs(dstPort)); printf(&quot;seqNum = %d\\n&quot;, ntohl(seqNum)); printf(&quot;ackNum = %d\\n&quot;, ntohl(ackNum)); printf(&quot;headLen = %d\\n&quot;, ((headLen &gt;&gt; 4) &amp; 0xf)); printf(&quot;flags = %d\\n&quot;, flags); printf(&quot;windowSize = %d\\n&quot;, ntohl(windowSize))); printf(&quot;checkSum = %d\\n&quot;, ntohl(checkSum)); printf(&quot;urgentPointer = %d\\n&quot;, ntohl(urgentPointer));#endif &#125;&#125;;// TCP状态enum TCPStatus&#123; CLOSED, SYN_SENT, ESTABLISHED, FIN_WAIT1, FIN_WAIT2, TIME_WAIT&#125;;// 传输控制快// 这是保存在本机的结构，永远用主机序！！！struct TCB&#123; int sockfd; // 套接字描述符 uint32_t srcAddr; // 源地址 uint16_t srcPort; // 源端口 uint32_t dstAddr; // 目的地址 uint16_t dstPort; // 目的端口 uint32_t seq; // seq uint32_t ack; // ack unsigned int ackExpect; // 应该收到的ack TCPStatus status; // 当前状态 char *data; // 数据段&#125;;vector&lt;TCB *&gt; TCBTable;TCB *currentTCB;union IpAddr&#123; unsigned int num; struct &#123; unsigned char c1; unsigned char c2; unsigned char c3; unsigned char c4; &#125; ip;&#125;;void printAddr(unsigned int addr)&#123;#ifdef DEBUG union IpAddr ip; ip.num = addr; printf(&quot;%d.%d.%d.%d&quot;, ip.ip.c4, ip.ip.c3, ip.ip.c2, ip.ip.c1);#endif&#125;// 约定传来的pBuffer是网络序// 其他几个应该都是主机序unsigned int getCheckSum(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr)&#123; DebugPrint(&quot;---&gt; In getCheckNum():\\n&quot;); DebugPrint(&quot;---&gt; srcAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n---&gt; dstAddr is :&quot;); printAddr(dstAddr); DebugPrint(&quot;\\n&quot;); unsigned int checkSum = 0; // 伪头部分 unsigned int srcAddr_n = htonl(srcAddr); unsigned int dstAddr_n = htonl(dstAddr); unsigned short len_n = htons(len); checkSum += (srcAddr_n &gt;&gt; 16) + (srcAddr_n &amp; 0xFFFF); // 源地址 checkSum += (dstAddr_n &gt;&gt; 16) + (dstAddr_n &amp; 0xFFFF); // 目标地址 checkSum += (TCP_PROTOCOL_NUM &lt;&lt; 8); // TCP协议号 checkSum += len_n; // TCP长度 uint16_t *TCPBuffer = (uint16_t *)pBuffer; // 计算主机序下的len // 遍历计算 for (int i = 0; i &lt; len / 2; i++) &#123; if (i == 8) continue; checkSum += TCPBuffer[i]; &#125; // 注意长度的奇偶，要特判奇数 if (len % 2) checkSum += ((uint16_t)(pBuffer[len_h]) &lt;&lt; 8); // 清除高位 while (checkSum &gt;&gt; 16) checkSum = (checkSum &amp; 0xffff) + (checkSum &gt;&gt; 16); DebugPrint(&quot;---&gt; Return from getCheckNum(), return value checkSum=%d (hex is %x):\\n&quot;, (~checkSum) &amp; 0xffff, (~checkSum) &amp; 0xffff); // 返回取反的值 return (~checkSum) &amp; 0xffff;&#125;// 传来的是网络序！// 注意这里的srcAddr和dstAddr也是网络序int stud_tcp_input(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); DebugPrint(&quot;---&gt; len is %d:\\n&quot;, len); DebugPrint(&quot;---&gt; srcAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n---&gt; dstAddr is :&quot;); printAddr(dstAddr); DebugPrint(&quot;\\n&quot;); TCP *tcp = (TCP *)pBuffer; // 检查CheckSum if (getCheckSum(pBuffer, len, ntohl(srcAddr), ntohl(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum) &#123; DebugPrint(&quot;---&gt; check sum error\\n&quot;); tcp-&gt;debugPrint(); DebugPrint(&quot;---&gt; your ans: %d\\n&quot;, getCheckSum(pBuffer, len, ntohs(srcAddr), ntohs(dstAddr))); DebugPrint(&quot;---&gt; correct ans: %d\\n&quot;, tcp-&gt;checkSum); // 实验指导书上没定义这个错误？ // tcp_DiscardPkt(pBuffer, checksum_error); return -1; &#125; // 检查ack uint32_t ackNum = ntohl(tcp-&gt;ackNum); uint32_t seqNum = ntohl(tcp-&gt;seqNum); if (ackNum != currentTCB-&gt;ackExpect) &#123; DebugPrint(&quot;---&gt; Error!!! ackNum != currentTCB-&gt;ackExpect\\n&quot;); tcp_DiscardPkt(pBuffer, STUD_TCP_TEST_SEQNO_ERROR); return -1; &#125; // if (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: SYN_SENT to ESTABLISHED\\n&quot;); currentTCB-&gt;status = ESTABLISHED; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; &#125; if (currentTCB-&gt;status == ESTABLISHED) &#123; DebugPrint(&quot;---&gt; Transfer data at Status ESTABLISHED\\n&quot;); currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH); stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; &#125; if (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: FIN_WAIT1 to FIN_WAIT2\\n&quot;); currentTCB-&gt;status = FIN_WAIT2; currentTCB-&gt;seq = ackNum; currentTCB-&gt;ack = seqNum + 1; return 0; &#125; if (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: FIN_WAIT2 to TIME_WAIT\\n&quot;); currentTCB-&gt;status = TIME_WAIT; stud_tcp_output(NULL, 0, PACKET_TYPE_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); return 0; &#125; return -1;&#125;// 约定传来的是网络序！（指pData）void stud_tcp_output(char *pData, unsigned short len, unsigned char flag, unsigned short srcPort, unsigned short dstPort, unsigned int srcAddr, unsigned int dstAddr)&#123; DebugPrint(&quot;---&gt; stud_tcp_output():\\n&quot;); DebugPrint(&quot;---&gt; srcAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n---&gt; dstAddr is :&quot;); printAddr(srcAddr); DebugPrint(&quot;\\n&quot;); if (currentTCB == NULL) &#123; currentTCB = new TCB; currentTCB-&gt;status = CLOSED; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcAddr = srcAddr; currentTCB-&gt;dstAddr = dstAddr; currentTCB-&gt;srcPort = srcPort; currentTCB-&gt;dstPort = dstPort; &#125; TCP *tcp = new TCP; memcpy(tcp-&gt;data, pData, len); // 构造TCP头 tcp-&gt;srcPort = htons(srcPort); tcp-&gt;dstPort = htons(dstPort); tcp-&gt;seqNum = htonl(currentTCB-&gt;seq); tcp-&gt;ackNum = htonl(currentTCB-&gt;ack); // 注意低四位为空，头长度为5 * 4字节 // 二进制格式0x10010000 tcp-&gt;headLen = 0x50; tcp-&gt;flags = flag; // 注意这里也要进行一次字节序转换！ tcp-&gt;windowSize = htons(1); tcp-&gt;urgentPointer = 0; tcp-&gt;checkSum = 0; // 预清零checkSum // 这里要加上一个长度！！！！！ tcp-&gt;checkSum = getCheckSum((char *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr); if (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN) &#123; DebugPrint(&quot;---&gt; Status Change: CLOSED to SYN_SENT\\n&quot;); currentTCB-&gt;status = SYN_SENT; &#125; if (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK) &#123; DebugPrint(&quot;---&gt; Status Change: ESTABLISHED to FIN_WAIT1\\n&quot;); currentTCB-&gt;status = FIN_WAIT1; &#125; if (currentTCB-&gt;status == ESTABLISHED) &#123; currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len; &#125; else &#123; DebugPrint(&quot;---&gt; Status: %d\\n&quot;, currentTCB-&gt;status); currentTCB-&gt;ackExpect = currentTCB-&gt;seq + 1; &#125; tcp_sendIpPkt((unsigned char *)tcp, 20 + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, 60);&#125;int stud_tcp_socket(int domain, int type, int protocol)&#123; DebugPrint(&quot;---&gt; stud_tcp_socket():\\n&quot;); // 如果TCB表为空，插入三个NULL // socket的返回值应该是一个文件描述符 // Linux中，文件描述符的0,1,2分别为std_in std_out std_err // 所以我们返回的值从3开始 // 另外，我们希望能根据sockfd直接定位TCB，因此这样实现 if (TCBTable.empty()) &#123; TCBTable.push_back(NULL); TCBTable.push_back(NULL); TCBTable.push_back(NULL); &#125; currentTCB = new TCB; currentTCB-&gt;ack = gAckNum; currentTCB-&gt;seq = gSeqNum; currentTCB-&gt;srcPort = gSrcPort++; currentTCB-&gt;sockfd = TCBTable.size(); currentTCB-&gt;status = CLOSED; TCBTable.push_back(currentTCB); return currentTCB-&gt;sockfd;&#125;/*struct sockaddr_in &#123; short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;;struct in_addr &#123; in_addr_t s_addr;&#125;;*/int stud_tcp_connect(int sockfd, struct sockaddr_in *addr, int addrlen)&#123; DebugPrint(&quot;---&gt; stud_tcp_connect():\\n&quot;); currentTCB = TCBTable[sockfd]; currentTCB-&gt;dstPort = ntohs(addr-&gt;sin_port); currentTCB-&gt;status = SYN_SENT; currentTCB-&gt;srcAddr = getIpv4Address(); currentTCB-&gt;dstAddr = ntohl(addr-&gt;sin_addr.s_addr); stud_tcp_output(NULL, 0, PACKET_TYPE_SYN, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));&#125;int stud_tcp_send(int sockfd, const unsigned char *pData, unsigned short datalen, int flags)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; currentTCB-&gt;data = (char *)pData; stud_tcp_output((char *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125;int stud_tcp_recv(int sockfd, unsigned char *pData, unsigned short datalen, int flags)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; memcpy(pData, tcp-&gt;data, len); return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125;int stud_tcp_close(int sockfd)&#123; DebugPrint(&quot;---&gt; In stud_tcp_input():\\n&quot;); currentTCB = TCBTable[sockfd]; if (currentTCB-&gt;status == ESTABLISHED) &#123; stud_tcp_output(NULL, 0, PACKET_TYPE_FIN_ACK, currentTCB-&gt;srcPort, currentTCB-&gt;dstPort, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr); TCP *tcp = new TCP; int len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); tcp = new TCP; len = waitIpPacket((char *)tcp, 1000); while (len == -1) &#123; len = waitIpPacket((char *)tcp, 1000); &#125; return stud_tcp_input((char *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr)); &#125; return -1;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"《计算机网络概论》lab 3 ipv4路由","slug":"《计算机网络概论》lab-3-ipv4路由","date":"2021-04-13T16:43:33.000Z","updated":"2021-04-13T16:56:24.745Z","comments":true,"path":"2021/04/14/《计算机网络概论》lab-3-ipv4路由/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-3-ipv4%E8%B7%AF%E7%94%B1/","excerpt":"","text":"实验流程实验要求在前面IPv4分组收发实验的基础上，增加分组转发功能。具体来说，对于每一个到达本机的IPv4分组，根据其目的IPv4地址决定分组的处理行为，对该分组进行如下的几类操作： 向上层协议上交目的地址为本机地址的分组； 根据路由查找结果，丢弃查不到路由的分组； 根据路由查找结果，向相应接口转发不是本机接收的分组。 实验思路在本次实验中，我们首先需要定义一个路由表结构，并且实现一个增加路由的函数。在实验指导书中给出了一种路由结构如下： 123456typedef struct stud_route_msg&#123; unsigned int dest; unsigned int masklen; unsigned int nexthop;&#125; stud_route_msg; 其中，masklen应当指子网掩码中从左往右数的1的个数而不是子网掩码的内容，这一点需要注意。因此，我们的路由表也仿照这样的结构设计即可。需要注意的是，由上层传来的路由表的数据是网络序，为了方便我们转换成本地序处理。 在接受分组时，首先应该查看目的地址是否为本机，然后查看该分组是否已经失效（例如TTL值小于等于0），然后在路由表中查找，查找不到则丢弃。 实验细节路由表的设计路由表设计如下，和实验系统中的设计一致。 123456789struct RouteInfo &#123; unsigned int dest; unsigned int masklen; // 子网掩码的长度（1的个数） unsigned int nexthop; RouteInfo(int d, int m, int n) &#123; dest = d, masklen = m, nexthop = n; &#125;&#125;;vector&lt;RouteInfo&gt; routeTable; //路由表 初始化路由表函数初始化时清空路由表即可。 12345// 初始化路由表void stud_Route_Init() &#123; routeTable.clear(); return;&#125; 增加一条新的路由信息注意需要将网络序转换为本地序。 123456// 增加路由void stud_route_add(stud_route_msg *proute) &#123; RouteInfo t(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop)); routeTable.push_back(t); return;&#125; 系统处理收到的IP分组的函数 首先，读取我们感兴趣的头部信息 12345678// 头部长度 int headerLength = pBuffer[0] &amp; 0xf; // timeToLive int timeToLive = (int) pBuffer[8]; // 头部校验和 int IHL = ntohs(*(unsigned short *) (pBuffer + 10)); // 目的IP地址 int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); 判断timeToLive值是否出错 123456// 判断timeToLiveif (timeToLive &lt;= 0) &#123; // 错误 fwd_DiscardPkt(pBuffer,STUD_FORWARD_TEST_TTLERROR); return 1;&#125; 遍历路由表进行查找 1234567891011121314151617181920212223242526272829303132333435// 遍历路由表for (vector&lt;RouteInfo&gt;::iterator it = routeTable.begin(); it != routeTable.end(); it++) &#123; // 计算子网掩码 unsigned int subnetMask = 0xffffffff &lt;&lt; (32 - it-&gt;masklen); // 查找路由表 if ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123; // 如果找到了应该更新新的head信息 // 构造新的ipv4头部内容 char *buffer = new char[length]; memcpy(buffer, pBuffer, length); // timeToLive-1 buffer[8]--; // 清空checksum，便于之后求和计算 buffer[10] = buffer[11] = 0; // 计算校验和 // sum为计算的和 unsigned short sum = 0; // temp用于辅助计算 unsigned short temp = 0; // 每16字节为一组 for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) buffer[i * 2]) &lt;&lt; 8) + ((unsigned char) buffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; // 计算并填充checkNum unsigned short headCheckSum = htons(0xffff - sum); memcpy(buffer + 10, &amp;headCheckSum, 2); // 发送信息 fwd_SendtoLower(buffer, length, it-&gt;nexthop); return 0; &#125;&#125; 如果遍历之后还没返回，说明没找到路由信息，丢弃。 123// 没有路由器fwd_DiscardPkt(pBuffer, STUD_FORWARD_TEST_NOROUTE);return 1; 至此，实验代码结束，在测试平台上测试通过。 实验中遇到的问题 本次实验较为顺利，没遇到太多的疑难问题。 完整代码完整代码在这里给出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &quot;sysInclude.h&quot;#include &lt;vector&gt;using std::vector;// system supportextern void fwd_LocalRcv(char *pBuffer, int length);extern void fwd_SendtoLower(char *pBuffer, int length, unsigned int nexthop);extern void fwd_DiscardPkt(char *pBuffer, int type);extern unsigned int getIpv4Address();struct RouteInfo &#123; unsigned int dest; unsigned int masklen; // 子网掩码的长度（1的个数） unsigned int nexthop; RouteInfo(int d, int m, int n) &#123; dest = d, masklen = m, nexthop = n; &#125;&#125;;vector&lt;RouteInfo&gt; routeTable; //路由表// 初始化路由表void stud_Route_Init() &#123; routeTable.clear(); return;&#125;// 增加路由void stud_route_add(stud_route_msg *proute) &#123; RouteInfo t(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop)); routeTable.push_back(t); return;&#125;int stud_fwd_deal(char *pBuffer, int length) &#123; // 头部长度 int headerLength = pBuffer[0] &amp; 0xf; // timeToLive int timeToLive = (int) pBuffer[8]; // 头部校验和 int Head_Checksum = ntohs(*(unsigned short *) (pBuffer + 10)); // 目的IP地址 int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); // 如果本机地址等于目的IP地址， 接收 if (dstAddr == getIpv4Address()) &#123; fwd_LocalRcv(pBuffer, length); return 0; &#125; // 判断timeToLive if (timeToLive &lt;= 0) &#123; // 错误 fwd_DiscardPkt(pBuffer, STUD_FORWARD_TEST_TTLERROR); return 1; &#125; // 遍历路由表 for (vector&lt;RouteInfo&gt;::iterator it = routeTable.begin(); it != routeTable.end(); it++) &#123; // 计算子网掩码 unsigned int subnetMask = 0xffffffff &lt;&lt; (32 - it-&gt;masklen); // 查找路由表 if ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123; // 构造新的ipv4头部内容 char *buffer = new char[length]; memcpy(buffer, pBuffer, length); // timeToLive-1 buffer[8]--; // 清空checksum buffer[10] = buffer[11] = 0; // 计算校验和 // sum为计算的和 unsigned short sum = 0; // temp用于辅助计算 unsigned short temp = 0; // 每16字节为一组 for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) buffer[i * 2]) &lt;&lt; 8) + ((unsigned char) buffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; // if (0xffff - sum &lt; temp) // sum = sum + temp + 1; // else // sum = sum + temp; &#125; unsigned short headCheckSum = htons(0xffff - sum); memcpy(buffer + 10, &amp;headCheckSum, 2); fwd_SendtoLower(buffer, length, it-&gt;nexthop); return 0; &#125; &#125; // 没有路由器 fwd_DiscardPkt(pBuffer, STUD_FORWARD_TEST_NOROUTE); return 1;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"《计算机网络概论》lab 2 ipv4分组收发","slug":"《计算机网络概论》lab-2-ipv4分组收发","date":"2021-04-13T16:38:41.000Z","updated":"2021-04-13T16:56:17.318Z","comments":true,"path":"2021/04/14/《计算机网络概论》lab-2-ipv4分组收发/","link":"","permalink":"http://www.kinami.cc/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-2-ipv4%E5%88%86%E7%BB%84%E6%94%B6%E5%8F%91/","excerpt":"","text":"实验流程实验要求根据计算机网络实验系统所提供的上下层接口函数和协议中分组收发的主要流程，独立设计实现一个简单的IPv4分组收发模块。要求实现的主要功能包括： IPv4分组的基本接收处理； IPv4分组的封装发送。 实验思路在本次实验中，最重要的部分是理解IPv4的头部结构，应当使用合适的方法对头部信息进行读取、校验、写入等操作。在实验指导书中给出的头部信息结构如下： 在接收时，使用合适的方法读取并验证头部信息，写入时用合适的方法写入正确的值，就是我们本次实验需要完成的内容。 实验细节IPv4分组的基本接收处理正如之前所述，本次实验的关键在于读取头部信息，首先我们对头部信息进行读取，代码如下： 读取头部信息 在本次实验中，只需读取下列我们感兴趣的信息即可。需要注意的是在读取超过1个字节的值时需要将网络序转换为本地序。 123456// 读取头部信息int version = pBuffer[0] &gt;&gt; 4;int headLength = pBuffer[0] &amp; 0xf; //0b00001111int timeToLive = (unsigned short) pBuffer[8];int headCheckSum = ntohs(*(unsigned short *) (pBuffer + 10));int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); 判断timeToLive值是否出错 12345// TTL值出错if (timeToLive &lt;= 0) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_TTL_ERROR); return 1;&#125; 判断IP版本号是否出错 12345// IP版本号错if (version != 4) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_VERSION_ERROR); return 1;&#125; 判断头部长度是否出错 12345// 头部长度错if (headLength &lt; 5) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_HEADLEN_ERROR); return 1;&#125; 校验checksum，直接把头部的长度按照规则相加，和应该为0xffff 这里要注意的细节是，由于我们用unsigned short进行计算，而checksum的规则要求如果相加大于0xffff，需要把高16位的值加到低16位上，因此，每次相加前我们需要判断相加是否大于0xffff，需要采用判断0xffff - sum和temp的关系来实现来避免溢出，如代码的11行所示。 1234567891011121314151617// 校验checksum// sum为计算的和unsigned short sum = 0;// temp用于辅助计算unsigned short temp = 0;// 每16字节为一组for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) pBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) pBuffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp;&#125;// 如果和不为0xffff，说明出错if (sum != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR); return 1;&#125; 如果经过上面的操作都没有返回，说明该分组没有问题，可以接受，如下 123//成功接受ip_SendtoUp(pBuffer, length);return 0; IPv4分组的封装发送该部分主要需要实现对头部信息的写入。流程如下： 首先，需要创建一个完整的分组结构 1234// 分配空间，头需要20字节，内容字节数为lenchar *IPBuffer = (char *) malloc((20 + len) * sizeof(char));// 将数据初始化为0memset(IPBuffer, 0, len + 20); 填充Version和IHL，内容为0b10001001=0x45，如下 1IPBuffer[0] = 0x45; 计算分组长度，转换成网络序后填写 1234 //分组总长度，需要转换成网络序unsigned short totalLength = htons(len + 20); // 填写total_length信息memcpy(IPBuffer + 2, &amp;totalLength, 2); 填写timeToLive和protocol 12IPBuffer[8] = timeToLive; //timeToLiveIPBuffer[9] = protocol; //协议 填写源地址和目标地址，注意转换成网络序 1234unsigned int src = htonl(srcAddr);unsigned int dst = htonl(dstAddr);memcpy(IPBuffer + 12, &amp;src, 4);memcpy(IPBuffer + 16, &amp;dst, 4); 计算checksum，由于我们在刚开始就使用memset将所有位初始化为了0，因此我们在这里可以用和第一个实验一模一样的代码来计算checksum，放置checksum的字节现在值为0，并不会影响计算，之后，用0xffff减去我们计算的结果就是应该填充的checksum。代码如下： 12345678unsigned short sum = 0;unsigned short temp = 0;// 计算sum// 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以for (int i = 0; i &lt; 10; i++) &#123; temp = (((unsigned char) IPBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) IPBuffer[i * 2 + 1]); 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp;&#125; 以上代码为求和，以下为填充。 1234unsigned short headCheckSum = 0;headCheckSum = htons(0xffff - sum);// 填充checksum值memcpy(IPBuffer + 10, &amp;headCheckSum, 2); 最后，将携带的信息填充并发送即可 123memcpy(IPBuffer + 20, pBuffer, len);ip_SendtoLower(IPBuffer, len + 20);return 0; 至此，实验代码结束，在测试平台上测试通过。 实验中遇到的问题 本次实验较为顺利，没遇到太多的疑难问题。 完整代码完整代码即为将实验细节部分的代码拼凑而成，但还是在这里给出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &quot;sysInclude.h&quot;#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;extern void ip_DiscardPkt(char *pBuffer, int type);extern void ip_SendtoLower(char *pBuffer, int length);extern void ip_SendtoUp(char *pBuffer, int length);extern unsigned int getIpv4Address();// 头部一共有20个字节，以字节为单位结构如下:// pBuffer[0] 高4位为Version 低4位为IHL// pBuffer[1] 高6位为TypeOfService// pBuffer[2]-pBuffer[3] Total Length// pBuffer[4]-pBuffer[5] Identification// pBuffer[6]的第6位第7位分别为MF和DF// pBuffer[6]的前5位+pBuffer[7] 为Fragment offset// pBuffer[8] : time to live// pBuffer[9]: Protocol// pBuffer[10]-pBuffer[11] Header checksum// pBuffer[12]-pBuffer[15] source address // pBuffer[16]-pBuffer[19] destination addressint stud_ip_recv(char *pBuffer, unsigned short length) &#123; // 读取头部信息 int version = pBuffer[0] &gt;&gt; 4; int headLength = pBuffer[0] &amp; 0xf; //0b00001111 int timeToLive = (unsigned short) pBuffer[8]; int headCheckSum = ntohs(*(unsigned short *) (pBuffer + 10)); int dstAddr = ntohl(*(unsigned int *) (pBuffer + 16)); // TTL值出错 if (timeToLive &lt;= 0) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_TTL_ERROR); return 1; &#125; // IP版本号错 if (version != 4) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_VERSION_ERROR); return 1; &#125; // 头部长度错 if (headLength &lt; 5) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_HEADLEN_ERROR); return 1; &#125; // 目的地址错 if (dstAddr != getIpv4Address() &amp;&amp; dstAddr != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_DESTINATION_ERROR); return 1; &#125; // 校验checksum // sum为计算的和 unsigned short sum = 0; // temp用于辅助计算 unsigned short temp = 0; // 每16字节为一组 for (int i = 0; i &lt; headLength * 2; i++) &#123; // 注意字节序，前8位为高位，后8位为低位 temp = (((unsigned char) pBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) pBuffer[i * 2 + 1]); // 如果相加之后进1，将进的1位加上 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; if (sum != 0xffff) &#123; ip_DiscardPkt(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR); return 1; &#125; //成功接受 ip_SendtoUp(pBuffer, length); return 0;&#125;int stud_ip_Upsend(char *pBuffer, unsigned short len, unsigned int srcAddr, unsigned int dstAddr, byte protocol, byte timeToLive) &#123; // 分配空间，头需要20字节，内容字节数为len char *IPBuffer = (char *) malloc((20 + len) * sizeof(char)); memset(IPBuffer, 0, len + 20); // pBuffer[0] 高4位为Version 低4位为IHL // 0b10001001 IPBuffer[0] = 0x45; //分组总长度，需要转换成网络序 unsigned short totalLength = htons(len + 20); // 填写total_length信息 memcpy(IPBuffer + 2, &amp;totalLength, 2); IPBuffer[8] = timeToLive; //timeToLive IPBuffer[9] = protocol; //协议 unsigned int src = htonl(srcAddr); unsigned int dst = htonl(dstAddr); memcpy(IPBuffer + 12, &amp;src, 4); //源与目的IP地址 memcpy(IPBuffer + 16, &amp;dst, 4); unsigned short sum = 0; unsigned short temp = 0; // 计算checksum // 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以 for (int i = 0; i &lt; 10; i++) &#123; temp = (((unsigned char) IPBuffer[i * 2]) &lt;&lt; 8) + ((unsigned char) IPBuffer[i * 2 + 1]); 0xffff - sum &lt; temp ? sum = sum + temp + 1 : sum = sum + temp; &#125; unsigned short headCheckSum = 0; headCheckSum = htons(0xffff - sum); memcpy(IPBuffer + 10, &amp;headCheckSum, 2); memcpy(IPBuffer + 20, pBuffer, len); ip_SendtoLower(IPBuffer, len + 20); return 0;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"《计算机网络概论》lab 1 滑动窗口","slug":"《计算机网络概论》lab-1-滑动窗口","date":"2021-04-13T12:51:26.000Z","updated":"2021-04-13T16:55:24.342Z","comments":true,"path":"2021/04/13/《计算机网络概论》lab-1-滑动窗口/","link":"","permalink":"http://www.kinami.cc/2021/04/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"实验流程实验要求本次实验要求在一个数据链路层的模拟实现环境下，用C语言实现三个数据链路层协议：1比特滑动窗口协议、回退N帧滑动窗口协议、选择性重传协议。 实验思路通过阅读实验指导书可以发现，回退N帧滑动窗口协议是最重要的一个，其他两个协议都可以看作在此基础上的一点小修改，所以本次实验中最重要的一点是实现回退N帧滑动窗口协议。在回退N帧实验中，系统和我需要实现的函数的函数交互方式如下： 等停协议和回退N帧协议：当发送端需要发送帧时，会调用学生测试函数，并置参数messageType为MSG_TYPE_SEND，测试函数应该将该帧缓存，存入发送队列中。若发送窗口还未打开到规定限度，则打开一个窗口，并将调用SendFRAMEPacket函数将该帧发送。若发送窗口已开到限度，则直接返回，相当于直接进入等待状态。 当发送端收到接收端的ACK 后，会调用学生测试函数，并置参数messageType为MSG_TYPE_RECEIVE，测试函数应该检查ACK值后，将该ACK 对应的窗口关闭。由于关闭了窗口，等待发送的帧可以进入窗口并发送，因此，此时若发送队列中存在等待发送的帧应该将一个等待发送的帧发送并打开一个新的窗口。 发送每发送一个帧，系统都会为他创建一个定时器，当被成功ACK 后，定时器会被取消，若某个帧在定时器超时时间仍未被ACK，系统则会调用测试函数，并置参数messageType 为MSG_TYPE_TIMEOUT，告知测试函数某帧超时，测试函数应该将根据帧序号将该帧以及后面发送过的帧重新发送。 可见，系统通过反复调用我实现的函数，通过messageType来标注是什么样的操作要求。因此我们可以考虑通过switch来区分开不同的操作，每个操作进行单独的实现。除此之外，在运行过程中，还有数据保存要求，所以我们需要全局变量或者静态变量来存储一些数据，考虑到每个函数功能的单独性，用静态变量实现会更优雅，在本次实验中选择这样实现。 实验细节正如之前所述，我将以回退N帧数函数为基础完成整个实验，在此部分进行一些代码细节的说明。首先，定义的一些常量以及结构如下： 两个窗口大小的常量 12#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4 表示帧状态的枚举型 12345typedef enum &#123; data, ack, nak&#125; frame_kind; 系统中定义的frame结构 12345678910typedef struct frame_head &#123; frame_kind kind; // 帧类型 unsigned int seq; // 序列号 unsigned int ack; // 确认号 unsigned char data[100];//数据&#125;;typedef struct frame &#123; frame_head head; //帧头 unsigned int size; //帧的大小&#125;; 自定义的用于存储帧的Buffer结构。其中pBuffer和pFrame指针指向同一片地方只是生命的类型不同，主要是便于之后调用时不再手动强制类型转换。 123456789101112131415161718typedef struct Buffer &#123; unsigned char *pBuffer; // 向`SendFRAMEPacket`函数传的第一个参数 frame *pFrame; // 存储的frame的指针 int bufferSize; // size，向`SendFRAMEPacket`函数传的第二个参数 Buffer() &#123; // 分配一块储存frame的空间 pFrame = new frame(); // 将分配的地址指针赋值给pBuffer pBuffer = (unsigned char *) pFrame; &#125; // 用于储存frame的工具成员函数 void save(char *_pBuffer, int _bufferSize) &#123; // 注意不能是复制指针，而是需要把内容复制过来 (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;; 一个用于通过指针获得ACK的宏函数 1#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack) 之后，回退N帧测试函数stud_slide_window_back_n_frame内定义的用于存储数据的静态变量如下： 12345678910int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; // switch body ....... &#125;&#125; 其中各变量的意义如下： lower: 滑动窗口的下界 upper: 滑动窗口上界的下一个 wait_queue: 由于窗口打开到上限不能直接send的帧的等待队列 WINDOW_SIZE: 在本函数中的窗口大小，每个函数中可能不一样 windows[WINDOW_SIZE]: 用于存储各窗口发出的帧的数组，大小和窗口大小一样 此外，需要注意的是，实际打开的窗口的窗口号下界为lower % WINDOW_SIZE，上界的下一个窗口号为(upper + 1) % WINDOW_SIZE。因为实际窗口号是在一定范围内轮流使用，例如0,1,2,3,0,1,2,...这样，但是如果将下界和上界直接这样表示有时会带来额外的麻烦，例如当窗口大小为1时，只存在一个窗口号0，此时上界的下一个窗口号也还是0，刚开始实现时就是因为这样，导致回退N帧测试函数不能直接修改WINDOW_SIZE来用在等停测试函数中。 之后便是swtich中各个功能的实现，实现细节如下： MSG_TYPE_SEND 123456789101112131415161718case MSG_TYPE_SEND: &#123; // 保存帧的内容 Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); // 发送等待序列中的帧 // 当队列不为空且窗口大小小于最大大小时进行发送。 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; // 从队列头取出一个并发送 Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); // 将发送的帧储存在对应窗口中 windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_RECEIVE 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取收到的ack int ack = GET_ACK(pBuffer); // 从目前的打开的窗口中寻找seq=ack的窗口 for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; // 如果找到，说明i窗口以及之前的窗口已经被成功接受，则下界应当更新为i + 1 lower = i + 1; break; &#125; &#125; // 此时如果能继续发送则继续发送，该部分发送函数的逻辑和`case MSG_TYPE_SEND`中的对应部分一模一样 while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break;&#125; MSG_TYPE_TIMEOUT: 1234567case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break;&#125; 以上便是回退N帧协议的实现细节。在实现中要注意的几个点，从pFrame中读取数据时（在本次实验中要读取的为seq、ack、kind），要注意大小端的转换，直接用ntohl()函数即可。在这种实现中，实现等停协议只需要将WINDOW_SIZE设置成WINDOW_SIZE_STOP_WAIT（即为1）即可，此外不需要任何的修改。 选择性重传函数中，取消了MSG_TYPE_TIMEOUT这种类型，只需要对case MSG_TYPE_RECEIVE做一些修改即可，修改如下： 123456789101112131415161718192021case MSG_TYPE_RECEIVE: &#123; // 读取`kind`区分是`ack`还是`nak` int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); // 如果kind是`ack`，和之前的处理一模一样，此处略 if (kind == ack) &#123; /* ... */ &#125; // 如果kind是`nak`，则将帧中的`ack`表示的帧号找出来重发 else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; // 遍历找到缓存的帧中seq等于读出的ack（在这里用变量nak表示）的帧 if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break;&#125; 至此，该实验结束。 实验中遇到的问题 不熟悉实验系统，实验系统对一些错误也不能很好的反馈。例如刚开始的时候，由于代码实现中将Buffer这个辅助结构当成一个class来使用，写了析构函数，并在析构函数中进行了delete操作，但是由于忽略了局部变量作用域的问题，导致了某些指针被重复释放，出了错误，但是在实验系统中并没有报错，只是单纯的卡住不动，最后因为过去的一点点经验想到了可能是指针相关的错误，最后才找到了这个问题。 还没找到很方便的debug方法，在做实验时还是通过最原始的输出log来寻找问题，实验系统中的单步调试功能也没太用习惯。 对大小端转换的问题还没有形成习惯，漏了好几次转换，运行出错了才发现没写。 完整代码由于三个函数的代码重复性很高，而且前面已经给出了详解，因此在完整代码部分删去了注释。代码说明见前面实验细节部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &quot;sysinclude.h&quot;#include &lt;queue&gt;extern void SendFRAMEPacket(unsigned char *pData, unsigned int len);#define WINDOW_SIZE_STOP_WAIT 1#define WINDOW_SIZE_BACK_N_FRAME 4typedef enum &#123; data, ack, nak&#125; frame_kind;typedef struct frame_head &#123; frame_kind kind; unsigned int seq; unsigned int ack; unsigned char data[100];&#125;;typedef struct frame &#123; frame_head head; unsigned int size;&#125;;typedef struct Buffer &#123; unsigned char *pBuffer; frame *pFrame; int bufferSize; Buffer() &#123; pFrame = new frame(); pBuffer = (unsigned char *) pFrame; &#125; void save(char *_pBuffer, int _bufferSize) &#123; (*pFrame) = *((frame *) _pBuffer); bufferSize = _bufferSize; &#125;&#125;;#define GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)/** 停等协议测试函数*/int stud_slide_window_stop_and_wait(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_STOP_WAIT; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower++; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 回退n帧测试函数*/int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType) &#123; // 使用static变量来持久化 static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_TIMEOUT: &#123; for (int i = lower; i &lt; upper; i++) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); &#125; break; &#125; default: break; &#125; return 0;&#125;/** 选择性重传测试函数*/int stud_slide_window_choice_frame_resend(char *pBuffer, int bufferSize, UINT8 messageType) &#123; static int lower = 0, upper = 0; static queue&lt;Buffer&gt; wait_queue; const static int WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME; static Buffer windows[WINDOW_SIZE]; switch (messageType) &#123; case MSG_TYPE_SEND: &#123; Buffer buffer; buffer.save(pBuffer, bufferSize); wait_queue.push(buffer); while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; break; &#125; case MSG_TYPE_RECEIVE: &#123; int kind = ntohl(((frame *) pBuffer)-&gt;head.kind); if (kind == ack) &#123; int ack = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123; lower = i + 1; break; &#125; &#125; while (!wait_queue.empty() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123; Buffer buffer = wait_queue.front(); wait_queue.pop(); SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); windows[upper % WINDOW_SIZE] = buffer; upper++; &#125; &#125; else if (kind == nak) &#123; int nak = GET_ACK(pBuffer); for (int i = lower; i &lt; upper; i++) &#123; if (ntohl(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123; Buffer buffer = windows[i % WINDOW_SIZE]; SendFRAMEPacket(buffer.pBuffer, buffer.bufferSize); break; &#125; &#125; &#125; break; &#125; default: break; &#125; return 0;&#125;","categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]}],"categories":[{"name":"课程作业","slug":"课程作业","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"计算机网络","slug":"课程作业/计算机网络","permalink":"http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"作业","slug":"作业","permalink":"http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"}]}