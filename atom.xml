<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kinami&#39;s blog</title>
  
  <subtitle>一点微小的贡献</subtitle>
  <link href="http://www.kinami.cc/atom.xml" rel="self"/>
  
  <link href="http://www.kinami.cc/"/>
  <updated>2021-04-13T13:06:50.140Z</updated>
  <id>http://www.kinami.cc/</id>
  
  <author>
    <name>kinami</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络概论lab 1 滑动窗口</title>
    <link href="http://www.kinami.cc/2021/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BAlab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://www.kinami.cc/2021/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BAlab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2021-04-13T12:51:26.000Z</published>
    <updated>2021-04-13T13:06:50.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>本次实验要求在一个数据链路层的模拟实现环境下，用C语言实现三个数据链路层协议：1比特滑动窗口协议、回退N帧滑动窗口协议、选择性重传协议。</p><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>通过阅读实验指导书可以发现，回退N帧滑动窗口协议是最重要的一个，其他两个协议都可以看作在此基础上的一点小修改，所以本次实验中最重要的一点是实现回退N帧滑动窗口协议。<br>在回退N帧实验中，系统和我需要实现的函数的函数交互方式如下：</p><blockquote><p><strong>等停协议和回退N帧协议：</strong><br>当发送端需要发送帧时，会调用学生测试函数，并置参数<code>messageType</code>为<code>MSG_TYPE_SEND</code>，测试函数应该将该帧缓存，存入发送队列中。若发送窗口还未打开到规定限度，则打开一个窗口，并将调用<code>SendFRAMEPacket</code>函数将该帧发送。若发送窗口已开到限度，则直接返回，相当于直接进入等待状态。</p><p>当发送端收到接收端的<code>ACK</code> 后，会调用学生测试函数，并置参数<code>messageType</code>为<code>MSG_TYPE_RECEIVE</code>，测试函数应该检查<code>ACK</code>值后，将该<code>ACK</code> 对应的窗口关闭。由于关闭了窗口，等待发送的帧可以进入窗口并发送，因此，此时若发送队列中存在等待发送的帧应该将一个等待发送的帧发送并打开一个新的窗口。</p><p>发送每发送一个帧，系统都会为他创建一个定时器，当被成功<code>ACK</code> 后，定时器会被取消，若某个帧在定时器超时时间仍未被<code>ACK</code>，系统则会调用测试函数，并置参数<code>messageType</code> 为<code>MSG_TYPE_TIMEOUT</code>，告知测试函数某帧超时，测试函数应该将根据帧序号将该帧以及后面发送过的帧重新发送。</p></blockquote><p>可见，系统通过反复调用我实现的函数，通过<code>messageType</code>来标注是什么样的操作要求。因此我们可以考虑通过<code>switch</code>来区分开不同的操作，每个操作进行单独的实现。除此之外，在运行过程中，还有数据保存要求，所以我们需要全局变量或者静态变量来存储一些数据，考虑到每个函数功能的单独性，用静态变量实现会更优雅，在本次实验中选择这样实现。</p><h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><p>正如之前所述，我将以回退N帧数函数为基础完成整个实验，在此部分进行一些代码细节的说明。<br>首先，定义的一些常量以及结构如下：</p><ul><li><p>两个窗口大小的常量</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_STOP_WAIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_BACK_N_FRAME 4</span></span><br></pre></td></tr></table></figure></li><li><p>表示帧状态的枚举型</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    data,</span><br><span class="line">    ack,</span><br><span class="line">    nak</span><br><span class="line">&#125; frame_kind;</span><br></pre></td></tr></table></figure></li><li><p>系统中定义的<code>frame</code>结构</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame_head</span> &#123;</span></span><br><span class="line">    frame_kind kind;<span class="comment">// 帧类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq;<span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ack;<span class="comment">// 确认号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">100</span>];<span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame</span> &#123;</span></span><br><span class="line">    frame_head head;<span class="comment">//帧头</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;  <span class="comment">//帧的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>自定义的用于存储帧的<code>Buffer</code>结构。其中<code>pBuffer</code>和<code>pFrame</code>指针指向同一片地方只是生命的类型不同，主要是便于之后调用时不再手动强制类型转换。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer;<span class="comment">// 向`SendFRAMEPacket`函数传的第一个参数</span></span><br><span class="line">    frame *pFrame; <span class="comment">// 存储的frame的指针</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize;<span class="comment">// size，向`SendFRAMEPacket`函数传的第二个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Buffer</span>() &#123;</span><br><span class="line">        <span class="comment">// 分配一块储存frame的空间</span></span><br><span class="line">        pFrame = <span class="keyword">new</span> <span class="built_in">frame</span>();</span><br><span class="line">        <span class="comment">// 将分配的地址指针赋值给pBuffer</span></span><br><span class="line">        pBuffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) pFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于储存frame的工具成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">char</span> *_pBuffer, <span class="keyword">int</span> _bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意不能是复制指针，而是需要把内容复制过来</span></span><br><span class="line">        (*pFrame) = *((frame *) _pBuffer);</span><br><span class="line">        bufferSize = _bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>一个用于通过指针获得<code>ACK</code>的宏函数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)</span></span><br></pre></td></tr></table></figure></li></ul><p>之后，回退N帧测试函数<code>stud_slide_window_back_n_frame</code>内定义的用于存储数据的静态变量如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_back_n_frame</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="comment">// switch body .......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中各变量的意义如下：</p><ul><li><code>lower</code>: 滑动窗口的下界</li><li><code>upper</code>: 滑动窗口上界的下一个</li><li><code>wait_queue</code>: 由于窗口打开到上限不能直接<code>send</code>的帧的等待队列</li><li><code>WINDOW_SIZE</code>: 在本函数中的窗口大小，每个函数中可能不一样</li><li><code>windows[WINDOW_SIZE]</code>: 用于存储各窗口发出的帧的数组，大小和窗口大小一样</li></ul><p>此外，需要注意的是，实际打开的窗口的<strong>窗口号</strong>下界为<code>lower % WINDOW_SIZE</code>，上界的下一个<strong>窗口号</strong>为<code>(upper + 1) % WINDOW_SIZE</code>。因为实际窗口号是在一定范围内轮流使用，例如<code>0,1,2,3,0,1,2,...</code>这样，但是如果将下界和上界直接这样表示有时会带来额外的麻烦，例如当窗口大小为1时，只存在一个窗口号<code>0</code>，此时<strong>上界的下一个窗口号</strong>也还是<code>0</code>，刚开始实现时就是因为这样，导致回退N帧测试函数不能直接修改<code>WINDOW_SIZE</code>来用在等停测试函数中。</p><p>之后便是<code>swtich</code>中各个功能的实现，实现细节如下：</p><ul><li><code>MSG_TYPE_SEND</code>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line"><span class="comment">// 保存帧的内容</span></span><br><span class="line">Buffer buffer;</span><br><span class="line">buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line"><span class="comment">// 发送等待序列中的帧</span></span><br><span class="line">    <span class="comment">// 当队列不为空且窗口大小小于最大大小时进行发送。</span></span><br><span class="line"><span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">        <span class="comment">// 从队列头取出一个并发送</span></span><br><span class="line">Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">wait_queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">        <span class="comment">// 将发送的帧储存在对应窗口中</span></span><br><span class="line">windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">upper++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>MSG_TYPE_RECEIVE</code>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">    <span class="comment">// 读取收到的ack</span></span><br><span class="line"><span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">    <span class="comment">// 从目前的打开的窗口中寻找seq=ack的窗口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">            <span class="comment">// 如果找到，说明i窗口以及之前的窗口已经被成功接受，则下界应当更新为i + 1</span></span><br><span class="line">lower = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时如果能继续发送则继续发送，该部分发送函数的逻辑和`case MSG_TYPE_SEND`中的对应部分一模一样</span></span><br><span class="line"><span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">wait_queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">upper++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>MSG_TYPE_TIMEOUT</code>:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line"><span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上便是回退N帧协议的实现细节。在实现中要注意的几个点，从<code>pFrame</code>中读取数据时（在本次实验中要读取的为<code>seq</code>、<code>ack</code>、<code>kind</code>），要注意大小端的转换，直接用<code>ntohl()</code>函数即可。在这种实现中，实现等停协议只需要将<code>WINDOW_SIZE</code>设置成<code>WINDOW_SIZE_STOP_WAIT</code>（即为1）即可，此外<strong>不需要任何的修改</strong>。</li></ul><p>选择性重传函数中，取消了<code>MSG_TYPE_TIMEOUT</code>这种类型，只需要对<code>case MSG_TYPE_RECEIVE</code>做一些修改即可，修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">    <span class="comment">// 读取`kind`区分是`ack`还是`nak`</span></span><br><span class="line"><span class="keyword">int</span> kind = <span class="built_in">ntohl</span>(((frame *) pBuffer)-&gt;head.kind);</span><br><span class="line">    <span class="comment">// 如果kind是`ack`，和之前的处理一模一样，此处略</span></span><br><span class="line"><span class="keyword">if</span> (kind == ack) &#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 如果kind是`nak`，则将帧中的`ack`表示的帧号找出来重发</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (kind == nak) &#123;</span><br><span class="line"><span class="keyword">int</span> nak = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历找到缓存的帧中seq等于读出的ack（在这里用变量nak表示）的帧</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123;</span><br><span class="line">Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line"><span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，该实验结束。</p><h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol><li>不熟悉实验系统，实验系统对一些错误也不能很好的反馈。例如刚开始的时候，由于代码实现中将<code>Buffer</code>这个辅助结构当成一个<code>class</code>来使用，写了析构函数，并在析构函数中进行了<code>delete</code>操作，但是由于忽略了局部变量作用域的问题，导致了某些指针被重复释放，出了错误，但是在实验系统中并没有报错，只是单纯的卡住不动，最后因为过去的一点点经验想到了可能是指针相关的错误，最后才找到了这个问题。</li><li>还没找到很方便的debug方法，在做实验时还是通过最原始的输出log来寻找问题，实验系统中的单步调试功能也没太用习惯。</li><li>对大小端转换的问题还没有形成习惯，漏了好几次转换，运行出错了才发现没写。</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>由于三个函数的代码重复性很高，而且前面已经给出了详解，因此在完整代码部分删去了注释。代码说明见前面<strong>实验细节</strong>部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysinclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SendFRAMEPacket</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_STOP_WAIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_BACK_N_FRAME 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    data,</span><br><span class="line">    ack,</span><br><span class="line">    nak</span><br><span class="line">&#125; frame_kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame_head</span> &#123;</span></span><br><span class="line">    frame_kind kind;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ack;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame</span> &#123;</span></span><br><span class="line">    frame_head head;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer;</span><br><span class="line">    frame *pFrame;</span><br><span class="line">    <span class="keyword">int</span> bufferSize;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Buffer</span>() &#123;</span><br><span class="line">        pFrame = <span class="keyword">new</span> <span class="built_in">frame</span>();</span><br><span class="line">        pBuffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) pFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">char</span> *_pBuffer, <span class="keyword">int</span> _bufferSize)</span> </span>&#123;</span><br><span class="line">        (*pFrame) = *((frame *) _pBuffer);</span><br><span class="line">        bufferSize = _bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 停等协议测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_stop_and_wait</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用static变量来持久化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_STOP_WAIT;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                    lower++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 回退n帧测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_back_n_frame</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用static变量来持久化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                    lower = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 选择性重传测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_choice_frame_resend</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> kind = <span class="built_in">ntohl</span>(((frame *) pBuffer)-&gt;head.kind);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kind == ack) &#123;</span><br><span class="line">                <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                        lower = i + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                    Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                    wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                    windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                    upper++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (kind == nak) &#123;</span><br><span class="line">                <span class="keyword">int</span> nak = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123;</span><br><span class="line">                        Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                        <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">北京大学计算机网络概论普通班lab实验报告</summary>
    
    
    
    <category term="课程作业" scheme="http://www.kinami.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="计算机网络" scheme="http://www.kinami.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="作业" scheme="http://www.kinami.cc/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
</feed>
