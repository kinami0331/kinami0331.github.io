<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《操作系统》xv6阅读报告之进程模型</title>
    <url>/2021/04/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本次XV6源码阅读主要关注XV6中的进程模型的实现，包括XV6中的PCB（进程控制块）结构、进程常用方法的实现、系统对进程的调度等。与该功能实现有关的<strong>主要</strong>代码文件以及该文件的主要内容如下表格所示。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>proc.h</code></td>
<td>主要声明了三个<code>struct</code>:<code>cpu</code>,<code>context</code>,<code>proc</code>，分别是内核中的CPU、上下文以及我们重点关注的PCB信息，除此之外还定义了一个枚举型，定义了xv6中进程的可能状态</td>
</tr>
<tr>
<td><code>proc.c</code></td>
<td>声明了进程表的数据结构<code>ptable</code>以及与进程有关的核心函数，在本次报告中会对这些函数详细解读</td>
</tr>
<tr>
<td><code>vm.c</code></td>
<td>实现了一些与虚拟内存有关的函数，其中与进程有关的部分包括为内核和用户分配内存，切换到当前进程页面的<code>switchuvm()</code>，切换到内核页面的<code>switchkvm()</code>，以及用于拷贝父进程空间到子进程空间的<code>copyuvm()</code>等</td>
</tr>
<tr>
<td><code>swtch.S</code></td>
<td>用汇编实现的一个用于切换上下文的函数</td>
</tr>
<tr>
<td><code>kalloc.c</code></td>
<td>主要实现了用于分配和释放物理内存的<code>kalloc()</code>以及<code>kfree()</code></td>
</tr>
</tbody></table>
<p>除此之外，还有定义了一些数据结构的其他头文件，这里不特别列出，在用到的时候会说明。在本次报告中，我们主要关注进程相关的内容，即<code>proc.h</code>和<code>proc.c</code>这两个文件中的内容。</p>
<h2 id="核心代码解读"><a href="#核心代码解读" class="headerlink" title="核心代码解读"></a>核心代码解读</h2><h3 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a><code>proc.h</code></h3><p>在<code>proc.h</code>中，定义了以下数据：</p>
<ol>
<li><p><code>struct cpu</code>：这是CPU在呢何种的表示，在这个结构体中，会有一个指向<code>struct proc</code>的指针，用于表示当前正在执行的进程。此外还声明了一个<code>cpus</code>数组，用于支持多核处理器。</p>
</li>
<li><p><code>struct context</code>，表示上下文信息的一个结构体，如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>struct proc</code>，这是XV6中的进程控制块（PCB），如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;</span><br><span class="line">  <span class="keyword">char</span> *kstack;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *chan;</span><br><span class="line">  <span class="keyword">int</span> killed;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中各个数据项的详细意义如下：</p>
<table>
<thead>
<tr>
<th>数据</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>uint sz</code></td>
<td>进程内存空间的大小，单位为byte</td>
</tr>
<tr>
<td><code>pde_t* pgdir</code></td>
<td>指向进程的page table</td>
</tr>
<tr>
<td><code>char *kstack</code></td>
<td>指向内核栈的底部</td>
</tr>
<tr>
<td><code>enum procstate state</code></td>
<td>表示内核当前的状态，其中<code>enum procstate</code>是一个枚举结构，该枚举结构的定义为<code> enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</code>除了未使用（UNUSED）状态之外，进程共有五种状态。</td>
</tr>
<tr>
<td><code>volatile int pid</code></td>
<td>进程的id</td>
</tr>
<tr>
<td><code>struct proc *parent</code></td>
<td>指向父进程结构</td>
</tr>
<tr>
<td><code>struct trapframe *tf</code></td>
<td>指向一个中断帧（<code>trapframe</code>），这个结构体定义在<code>x86.h</code>这个文件中。当进程中断时，这个变量指向进程对应的中断帧。</td>
</tr>
<tr>
<td><code>struct context *context</code></td>
<td>切换进程时需要保存的上下文信息，其中<code>context</code>结构体已经在之前介绍过。</td>
</tr>
<tr>
<td><code>void *chan</code></td>
<td>这是一个与睡眠&amp;唤醒有关的数据，如果<code>chan</code>不为空，说明当前进程在<code>chan</code>上休眠，其中<code>chan</code>指的是一个等待队列（wait channel），在xv6中通过调用<code>sleep(chan)</code>来让进程在一个<code>chan</code>上休眠，用<code>wakeup(chan)</code>唤醒一个<code>chan</code>上的进程。</td>
</tr>
<tr>
<td><code>int killed</code></td>
<td>当<code>killed</code>不为0时，说明这个进程被杀死</td>
</tr>
<tr>
<td><code>struct file *ofile[NOFILE]</code></td>
<td>打开的文件，其中<code>struct file</code>是一个与文件有关的结构，这里暂且不详细说明。</td>
</tr>
<tr>
<td><code>struct inode *cwd</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td><code>char name[16]</code></td>
<td>进程的名称，debug用</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a><code>proc.c</code></h3><ol>
<li>在<code>proc.c</code>中，首先定义了一个重要的数据结构<code>ptable</code>，在xv6中，所有的进程信息都储存在这个结构中，这个结构体如下所示： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line">&#125; ptable;</span><br></pre></td></tr></table></figure>
 其中<code>spinloc lock</code>是一个互斥锁。<code>NPROC</code>为xv6中进程数量的上限，定义在<code>param.h</code>中，在xv6，进程的上限数为64。</li>
<li><code>allocproc()</code>函数，该函数的主要功能为在<code>ptable</code>中寻找一个空位，如果找到空位，则创建一个新的进程，并返回指向该进程的一个指针。<br> 该函数的声明为<code>static struct proc* allocproc(void)</code>。<br> 首先，函数遍历<code>ptable</code>中的<code>proc</code>数组，如果找到了一个空位置，则继续之后的工作，如果遍历全部之后还没有找到则直接返回0（NULL指针），代码如下所示。其中涉及到了<code>acquire()</code>和<code>release()</code>这两个与锁有关的函数，不是我们这一节的重点，暂时忽略。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* part 1 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">char</span> *sp;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED)</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">  <span class="built_in">release</span>(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 在运行<code>goto found</code>之后，<code>p</code>即为一个状态为<code>UNUSED</code>的<code>proc</code>位置，将这个进程设置为<code>EMBRYO</code>状态，并且分配一个<code>pid</code>。其中<code>pid</code>由全局变量<code>nextpid</code>来分配，每分配一个新的<code>pid</code>，<code>nextpid</code>进行一次自增操作。该部分代码如下。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* part 2 */</span></span><br><span class="line">found:</span><br><span class="line">  p-&gt;state = EMBRYO;</span><br><span class="line">  p-&gt;pid = nextpid++;</span><br><span class="line">  <span class="built_in">release</span>(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 之后，需要为内核栈分配空间，需要调用定义在<code>kalloc.c</code>中的<code>kalloc()</code>函数，如果分配失败，该进程并不能顺利创建，则将进程的状态重新设置为<code>UNUSED</code>并返回空指针。代码如下。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* part 3 */</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;kstack = <span class="built_in">kalloc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    p-&gt;state = UNUSED;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 之后，要对内核栈的其他部分进行建立，最终结构如下图所示（代码略）<br> <img src="/2021/04/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/f1-3.png" alt="figure1-3"><br> 在<code>allocproc()</code>中的最后一步为<code>p-&gt;context-&gt;eip = (uint)forkret</code>，使得新进程首先运行在<code>forkret</code>这个函数中，该函数中判断了是否为第一个创建的线程，之后就没有做别的事情，直接返回，返回后会进入<code>trapret</code>函数，<code>trapret</code>为从中断中返回的函数，该函数定义在<code>trapasm.S</code>中，用于恢复用户寄存器，恢复后使用<code>iret</code>从中断中返回。</li>
<li><code>userinit()</code>函数，用于创建第一个进程。在xv6中，<code>main()</code>函数初始化了一些设备和子系统后，会调用该函数创建第一个进程。在该函数中，首先调用<code>allocproc()</code>在分配一个进程并进行初始化，之后调用<code>setupkvm()</code>创建一个映射内核区的页表，这个函数设计虚拟内存相关知识，这里不详细说明。最终得到如下结构：<br> <img src="/2021/04/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/f1-1.png" alt="figure1-1"><br> 之后，<code>userinit()</code>函数将<code>trapframe</code>设为初始的用户模式状态，该部分代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; <span class="number">3</span>) | DPL_USER;</span><br><span class="line">  p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; <span class="number">3</span>) | DPL_USER;</span><br><span class="line">  p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;</span><br><span class="line">  p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;</span><br><span class="line">  p-&gt;tf-&gt;eflags = FL_IF;</span><br><span class="line">  p-&gt;tf-&gt;esp = PGSIZE;</span><br><span class="line">  p-&gt;tf-&gt;eip = <span class="number">0</span>; <span class="comment">// beginning of initcode.S</span></span><br></pre></td></tr></table></figure>
这里我们主要关注最后一行代码，将<code>trapframe</code>的<code>eip</code>设为了0，这是初始化代码<code>initcode.S</code>的入口<br> 最后，设置进程状态为<code>RUNNABLE</code>，正式开始工作。</li>
<li><code>fork()</code>函数。除了第一个进程之外，其他的进程都是由父进程调用<code>fork()</code>创建的，实现过程如下。<br> 首先，分配一个进程。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line"><span class="keyword">if</span> ((np = <span class="built_in">allocproc</span>()) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
 之后复制父进程的地址空间，如果失败（返回值不为0）则回收进程空间并返回一个错误。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((np-&gt;pgdir = <span class="built_in">copyuvm</span>(proc-&gt;pgdir, proc-&gt;sz)) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">kfree</span>(np-&gt;kstack);</span><br><span class="line">    np-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    np-&gt;state = UNUSED;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 如果成功，则复制以下信息</span></span><br><span class="line">np-&gt;sz = proc-&gt;sz;</span><br><span class="line">np-&gt;parent = proc;</span><br><span class="line">*np-&gt;tf = *proc-&gt;tf;</span><br></pre></td></tr></table></figure>
 之后，设置<code>np-&gt;tf-&gt;eax = 0</code>，当子进程从中断返回时，会返回0。<br> 然后子进程继承父进程打开的文件、当前工作目录以及父进程的名字。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;ofile[i])</span><br><span class="line">    np-&gt;ofile[i] = <span class="built_in">filedup</span>(proc-&gt;ofile[i]);</span><br><span class="line">np-&gt;cwd = <span class="built_in">idup</span>(proc-&gt;cwd);</span><br><span class="line">	</span><br><span class="line">pid = np-&gt;pid;</span><br><span class="line">np-&gt;state = RUNNABLE;</span><br><span class="line"><span class="built_in">safestrcpy</span>(np-&gt;name, proc-&gt;name, <span class="built_in"><span class="keyword">sizeof</span></span>(proc-&gt;name));</span><br></pre></td></tr></table></figure>
 最后，在父进程中返回<code>pid</code>，其中<code>pid</code>由<code>pid = np-&gt;pid</code>得到，是子进程的<code>pid</code>。</li>
<li><code>exit()</code>函数，退出当前进程，退出的进程会变为<code>ZOMBIE</code>状态直到它的父进程调用<code>wait()</code>来发现它已经退出。实现过程如下。<br> 首先关闭所有的文件，之后调用<code>wakeup1()</code>来唤醒父进程（这里会先加锁所以父进程并不会马上唤醒）。如果当前进程有子进程，则需要设置子进程的父进程变为<code>initproc</code>。最后，将当前进程的状态设置为<code>ZOMBIE</code>。</li>
<li><code>wait()</code>函数，等待一个子进程退出，返回子进程的<code>pid</code>，如果没有子进程则返回-1。实现流程如下。（代码略）<br> 遍历<code>ptable</code>中的<code>proc</code>数组，查找是否有子进程，如果有子进程则会将一个<code>havekids</code>标记为1，如果循环了一遍后<code>havekids</code>还是0，则直接返回-1。如果有子进程但是子进程未退出，则会调用<code>sleep()</code>来等待子进程唤醒。在发现处于<code>ZOMBIE</code>状态的子进程之后会释放子进程空间的使用，将这个进程块的状态设置为<code>UNUSED</code>，最后返回子进程的<code>pid</code>。</li>
<li><code>scheduler()</code>函数，该函数会被每个CPU都调用，该函数会遍历进程表，找到一个状态为<code>RUNNABLE</code>的进程来执行，如果没找到则会把当前CPU的<code>proc</code>（表示当前CPU正在执行的进程）设为空指针。其核心代码如下 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;state != RUNNABLE)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  proc = p;</span><br><span class="line">  <span class="built_in">switchuvm</span>(p);</span><br><span class="line">  p-&gt;state = RUNNING;</span><br><span class="line">  <span class="built_in">swtch</span>(&amp;cpu-&gt;scheduler, proc-&gt;context);</span><br><span class="line">  <span class="built_in">switchkvm</span>();</span><br><span class="line">  proc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 当找到一个处于<code>RUNNABLE</code>状态的进程后，会调用三个重要的函数<code>switchuvm()</code>,<code>swtch()</code>以及<code>switchkvm()</code>。其中<code>switchuvm()</code>会根据<code>proc</code>结构中的<code>pgdir</code>来找到当前进程需要使用的页表，并进行切换。<code>swtch</code>是一个使用汇编编写的函数，在<code>swtch.S</code>中编写，用于保存当前进程的上下文，然后返回到要切换的进程的上下文（<code>cpu-&gt;scheduler</code>）中。<code>switchkvm()</code>用于切换到内核页表。 在xv6中的实现里，这个调度函数采用了最简单的实现方法：直接遍历进程数组寻找，在真实的操作系统中往往会采用更复杂的调度算法来获得更好的体验。</li>
</ol>
<h2 id="总结及收获"><a href="#总结及收获" class="headerlink" title="总结及收获"></a>总结及收获</h2><p>略</p>
]]></content>
      <categories>
        <category>课程作业</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>《操作系统》xv6阅读报告之进程调度</title>
    <url>/2021/04/14/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本次XV6源码阅读，主要是在上次阅读<strong>进程模型</strong>的基础上，进一步研究xv6中在进程<strong>调度</strong>方面的细节。主要需要阅读的代码文件和上次类似，有以下这些：<br>| 文件名     | 主要功能                                                     |<br>| ———- | ———————————————————— |<br>| <code>proc.h</code>   | 主要声明了三个<code>struct</code>:<code>cpu</code>,<code>context</code>,<code>proc</code>，分别是内核中的CPU、上下文以及我们重点关注的PCB信息，除此之外还定义了一个枚举型，定义了xv6中进程的可能状态 |<br>| <code>proc.c</code>   | 声明了进程表的数据结构<code>ptable</code>以及与进程有关的核心函数，在本次报告中会对这些函数详细解读 |<br>| <code>vm.c</code>     | 实现了一些与虚拟内存有关的函数，其中与进程有关的部分包括为内核和用户分配内存，切换到当前进程页面的<code>switchuvm()</code>，切换到内核页面的<code>switchkvm()</code>，以及用于拷贝父进程空间到子进程空间的<code>copyuvm()</code>等 |<br>| <code>swtch.S</code>  | 用汇编实现的一个用于切换上下文的函数                         |<br>| <code>kalloc.c</code> | 主要实现了用于分配和释放物理内存的<code>kalloc()</code>以及<code>kfree()</code>    |<br>除此之外，还有定义了一些数据结构的其他头文件，这里不特别列出，在用到的时候会说明。在本次报告中，我们主要关注进程相关的内容，即<code>proc.h</code>和<code>proc.c</code>这两个文件中的内容。</p>
<h2 id="核心代码解读"><a href="#核心代码解读" class="headerlink" title="核心代码解读"></a>核心代码解读</h2><h3 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a><code>proc.h</code></h3><p>该部分说明直接复用上次阅读报告，因为定义的结构体之后要用到。<br>在<code>proc.h</code>中，定义了以下数据：</p>
<ol>
<li><p><code>struct cpu</code>：这是CPU在呢何种的表示，在这个结构体中，会有一个指向<code>struct proc</code>的指针，用于表示当前正在执行的进程。此外还声明了一个<code>cpus</code>数组，用于支持多核处理器。</p>
</li>
<li><p><code>struct context</code>，表示上下文信息的一个结构体，如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>struct proc</code>，这是XV6中的进程控制块（PCB），如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;</span><br><span class="line">  <span class="keyword">char</span> *kstack;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *chan;</span><br><span class="line">  <span class="keyword">int</span> killed;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中各个数据项的详细意义如下：</p>
<table>
<thead>
<tr>
<th>数据</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>uint sz</code></td>
<td>进程内存空间的大小，单位为byte</td>
</tr>
<tr>
<td><code>pde_t* pgdir</code></td>
<td>指向进程的page table</td>
</tr>
<tr>
<td><code>char *kstack</code></td>
<td>指向内核栈的底部</td>
</tr>
<tr>
<td><code>enum procstate state</code></td>
<td>表示内核当前的状态，其中<code>enum procstate</code>是一个枚举结构，该枚举结构的定义为<code> enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</code>除了未使用（UNUSED）状态之外，进程共有五种状态。</td>
</tr>
<tr>
<td><code>volatile int pid</code></td>
<td>进程的id</td>
</tr>
<tr>
<td><code>struct proc *parent</code></td>
<td>指向父进程结构</td>
</tr>
<tr>
<td><code>struct trapframe *tf</code></td>
<td>指向一个中断帧（<code>trapframe</code>），这个结构体定义在<code>x86.h</code>这个文件中。当进程中断时，这个变量指向进程对应的中断帧。</td>
</tr>
<tr>
<td><code>struct context *context</code></td>
<td>切换进程时需要保存的上下文信息，其中<code>context</code>结构体已经在之前介绍过。</td>
</tr>
<tr>
<td><code>void *chan</code></td>
<td>这是一个与睡眠&amp;唤醒有关的数据，如果<code>chan</code>不为空，说明当前进程在<code>chan</code>上休眠，其中<code>chan</code>指的是一个等待队列（wait channel），在xv6中通过调用<code>sleep(chan)</code>来让进程在一个<code>chan</code>上休眠，用<code>wakeup(chan)</code>唤醒一个<code>chan</code>上的进程。</td>
</tr>
<tr>
<td><code>int killed</code></td>
<td>当<code>killed</code>不为0时，说明这个进程被杀死</td>
</tr>
<tr>
<td><code>struct file *ofile[NOFILE]</code></td>
<td>打开的文件，其中<code>struct file</code>是一个与文件有关的结构，这里暂且不详细说明。</td>
</tr>
<tr>
<td><code>struct inode *cwd</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td><code>char name[16]</code></td>
<td>进程的名称，debug用</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a><code>proc.c</code></h3><ul>
<li><code>scheduler()</code>函数<br>  在<code>proc.c</code>中，实现了一个跟进程调度有关的函数<code>scheduler()</code>，该函数不接受参数也没有返回值，作用为遍历进程表，找到一个状态为<code>RUNNABLE</code>的进程来执行。代码如下：      <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (p-&gt;state != RUNNABLE)</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	  proc = p;</span><br><span class="line">	  switchuvm(p);</span><br><span class="line">	  p-&gt;state = RUNNING;</span><br><span class="line">	  swtch(&amp;cpu-&gt;scheduler, proc-&gt;context);</span><br><span class="line">	  switchkvm();</span><br><span class="line">	  proc = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
  其中<code>ptable.proc</code>是一个储存着所有<code>proc</code>结构体的数组，该函数从数组的第一个元素开始进行遍历（在实际的工作中其实是从前一次切换的位置开始遍历，这个我们之后说明），当找到一个状态为<code>RUNNABLE</code>的进程之后，会调用三个重要的函数<code>switchuvm()</code>,<code>swtch()</code>以及<code>switchkvm()</code>。其中<code>switchuvm()</code>会根据<code>proc</code>结构中的<code>pgdir</code>来找到当前进程需要使用的页表，并进行切换。<code>swtch</code>是一个使用汇编编写的函数，在<code>swtch.S</code>中编写，用于保存当前进程的上下文，然后返回到要切换的进程的上下文（<code>cpu-&gt;scheduler</code>）中。<code>switchkvm()</code>用于切换到内核页表。由代码可见，在xv6的实现里，这个调度函数采用了最简单的实现方法：通过遍历储存着所有进程<code>proc</code>结构的数组来寻找下一个可以开始工作的进程。<br>  在上次报告中，对该部分的解读到此为止，这次我们继续探寻一些细节。</li>
<li><code>yield()</code>函数<br>  <code>yield()</code>函数代码如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;ptable.lock); <span class="comment">//DOC: yieldlock</span></span><br><span class="line">  proc-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  可见其中的逻辑很简单，主要就是将当前进程的状态设置为<code>RUNNABLE</code>，然后再调用<code>sched()</code>函数</li>
<li><code>sched()</code>函数  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> intena;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!holding(&amp;ptable.lock))</span><br><span class="line">    panic(<span class="string">&quot;sched ptable.lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cpu-&gt;ncli != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (readeflags() &amp; FL_IF)</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">  intena = cpu-&gt;intena;</span><br><span class="line">  swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</span><br><span class="line">  cpu-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在该函数中，最重要的一句为<code>swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</code>即进行上下文切换的语句，关于这里的工作逻辑，在我们分析完下面的代码后进行说明。</li>
</ul>
<h3 id="swtch-S"><a href="#swtch-S" class="headerlink" title="swtch.S"></a><code>swtch.S</code></h3><p>在这个汇编文件中，实现了一个由汇编写的函数<code>swtch</code>，它是在进程调度时用于保存上下文的核心内容，代码如下</p>
<ul>
<li><code>swtch()</code>函数  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  movl 4(%esp), %eax</span><br><span class="line">  movl 8(%esp), %edx</span><br><span class="line"></span><br><span class="line">  # Save old callee-save registers</span><br><span class="line">  pushl %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  pushl %esi</span><br><span class="line">  pushl %edi</span><br><span class="line"></span><br><span class="line">  # Switch stacks</span><br><span class="line">  movl %esp, (%eax)</span><br><span class="line">  movl %edx, %esp</span><br><span class="line"></span><br><span class="line">  # Load new callee-save registers</span><br><span class="line">  popl %edi</span><br><span class="line">  popl %esi</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
  代码的注释中指出，<code>swtch</code>函数接受两个参数:<code>void swtch(struct context **old, struct context *new);</code>，注意两个参数的类型不一样，前一个参数是一个指向<code>context</code>结构指针的指针。<br>  首先3,4两行代码取出了传给<code>swtch</code>的两个参数，其中<code>%eax</code>为<code>old</code>，<code>%edx</code>为<code>new</code>。<br>  7,8,9,10四行则按顺序保存四个寄存器，在保存之前，<code>%esp</code>中存储的内容为返回地址，之后按顺序压入<code>ebp</code>,<code>ebx</code>,<code>esi</code>,<code>edi</code>。操作完成后栈中结构如下：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地址高位</span><br><span class="line">	返回地址</span><br><span class="line">	ebp</span><br><span class="line">	ebx</span><br><span class="line">	esi</span><br><span class="line">	edi # 现在的栈顶</span><br><span class="line">地址地位</span><br></pre></td></tr></table></figure>
  可以发现这个结构对应的正是一个<code>context</code>结构，所以此时的<code>%esp</code>可以看作是一个指向一个<code>context</code>结构的指针。之后第13行，将这个指针保存在第一个参数指向的地方（第一个参数是一个指向<code>context</code>指针的指针），这里的实现相对我们做过的Nachos来说不太一样，所以后面会给出整理后的具体调度流程。  之后，第14行将用第二个参数替换栈顶，然后在17-20行恢复寄存器数据，此时的返回地址是要切换到的线程的返回地址，返回后另一个线程直接开始工作。</li>
</ul>
<h3 id="调度逻辑总结"><a href="#调度逻辑总结" class="headerlink" title="调度逻辑总结"></a>调度逻辑总结</h3><p>由于xv6是一个支持多核心的操作系统，在xv6中，每个核心都会有自己的一套上下文以及调度器。在上一部分的代码实现中可以看到，<code>swtch</code>函数的一个参数为<code>cpu-&gt;scheduler</code>。这是<code>struct cpu</code>中的一个成员变量，类型为<code>context *</code>，事实上，它指向的是调度器的上下文。</p>
<p>在xv6工作时，每个CPU会启动一个调度器，在<code>main()</code>函数中调用，调度器的完整代码如下所示：</p>
<ul>
<li><code>scheduler()</code>完整代码  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里是我们之前解读过的核心代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可见，这个调度器是不会返回的，一直在循环。代码在调度器中运行时，其实是<code>main()</code>函数的上下文，可以认为是主进程的上下文中（之后称为调度器上下文），然后从这里切换到其他的进程。所以在<code>scheduler()</code>中调用<code>swtch</code>函数时第一个参数为<code>&amp;cpu-&gt;scheduler</code>，将当前调度器进程的上下文保存在<code>cpu-&gt;scheduler</code>中，然后切换到目标进程的上下文中。</p>
<p>在当前工作的进程<code>yield()</code>时调用了<code>sched()</code>函数，而在这个函数中，我们可以看到调用<code>swtch</code>的函数为<code>swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</code>实际上当一个进程<code>yield()</code>之后，是先回到调度器进程中，之后再由调度器进程负责找到下一个进程再切换一次，实际上是两次切换，切换到目标进程的工作是由调度器进程完成的。</p>
<h2 id="总结及收获"><a href="#总结及收获" class="headerlink" title="总结及收获"></a>总结及收获</h2><p>懂得都懂</p>
]]></content>
      <categories>
        <category>课程作业</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 2 ipv4分组收发</title>
    <url>/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-2-ipv4%E5%88%86%E7%BB%84%E6%94%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>根据计算机网络实验系统所提供的上下层接口函数和协议中分组收发的主要流程，独立设计实现一个简单的IPv4分组收发模块。要求实现的主要功能包括：</p>
<ol>
<li>IPv4分组的基本接收处理；</li>
<li>IPv4分组的封装发送。</li>
</ol>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>在本次实验中，最重要的部分是理解IPv4的头部结构，应当使用合适的方法对头部信息进行读取、校验、写入等操作。在实验指导书中给出的头部信息结构如下：</p>
<p><img src="/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-2-ipv4%E5%88%86%E7%BB%84%E6%94%B6%E5%8F%91/lab2-1.png" alt="lab2-1"></p>
<p>在接收时，使用合适的方法读取并验证头部信息，写入时用合适的方法写入正确的值，就是我们本次实验需要完成的内容。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><h4 id="IPv4分组的基本接收处理"><a href="#IPv4分组的基本接收处理" class="headerlink" title="IPv4分组的基本接收处理"></a>IPv4分组的基本接收处理</h4><p>正如之前所述，本次实验的关键在于读取头部信息，首先我们对头部信息进行读取，代码如下：</p>
<ul>
<li><p>读取头部信息</p>
<p>在本次实验中，只需读取下列我们感兴趣的信息即可。需要注意的是在读取超过1个字节的值时需要将网络序转换为本地序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取头部信息</span></span><br><span class="line"><span class="keyword">int</span> version = pBuffer[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> headLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>; <span class="comment">//0b00001111</span></span><br><span class="line"><span class="keyword">int</span> timeToLive = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> headCheckSum = ntohs(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line"><span class="keyword">int</span> dstAddr = ntohl(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>判断<code>timeToLive</code>值是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TTL值出错</span></span><br><span class="line"><span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_TTL_ERROR);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断IP版本号是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IP版本号错</span></span><br><span class="line"><span class="keyword">if</span> (version != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_VERSION_ERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断头部长度是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部长度错</span></span><br><span class="line"><span class="keyword">if</span> (headLength &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_HEADLEN_ERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验<code>checksum</code>，直接把头部的长度按照规则相加，和应该为<code>0xffff</code></p>
<p>  这里要注意的细节是，由于我们用<code>unsigned short</code>进行计算，而<code>checksum</code>的规则要求如果相加大于<code>0xffff</code>，需要把高16位的值加到低16位上，因此，每次相加前我们需要判断相加是否大于<code>0xffff</code>，需要采用判断<code>0xffff - sum</code>和<code>temp</code>的关系来实现来避免溢出，如代码的11行所示。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验checksum</span></span><br><span class="line"><span class="comment">// sum为计算的和</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// temp用于辅助计算</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每16字节为一组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">    temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">    <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果和不为0xffff，说明出错</span></span><br><span class="line"><span class="keyword">if</span> (sum != <span class="number">0xffff</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果经过上面的操作都没有返回，说明该分组没有问题，可以接受，如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成功接受</span></span><br><span class="line">ip_SendtoUp(pBuffer, length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="IPv4分组的封装发送"><a href="#IPv4分组的封装发送" class="headerlink" title="IPv4分组的封装发送"></a>IPv4分组的封装发送</h4><p>该部分主要需要实现对头部信息的写入。流程如下：</p>
<ul>
<li><p>首先，需要创建一个完整的分组结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配空间，头需要20字节，内容字节数为len</span></span><br><span class="line"><span class="keyword">char</span> *IPBuffer = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>((<span class="number">20</span> + len) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="comment">// 将数据初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(IPBuffer, <span class="number">0</span>, len + <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>填充<code>Version</code>和<code>IHL</code>，内容为<code>0b10001001=0x45</code>，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IPBuffer[<span class="number">0</span>] = <span class="number">0x45</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>计算分组长度，转换成网络序后填写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//分组总长度，需要转换成网络序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> totalLength = htons(len + <span class="number">20</span>); </span><br><span class="line"><span class="comment">// 填写total_length信息</span></span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">2</span>, &amp;totalLength, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>填写<code>timeToLive</code>和<code>protocol</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IPBuffer[<span class="number">8</span>] = timeToLive;        <span class="comment">//timeToLive</span></span><br><span class="line">IPBuffer[<span class="number">9</span>] = protocol;   <span class="comment">//协议</span></span><br></pre></td></tr></table></figure></li>
<li><p>填写源地址和目标地址，注意转换成网络序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> src = htonl(srcAddr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dst = htonl(dstAddr);</span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">12</span>, &amp;src, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">16</span>, &amp;dst, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>计算<code>checksum</code>，由于我们在刚开始就使用<code>memset</code>将所有位初始化为了<code>0</code>，因此我们在这里可以用和第一个实验一模一样的代码来计算<code>checksum</code>，放置<code>checksum</code>的字节现在值为0，并不会影响计算，之后，用<code>0xffff</code>减去我们计算的结果就是应该填充的<code>checksum</code>。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算sum</span></span><br><span class="line"><span class="comment">// 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码为求和，以下为填充。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="number">0</span>;</span><br><span class="line">headCheckSum = htons(<span class="number">0xffff</span> - sum);</span><br><span class="line"><span class="comment">// 填充checksum值</span></span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>最后，将携带的信息填充并发送即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">20</span>, pBuffer, len);</span><br><span class="line">ip_SendtoLower(IPBuffer, len + <span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，实验代码结束，在测试平台上测试通过。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>本次实验较为顺利，没遇到太多的疑难问题。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码即为将实验细节部分的代码拼凑而成，但还是在这里给出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysInclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ip_DiscardPkt</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ip_SendtoLower</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ip_SendtoUp</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部一共有20个字节，以字节为单位结构如下:</span></span><br><span class="line"><span class="comment">// pBuffer[0] 高4位为Version 低4位为IHL</span></span><br><span class="line"><span class="comment">// pBuffer[1] 高6位为TypeOfService</span></span><br><span class="line"><span class="comment">// pBuffer[2]-pBuffer[3] Total Length</span></span><br><span class="line"><span class="comment">// pBuffer[4]-pBuffer[5] Identification</span></span><br><span class="line"><span class="comment">// pBuffer[6]的第6位第7位分别为MF和DF</span></span><br><span class="line"><span class="comment">// pBuffer[6]的前5位+pBuffer[7] 为Fragment offset</span></span><br><span class="line"><span class="comment">// pBuffer[8] : time to live</span></span><br><span class="line"><span class="comment">// pBuffer[9]: Protocol</span></span><br><span class="line"><span class="comment">// pBuffer[10]-pBuffer[11] Header checksum</span></span><br><span class="line"><span class="comment">// pBuffer[12]-pBuffer[15] source address </span></span><br><span class="line"><span class="comment">// pBuffer[16]-pBuffer[19] destination address</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_ip_recv</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取头部信息</span></span><br><span class="line">    <span class="keyword">int</span> version = pBuffer[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> headLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>; <span class="comment">//0b00001111</span></span><br><span class="line">    <span class="keyword">int</span> timeToLive = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> headCheckSum = <span class="built_in">ntohs</span>(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">int</span> dstAddr = <span class="built_in">ntohl</span>(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TTL值出错</span></span><br><span class="line">    <span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_TTL_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IP版本号错</span></span><br><span class="line">    <span class="keyword">if</span> (version != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_VERSION_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头部长度错</span></span><br><span class="line">    <span class="keyword">if</span> (headLength &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_HEADLEN_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目的地址错</span></span><br><span class="line">    <span class="keyword">if</span> (dstAddr != <span class="built_in">getIpv4Address</span>() &amp;&amp; dstAddr != <span class="number">0xffff</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_DESTINATION_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验checksum</span></span><br><span class="line">    <span class="comment">// sum为计算的和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// temp用于辅助计算</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每16字节为一组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">        temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">        <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">0xffff</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功接受</span></span><br><span class="line">    <span class="built_in">ip_SendtoUp</span>(pBuffer, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_ip_Upsend</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr, byte protocol, byte timeToLive)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配空间，头需要20字节，内容字节数为len</span></span><br><span class="line">    <span class="keyword">char</span> *IPBuffer = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>((<span class="number">20</span> + len) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memset</span>(IPBuffer, <span class="number">0</span>, len + <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// pBuffer[0] 高4位为Version 低4位为IHL</span></span><br><span class="line">    <span class="comment">// 0b10001001</span></span><br><span class="line">    IPBuffer[<span class="number">0</span>] = <span class="number">0x45</span>;</span><br><span class="line">    <span class="comment">//分组总长度，需要转换成网络序</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> totalLength = <span class="built_in">htons</span>(len + <span class="number">20</span>); </span><br><span class="line">    <span class="comment">// 填写total_length信息</span></span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">2</span>, &amp;totalLength, <span class="number">2</span>);</span><br><span class="line">    IPBuffer[<span class="number">8</span>] = timeToLive;        <span class="comment">//timeToLive</span></span><br><span class="line">    IPBuffer[<span class="number">9</span>] = protocol;   <span class="comment">//协议</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> src = <span class="built_in">htonl</span>(srcAddr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dst = <span class="built_in">htonl</span>(dstAddr);</span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">12</span>, &amp;src, <span class="number">4</span>);   <span class="comment">//源与目的IP地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">16</span>, &amp;dst, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算checksum</span></span><br><span class="line">    <span class="comment">// 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="number">0</span>;</span><br><span class="line">    headCheckSum = <span class="built_in">htons</span>(<span class="number">0xffff</span> - sum);</span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">20</span>, pBuffer, len);</span><br><span class="line">    <span class="built_in">ip_SendtoLower</span>(IPBuffer, len + <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 3 ipv4路由</title>
    <url>/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-3-ipv4%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>在前面IPv4分组收发实验的基础上，增加分组转发功能。具体来说，对于每一个到达本机的IPv4分组，根据其目的IPv4地址决定分组的处理行为，对该分组进行如下的几类操作：</p>
<ol>
<li>向上层协议上交目的地址为本机地址的分组；</li>
<li>根据路由查找结果，丢弃查不到路由的分组；</li>
<li> 根据路由查找结果，向相应接口转发不是本机接收的分组。</li>
</ol>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>在本次实验中，我们首先需要定义一个路由表结构，并且实现一个增加路由的函数。在实验指导书中给出了一种路由结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stud_route_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dest;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> masklen;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop;</span><br><span class="line">&#125; stud_route_msg;</span><br></pre></td></tr></table></figure>

<p>其中，<code>masklen</code>应当指子网掩码中从左往右数的1的个数而不是子网掩码的内容，这一点需要注意。因此，我们的路由表也仿照这样的结构设计即可。需要注意的是，由上层传来的路由表的数据是网络序，为了方便我们转换成本地序处理。</p>
<p>在接受分组时，首先应该查看目的地址是否为本机，然后查看该分组是否已经失效（例如<code>TTL</code>值小于等于0），然后在路由表中查找，查找不到则丢弃。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><h4 id="路由表的设计"><a href="#路由表的设计" class="headerlink" title="路由表的设计"></a>路由表的设计</h4><p>路由表设计如下，和实验系统中的设计一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RouteInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dest;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> masklen;   <span class="comment">// 子网掩码的长度（1的个数）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop;</span><br><span class="line">    RouteInfo(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dest = d, masklen = m, nexthop = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;RouteInfo&gt; routeTable;   <span class="comment">//路由表</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化路由表函数"><a href="#初始化路由表函数" class="headerlink" title="初始化路由表函数"></a>初始化路由表函数</h4><p>初始化时清空路由表即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化路由表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_Route_Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    routeTable.clear();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加一条新的路由信息"><a href="#增加一条新的路由信息" class="headerlink" title="增加一条新的路由信息"></a>增加一条新的路由信息</h4><p>注意需要将网络序转换为本地序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加路由</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_route_add</span><span class="params">(stud_route_msg *proute)</span> </span>&#123;</span><br><span class="line">    <span class="function">RouteInfo <span class="title">t</span><span class="params">(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop))</span></span>;</span><br><span class="line">    routeTable.push_back(t);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系统处理收到的IP分组的函数"><a href="#系统处理收到的IP分组的函数" class="headerlink" title="系统处理收到的IP分组的函数"></a>系统处理收到的IP分组的函数</h4><ul>
<li><p>首先，读取我们感兴趣的头部信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部长度</span></span><br><span class="line">  <span class="keyword">int</span> headerLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>;</span><br><span class="line">  <span class="comment">// timeToLive</span></span><br><span class="line">  <span class="keyword">int</span> timeToLive = (<span class="keyword">int</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line">  <span class="comment">// 头部校验和</span></span><br><span class="line">  <span class="keyword">int</span> IHL = ntohs(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line">  <span class="comment">// 目的IP地址</span></span><br><span class="line">  <span class="keyword">int</span> dstAddr = ntohl(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>判断<code>timeToLive</code>值是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断timeToLive</span></span><br><span class="line"><span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">     <span class="built_in">fwd_DiscardPkt</span>(pBuffer,STUD_FORWARD_TEST_TTLERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历路由表进行查找</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历路由表</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;RouteInfo&gt;::iterator it = routeTable.<span class="built_in">begin</span>(); it != routeTable.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">// 计算子网掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subnetMask = <span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - it-&gt;masklen);</span><br><span class="line">    <span class="comment">// 查找路由表</span></span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了应该更新新的head信息</span></span><br><span class="line">        <span class="comment">// 构造新的ipv4头部内容</span></span><br><span class="line">        <span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, pBuffer, length);</span><br><span class="line">        <span class="comment">// timeToLive-1</span></span><br><span class="line">        buffer[<span class="number">8</span>]--;</span><br><span class="line">        <span class="comment">// 清空checksum，便于之后求和计算</span></span><br><span class="line">        buffer[<span class="number">10</span>] = buffer[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算校验和</span></span><br><span class="line">        <span class="comment">// sum为计算的和</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// temp用于辅助计算</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每16字节为一组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">            temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">            <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算并填充checkNum</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="built_in">htons</span>(<span class="number">0xffff</span> - sum);</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 发送信息  </span></span><br><span class="line">        <span class="built_in">fwd_SendtoLower</span>(buffer, length, it-&gt;nexthop);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果遍历之后还没返回，说明没找到路由信息，丢弃。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有路由器</span></span><br><span class="line"><span class="built_in">fwd_DiscardPkt</span>(pBuffer, STUD_FORWARD_TEST_NOROUTE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，实验代码结束，在测试平台上测试通过。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>本次实验较为顺利，没遇到太多的疑难问题。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码在这里给出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysInclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="comment">// system support</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fwd_LocalRcv</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fwd_SendtoLower</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length, <span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fwd_DiscardPkt</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RouteInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dest;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> masklen;   <span class="comment">// 子网掩码的长度（1的个数）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop;</span><br><span class="line">    <span class="built_in">RouteInfo</span>(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dest = d, masklen = m, nexthop = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;RouteInfo&gt; routeTable;   <span class="comment">//路由表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化路由表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_Route_Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    routeTable.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加路由</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_route_add</span><span class="params">(stud_route_msg *proute)</span> </span>&#123;</span><br><span class="line">    <span class="function">RouteInfo <span class="title">t</span><span class="params">(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop))</span></span>;</span><br><span class="line">    routeTable.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_fwd_deal</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头部长度</span></span><br><span class="line">    <span class="keyword">int</span> headerLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="comment">// timeToLive</span></span><br><span class="line">    <span class="keyword">int</span> timeToLive = (<span class="keyword">int</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 头部校验和</span></span><br><span class="line">    <span class="keyword">int</span> Head_Checksum = <span class="built_in">ntohs</span>(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 目的IP地址</span></span><br><span class="line">    <span class="keyword">int</span> dstAddr = <span class="built_in">ntohl</span>(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果本机地址等于目的IP地址， 接收</span></span><br><span class="line">    <span class="keyword">if</span> (dstAddr == <span class="built_in">getIpv4Address</span>()) &#123;</span><br><span class="line">        <span class="built_in">fwd_LocalRcv</span>(pBuffer, length);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断timeToLive</span></span><br><span class="line">    <span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误</span></span><br><span class="line">        <span class="built_in">fwd_DiscardPkt</span>(pBuffer, STUD_FORWARD_TEST_TTLERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历路由表</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;RouteInfo&gt;::iterator it = routeTable.<span class="built_in">begin</span>(); it != routeTable.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="comment">// 计算子网掩码</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> subnetMask = <span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - it-&gt;masklen);</span><br><span class="line">        <span class="comment">// 查找路由表</span></span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123;</span><br><span class="line">            <span class="comment">// 构造新的ipv4头部内容</span></span><br><span class="line">            <span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">            <span class="built_in">memcpy</span>(buffer, pBuffer, length);</span><br><span class="line">            <span class="comment">// timeToLive-1</span></span><br><span class="line">            buffer[<span class="number">8</span>]--;</span><br><span class="line">            <span class="comment">// 清空checksum</span></span><br><span class="line">            buffer[<span class="number">10</span>] = buffer[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算校验和</span></span><br><span class="line">            <span class="comment">// sum为计算的和</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// temp用于辅助计算</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每16字节为一组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">                temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">                <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">                <span class="comment">// if (0xffff - sum &lt; temp)</span></span><br><span class="line">                <span class="comment">//     sum = sum + temp + 1;</span></span><br><span class="line">                <span class="comment">// else</span></span><br><span class="line">                <span class="comment">//     sum = sum + temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="built_in">htons</span>(<span class="number">0xffff</span> - sum);</span><br><span class="line">            <span class="built_in">memcpy</span>(buffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">fwd_SendtoLower</span>(buffer, length, it-&gt;nexthop);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有路由器</span></span><br><span class="line">    <span class="built_in">fwd_DiscardPkt</span>(pBuffer, STUD_FORWARD_TEST_NOROUTE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ上的注意事项汇总 (21 fall)</title>
    <url>/2021/11/11/OJ%E4%B8%8A%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a6b1eab995475ebdfa15fa51b23158a154b77938acde9c4d082583db5b9b704a">b1c8743748ae1f554aaae721c1205cc441f57087a8f982dede0aaaefeeadf341b7deec18777f3bb689e10fbb54111938a7d32a5ff85e36eea0e2ce5a775425afd9e0ba3be51a27ddb954a3072159c9d218994316e6e2c81ac986919257a8275f18c4248cc598e16064f9c0b56b324e7d3563e74015c7334fe351ba42945ed1bd9cf1397503d034a0b231ddf22da3377506ecc88e853b0310bd5fc83f0c0abda459f1ef95f54f7c7f3c505a022d5b3135e0fbca85e93ce1cffee444168a6765a444723a31ba103ea2e25666f8dd6f1e0eec7ed424ec6363d38d1bf1355d2506d85db248fee3c82b2183a823180409ef356bdea0f8935e3df5a156720fe69db65c161ff66a84a63ef4373b96396c8150d03b3f6e11bb0bf67eda358657020ab69541353be7a35c450559f5e45ec0c557f11fea913c1930546011d6d9335f19827bd1d542779da8d31900083d72f293ca95203e1273573dcb120e3ecb8dad3ef64fbc85d028c055c7d74045e0a19d34a80efcec0b456015cf6c06b9c1df126f833b3bae3bc1ca78968663b7850d6d3a1a423497398cc3ca5d97072f86f627b112810f4aba8a284881e30f769ff397580919f2872c6565f2d4a69170869b0af5246b9a6101b3d40337efb18501256ebe4d61e113f221ac0a7ff56807cd3e7145fb020fd6e22215cc3f04c2c5dcb7b3a2398431358e707af7502a6960dc4c917ad9e911e01926b8d58a5f80693f2fd4ebbeca0e32a0506a74eb89ba8df4c6a6c49085d13a8b784d18e0f5d54c44eff1bf3e6a62b1a2687daaee63cc7017676b902372cb1c8d602491a966ff794f2631c6a2c960b538c850c9f818a2f2cd3786b861d92be6ddbf91c5f8b07db994d83f4e4245261a1bfc6ed27e23a3e0987d56c116d48fa63c8419ad99559971f446182295d9c005ec0fca9f0be1c6798521af3b6c93a2831f6abce781f709d28345a4c574f711976a2c20c9cb1084cf118331452ce167832c5dfce38191e506087fe1e076c011b0a923a0136e0d6eed7ef61ffc2341f9b9d99d0b772746b27b2dcc1fbd6c9b06718e7f038023337ffb279c15c28ab7b90c7453e5102fb655bfd0dfaf393e2f037d4c3e3a5804ed848576a49519a1d71f1463b274da5a3746c85a5cb893179653e803578258806133643e2d9cb90043c4d1df33846f14d65401f5ae0d0e7c9a5001530fb8a80b2cf5832ea3de05faf08890db9325bff83e1861b79cd307167a182ce0401ec5e96fcb778b1febf529d8f009dd7e0967a0c14c729521e36a713abeb69f9c362b9b80620a4217be3ab357351f9e24dbbc680622d477808bd6535ec303b5bee1a0ab1a4141dc92794e0119fcbf94f8ebd37ae016880020ebd2cb238c559ea9a09f1d6a203a29e49724cedef43da759bc1b7cf09df1dca2c4888b8e0ed1fa95d6561f7635598ae9dad3521ae75f225395e2733058ba39c982015dd0df716c01db91c32e464d69eb1b7bce529e94ce6feba14bf2df13aa76062496feabcb7db57d18bde56f73a6a0effc14625bd2caa02383bbe87ad3d0eeaec54795dff8522d8667925b2e0718554a4dbcdfafdf10e8ed4699e80bac4bade47f5c2ca628699c05e69b497c85e408c6d3c1b3978b84e8fe1f51d0da8d3761367bc69014450bed13cb3978e0c35fba98299fa42ed7377c689f8a6dc39f5c9a385b083e2acf0ac70b2a73ecba94255e6ce08303fb74507f3d8c056543339495bf6ed555c7e7e9e366e0826d70996a8919bd9253440004af9bb294cd2c83c248f237b44628108f9547741e949336352e279b38e04c73c33a780b60142d472b73a2703f6d232fd8eb01cf19136cd0f003bd581de4059e0842e49a83accb795ab3eb824e4f6654504ac9597d1524127b8998a2bddd32f84fba656c204a923378f0dec8aaae50baeb91b178b53be9f4eedc52dde98289fc754d9cbe077888875e370f07c4cd651891450df291f41226a60daba3217463a01698854e7ed2ddb06e17417feb20f2f245757ee1d618dcf8f5d7e04dbc2a161464c5ab248462d4e775b202fe07e9bf1f67c0e0387f301088fe1626a1ca47dad65e02bd656fe78ca69f4a78d31079e3400ba8abbc3f11b3063cf244b2216fbf1012d1e644ff3de12ac6bac79b928876b396f6bfe5b93407ea0a7de0f1e615729834a6baf330a98d8b5cddee0af7ff5706202d68feeadbb4ae6d065bb66e5aef692db314536f732106f906d7a52ca9ca2abc812d45f31e1cc7a53e29d9fd5fc5d8932273266d91f6d07563bd87e829963766aaca0d76ad007f3acbd8dc3f6204dd9ebbdca712e164cd29db8c8c32aaf38a6fe68c9b9f0c44e015c1e4016ebcc5b50fe886f4da4bb0dbf4b79327fac3829e80d36e86104aa9df80d3f00ce32ef473f4f3b9da3825dda80f12fde212c85c6ec596f68c9d46ae7cd164902fbec4c8cabb88703bd9b2bb4762b21491feaa6a4fa5c704782d4b2a1d52adfd81d72ab55e9359c7203e9a4ec2c22c12cbe5f1ae4971f244ac2686a451b5156ecc801b2cae82591505ebd4a6c411a5b09d7222efb37ba8d0fa420c87177e041c45012da50f5dbd9855d9017099c3b6eff8cee08ec91248229f03020ec2aff2c45aef4642fff49de89172d09e03865acee2c15dc92e5ab4c7c8ca0f0b820f675f636ae2ad28bd23954f7e3f399a740b121f8d24bf120b195bbd54247e22618635ad81652bc8e560565a807f525b34f886b73988e51f4b2990aa68792df3f6ed1e7a772a4370e09aa09d2a9ac8ca81fe2aa0584a9087343e9a58b3ba8f65961b420360a2623a42bdf817e3b727516f24cbcc0bbcbcb7ab25dd10d84c03dd210c84da0d0d649402155816717fc3ac710b8f3ac474a3ee13c9e35daa7dccc6b932538d3bddc8b1b7e8aa1236d1dd07a2931474ac4a41c85852bb1c348918e0c8bc2892f2bb4fa0cfa0e29212daf368d34e73cf62dee0b8c51f6c10752b929c8a9b3f462abb5f44766f5a059d2f28a029fcc5c493fcab0bdafb6fe3ca6704c9f493c18b3bc4df763a2cd14b918e8ccfbb0df8b96046d90ae84779b98178ef57f0b5432cb7e3b5eff486c8361c307565b9b9e4a73f7829297b5f9032551b0cda81599c54869decd08e72f8c8d80805c94221ad69b3367b3d668f191690b5b93be26ef632649eb007eec0409cf205dd99c5414372d287b8db4b3de578dc1080e80504fdf9b2e23e87b154c0d6b87520f7f58bded4ebf9d64ff2ce49b8771bde0b7e379815dda286920c2494709396d5890e2d44d58861442650bef80a6c7637ad69d4e5629d56161be60f0217d1a5e5967b4b9d60545a834740276c92e5e48e09faec05386d948b393b460eb3d58f6c787514ceba39a4d6636c085836e2f9830f1a07ce146cc2c517e463559d66d6d6e7f83eaa509ed102a97109f86af8a196deb6c706cf79868f0311de74a8a7643c889d08f65010987210f7c3c5afddb93c123ddc001cca2dac870c4e9e6f163fe8d7f3e5ee06ccca64ef7addd72386209ecaa79b1c135d34d29346852b9c917e6291019a56a50b0b965399f0bcf12b685d324c1ff13b8f018358201c14974a16ae9d3ec815039697dd3f65cebc37c0e7bf22ea2e6ea5f278948a545f40da8520cfd201148f2f5a31dc519a690b2775b4b0648cd6c369c120cfa6beec2ba6decc70811dd83a0719350ec9fec67db730a53e15bb59696c98fd9f6f14cb655fdccbff15fa518dce9908ea89b3deda382ed2a4730801e56ea5916d2c72cbbc6cc68e48f1a73b67494dce8c490639e28bcddca33e6f051468e734898968ce31985c0acffd61a53cefa048e3360c7563b973aed4f4213e923a5582955cda4da7d8ae2645f80a6bdd158e64a55b4a12c6d306b0cdad3566660c5fc781a7330f43d55f40d47487a78d5d7116d8062027a5efe54664461d1b590495f047f0ad3c2929e32dbd9af80b46e71e882ada32410217ff6b163afb03334c60063daba40444307d1b05ac792460cfb8062a984c62fb3bdeb2ae80051ee3d4cdfaec8084036e84d4fa1dcefc99d3d903dac5e007fab756915c79b71d80c7ecf483e8b1de113d9c52d468ba11e32d2cbb663c2b6bd21661b065f97282cdae94d8f8f2d84b90e9c8629c36f8e4460d33fc524203d2d465a067c22c34b96f544412f27fecd475cd07793d4c5a6ed1bba223234efec8c96b1387e69e5da8111d23352e007b2a3ea44d3f7c70d54a368351c65098bb5a094dd791edf53972db3b94c2544d69d86a167066caf2eeb5063cf56b386b82f5223d4c79a4d5e27cc169b2bfdf73b894e3bab9c1889bedce3c00f780435547aff6e813aa6dd0e2b3fd800c562ef7b2c305a78f8fc3218e3d4e51e00b761e88fd4dd2e5300cbe4c409061f6c9d52506740eb100d0f05a32863a599af1c1b1b3a0aa631a1f0e29d17c72b2c429bc637b8f657a0407b3dfd3bdc7493a4a9f150e6d37c9b10e1234275fb1e1860d70c5df4edc381af10cad9ae0ef8e8e3d916e3b8886b3deb759e2d752d67433168ad44ef3814825ed3112ff08003ee2c5a26356730d49be710708990a91c57627c62ce48cbae68de9c7e6a8c445e990412bbb7193376f8f314d5fb530028392be902885b2c8f2f8ee612a2b9d0474990f777c4cd444e0ec7d1ff919bc46c6908b8b08e4f64198cd9a8311a0c3df55f6ed28a9f658ac5eb6291358f0c28278de5d810da8d08267c4b3f32d7b6faec0137b858280057b8b45cbbf8a55b580855d468a42d3f725827771c49bfb546a1d806959eb6f277cb317797bed0139db6283b40908933c933286b5cda3c04a5578c29f01c64463b0672656f8dbebdf5fdc911125524400b721d03b6b6d7989d08e468dc53db618908eb28376fadeeee43126d6b75174c88e600b4d9fd5d809892edf99606bdc19870b104c54f519ff5b89e9d1677734b4bacee4b246647138d9e28b99e63abeb6ad605312144ee5fac91ac46193b7e455c0be3866a68b861713e9495dd4a9db46ae8eeff6185fa676b8daa91d95f774525057c0db1ef6a886d2522532a4b10e5f7ba4185f19eb720cbceafdb8cf0b3d4d9c64b567458f45c3f6773ddff2b9131f6b58892e20bde50ddb6ca7e8f8b05b629a78f834812c96a49dd620aa940828f85609c75ca28fef718a8614e6c97b15a910d1c08d084e9878b6d9ba94ac22a3eb3853d393f8d52dc043de2e7cf37627c4de368cace07446ade2cf54e78748572cbe76bb94fda0d05f49c494669c499593d96505434bf6ce1c2ea0bae6aece0715702d64f316b296b51ed27a95b13106e85e4dde994b73a4913bda6ad4347acbed4b5f8b7001580c29cbe81187f184facb61b7ea4ecece65ff001f279f5d852d5e2a172e1dc85a108501f5036cd2aaf422cf0b8f2a3c018cb61a91c8e34dec387db0a4beed91e25cf3e1a888363f804cf6576c16dd2dc6135c988674701e3f774dd9f23d6e235cc573161c343db79652415174a249fb67a621c8626eb30cc9311ff98d3c75874a4953a133f0dfe4165b06b53af28deab504adb74089710f56656a37f9fe59a7b866a951a4776b8eabf15b5e8de86db950aaa8bcc553f186dbd0ef033e3c54b9f494905af7d064530b79e15aa99d80d69a38192296a83e998899c5792cd0f403ef4a99e8960f87bdb1f0e684cd6332afc0a3eacc998b8b1a54ec0c27e8dc79cce2618073aad025c64752647f599a3ef6f9d99beacd085a19564722eb91c2ed29a9704ebd0b561142</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave"></span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算概论C</category>
        <category>计算概论C(21 fall)</category>
      </categories>
      <tags>
        <tag>计算概论C(21 fall)</tag>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算概论C》上机作业要求 (21 fall)</title>
    <url>/2021/11/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%A6%82%E8%AE%BAC%E3%80%8B%E4%B8%8A%E6%9C%BA%E4%BD%9C%E4%B8%9A%E8%A6%81%E6%B1%82-2021-11-11/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6f5a59f2c9f2307e404a42eb70700727138d5f1bacaaed42d807d74e51cc6c25">b1c8743748ae1f554aaae721c1205cc441f57087a8f982dede0aaaefeeadf341a182aeacf2928d7272a20afd7f0b09cf73cd6ee1ee950a2f651a4751fbfdc6eaf916b4255be299d50eb2ba0ab8710aeddc6566e998c2aafede15e08057faf8b5366dbe103e3cb7edb58c3ec099f2391c16d0b7c863dc672f3108da96343563da8ee4984c9ff2b1d1e9fcdf5c1beaddb7a3976accaf1c0f091af5aa306ac612d9dc8aa11d6a62b7ad79e6a84d634f34e7e22c7a66df9112596f503dbc07786ab2b2bf4077662c28dfb8dfbbaad2a2c76ed729ac95281344b6f469ed3769e4bdce893c30d43c6739eb9083a44b5e021e396ce23ef543c9c41835135570b1d2fe6be8d03782313e254ad580c872a8d47ca7af65029dd7af3edd7900f2119f1a7a8b7793e7e0a2e0ccce62fbd67dc7b6f3c80579a0a27ab78adee7c349844ad9bc4c71902231485f67a2241e4f207cb2c5fea97d05010173c763b0831f41138e9406b448b92b7b44a7a36d43e2393673f78d9632f6d43d6ef2d877c617aec8b79d726a0ce6267b9357d3254397472c0d9a4b9c3c0e20f435b8f1ae5683046d54fb53f9bbfc7d4133e3126f1b6662aa1e062f77678a6c1b84a2c7d1cf448bbde5e8c9af2acb131da5c6292f2db135ff028ca03738a58e5875884d04f2e53bb9dcb3569dccef19d370da52a5fc18a11378632b0000ee82e8debd17cc2e53dd76d77bd631b02ccb6edb9b833ecfa226aab681c7a56466a104120ecd5b36ef9420a737ca295230b301c1f8ae1b5b8f226aea07cd00d7585643fe1bff00df55e6d76d111ce3bf5a6db0af8f642ad10900243c2d71c224a9a2fa591e84a6ac7f060c9a1fe99ccf902c9936e1501f2eb2fbb7446b08abf1fe637ec5738edc3d7d93ed3fcc2f094fc37705ea3df91c91f370547c65ff1693c89416a5b087ef6eca606da5a69748f8794cad690349cc482bc258c10c36239be8a7b9ac590925b94dc6982c27aeaae818b5031e6ed065d91747d2aa3020868568c15948e905c74ed0bc4625bbf92cbc8aceddd3c7922c09a012ad95d00ef062caa0d93314cf4421531d821865fade4eb3da4f0dc0ab3e256b986404820e0df6f4980662ba295dc7beec2f066094ca5faa287586640312e438393f9f4d39b406eaa20b6810965b902e4cced5edc5fdd69e1a121b9df587cc94e55ea6bbb59a4c853a073f06ac0ab32ecd9dac9e709acfae784ce0e0d00064f4fe9893542e584804e8e4d871a83b91df4a786ad97e54d7f6237843b9c497e9089cc72b7dd516bfa7988f10974283a0fc24e1614c1ffb1add2649eb2c4b5e82b505f12412520170e08d3222dc8706d4a92308ac1f896da0901451227003fd04163f392ee13af96e56bbba8d20891912ed512cf226414664ec46eb06ac1a79248abd5c6c5526c40e19d457067de5f790139efa401e4228e827725b508f2cb38775cc232144a237b76188ac1509861e7304e93d2785899665a91b9f8e7a2cd7f4386dc1d8524a1f4a64a47806cfc326d1f498b140d5f049fafa3ce62e71d045b58aa1dea24be984cdee08494f660984475eadea5d23874eb3c8552bd72422379042789202d41d1d69d89ab0dc9cddc230941720109cfb687426e389aa4cb43464d9fcd955663027ac80f76a31415173f97e6474951679468a409c1dd89be69abe74db06b4c37883e4c141d6d5d99c1d5a8b3c4b114038f4477fb2673082a4b6f48e30dad900e450c3ecf562f5ad41fde6366a8f4d1d727b7c4f13ad45cccfa37719349c0ad1eb69c0e6a2c5a6ba20f3344bb61768aa5735612780f7dfda3af9ee829e7aa5a6936339e0e07879fef1cce55748e8fca4ce66271292ff19e2091d6a23ebae15aab79e277ebe65676f99309cf1f62d8d818ffc5a1b8991162cb49a96d4b0de3763ff21707c849975cebc7f4fbb45ca579cf3b29a3dafaf22369f3674265365721b60892fa296ee166e3e6e25b854d9c11238acb5e609d7f0788ce322cee74f37011fa03083fb909d914d317816a06a9f6d93ba86c1ca83b7129765a5640c9bc841885bbe653ee1e36ec9c4eed516fa39820d15139429daadb5d1b37230d4f1d5febd58cf6b850979a91ea4f60e75735b87f8b85a68d6a3aa0e2af157fbf1f5c3323ef04ffb7b0e4566ff5d1cfaf58b9e7b68b65cfe163156f864fc2f25fcd85acf611affd5b0b5aad24cf3a8c42d85d991c9819f89d5a300ee59f3b0c9c4ec6269d10ef547b87f6ba8ba9392be24dfdfbbb150c268676ebd4997a1585b3f354172df88ed3c517144aad64ae0aa33522cc60863c9dfae12ff5a7a219e4a2433e7f1b0ba7e6b404af2a1e74c20c112dbb340faafa9fc33ae31982169d369bea832f7a546bb37516c3e3d179aba3d1a096edf60e6d2412b47fd85ae926d71686f69c98e3a11005490b6f9b48aa4d8d4c227b6ceee6c0890a0743e337707797322e42232d23bf68d223454804457a209b98462010d215d6769a9695d777156285013032d1ab264d2a6cb9b31958d044a0edabe0aceaef7de8e7521f78c55864ff3bc3aa905ac2dd919e157b57de7ee7fa9533be6b701e89d359e66aa12a07d1d1ac6152972e8cbd29415e9966eab13edd857cdb012b4f7fbaede7bad92b69a2d420211fadaf378531c2812cfa809f69c963fb7879e856e27be0ab9989c116e13aee5bfdd3bdca30ef47c77e5e669328c30badeb1f316afbf21e8449eaaaae5ed8e5070559a3aabfc4e88e9e9b4f89f4ed177d5a18ed5761636687555094e1a8884b8b7954c4586099dcacc22891d0ec73b55a7eb147654abb95d86524e7efe977a0de12f4c5983b99b811f9c1d8ae605584df195740374a72bbb7d5be090109941fdf3dfe95e8e4c8ff702f68432882d18347f969e2ceaea89825ecb4e15ad50571f2730ede232a67d84f5dac96016a0d2482994327e5220e87fe954bbbefdfef4a7d5eea88627b96801e7249be6c8b04f5a92c10a2dc9d357eb8be7cd8930fcfe6e6c45bf4b78f9aa0edbc3440924e284b6cc0d6188891d7e90c1411df25236a902267fa5f85cbd27b1cd1a8f06705cdf907e4df816a2744e0a086362b3ce689394ea986be6c73840036268f862bc698ebf05b815e6bac75a3fc08fe40b521dccd59d98a3e1dbf871d417f8701af0266f62ad52d32e9db642386873cf38fcadae1f83de4a235d1fc1dbe03bb686b8df67c5c3d8a1c9c3ef7b8f44df2049213e760df1d14e344f27725433e13a675bac39fdd4c57b28b9ad6e86d31d2e5efc5d649dc3b28ecc4f3707d70fc0c9c1a4cea1260fc5ec953da9898dfe66da9b296702952b16238d34602ff8f2108e0f2ef6a1274c3e1bce81dcd3a796b1201620ba0869fb644d8185ad41e2753934b95f6d8455a9c5aa36ff99a7b6a5a532ff90396f6bcb5e7edacd6a662779e97c9553f3bcef033e560b99fe6392bb36323dc72dc21120bc1fd5591bf4ec48a1a20fd81f504d9e95cd1f6f2d424eafff79404b143adc48d283f855a47b5168dc1b7794081d5f385b552a0d8fd612ad6206cc587dc8a00d53aa5f956499b38da58c5134fa6f2a8aac3d1aebe73659c436bc138e5dc430bb48e31b6634675975db6e301e82d1b20c280ed61ee199e9cdb26ca84665f1a69e72171eb65ea147bfbbeed8deeeef28ee32c4b813f5f51ebc6759149c0820cf7266f4ccb8dc17e5b7c82512e11db8073398aef5c118a104fa8c1a7352d71229a57be8decee0f95c0e043f8258fbff77dbdddda50a70838188e7afaaa1a2b340d63e6d9582d37de3da42dff5d7facd38fdaca743b7d11cd5e1ab25a4f26cd080c5c5957281c41e15726fde0c5fe56bd1d04518eaa62e583859c2dda1f133ea337a9af474045b7c337c98fb315e36f67b40ed0006c571e2bd3e25e1c0b6c53b5337cec478f83f162a30002f1819f94bded5a27eb145cc8ee08a7bec5e23f39429d85de0153fc947f8d8d100a390566017823e1f547db3b1163ef7db6b9802aa3e9ebb25cbe4600dca243dd74c96f875d11a4a13e89bd3354b361451daa04ad3693c93b5a0513e3870ea9e207a5a5694818045100cfb6f45866267e80f5b6631c7cbfae2ba54153bb10200bac5934f8486661941b7b6458b56d432a620bcfef9a951dc812b0a57fc004ed1b1cb466c30bb06d57f49654ce038f04d04a29e9b62ed81f1f6ddb104488d636bcfd9f2bcfa7a983d5c0ccb87ff83665ad1ac819ef082e6ae9cbb2326cdfdd60228391ce0240dbe09d33727bb5d5ff2ef6a631b31499b970d10d5bfa4e77de69d0a8dbe36fa0504d287d56bb6d36a94d9b28a5c84fb757620a51e2a14a66454b7ef164c72bfa56ff13c480d941b59917d8103c1757303d2fa182c290e38aaf775e9f67d0158de8877ad6847ac9f0c4c456cab7d6d40f5da13893a3a0a1ea5018751682ed1cd93a6ee5e05c2b95126fb95d8bf31a0a4e2eefa4ae49a9d64335773f3e299bb92add987039586928d5ef3d42ed2ea3808dc3e36d2405a9263254ac74ca45a4d17fca9d0e0e8fd482f7dac8fbd929b11a934ca63f6fa32dc1b943a1eb0515cb8d06a7c03487860f62dcd001ef4072063095d4be2f6f0c93aee0b7bc921f38824ce092f9a0cb1e7cb61bd6c519ab392c499ec9bb0c6593f405fe028789c3e38e3fb05114e246bf427248570a6bce78d5af1093e518a9a035763c9211bc68acb9a59e267dbaa84579bac1b097cfcee5d66a672caea943a3284e7cd97e3f7e2e7d70a5770a4b8bbcd19a75e7e521f488d6b892abad29d9338678e56c56a0edb38b8ddf01ba7f10b1dbfdb0f7660eecf2eca7a7c791c02547a4caf3395b5aba59cff0e642947107f227af8662ac1fcbd3a3612c1414284e0c5cb71ce79ba6ef40f9f3866d90c41390d6e2939ab34c85ada63157b6eacb5798c81918aac62a0dbc63f641c68da871255f088f76f8220117b4b9de19e044e9cb3a9e9ae3cf78636a16760aef81935c74ca0e81378475fbb3f3b37390045536b8057fd1244ed3e1dd808020f8d65b2affb05ef80ac2afe430fe74bf4ff05d9a8c379a288fb0ee48a861535336c729b5c1ef1e708e4991d31b9489a5ea363c4474c4681e3a0b1f8aafb2535f146ccb365e197f70e7079713887493b0fa84f0f632d4ee5f5494755496ed8af00bef7f5aec3256550b1c717dd6b932a7096a43b3b484afbf7e0d32aa6942b1d5969f0d9f8f195b1d7771a01d8b95bc40c8128117c6f4a1d7b8bace72f004a721f9470d3313f730732853ec41bf82dd72066b748d6a358d49044a93310fe986ae49f2ec651ecbfa9a9e2234b177c6e8ccfe4be4d77e7fc0830ed722fc9ffc27834403732e9234212c1591ae268a3272763dd5b201edbc83c0b35fb421e552085aae2466c63e02d0e44f63fcb10848a99ac8177fb247f969eb1badb92be57fac0e9abc402e85fd29311bd90913c1ca7986dfbb3cc278fad6de77bad81c657b6c010571484536103eeae8f4ddc6870977ee055442b995258d514d245e2d06885f0f55c2d9366e0f73d7ff3aa34f384d2dcfd07f08b85101bacc9c731a12725b3d097c4f3b98ecabae3630daea20f802b3c70a281f8cd56d8b7f1829d98087bd80cc2d8911a3033b29627b16bc82c23d224edca2151190cefed303c4590b7201249e1e152219e4ad6d8c795ee18f7d174174844c930b724ff4b1203de88298b93198f6f852426899496eeb5dec2e52defd68e1a8d3ede6f8757aa3c538798e29ab714bef7fc14c5ae01b9b7b59dc58ebf37f4fd796335a41436926771e8972e7044a6c7c30fbfcab85792205a0d5d060d8b6d528e44e0ec73aa7fd760bb34e45423f8e1d80e7385742cb09b1088bd8cd859be6a51e4ad5cee652cb88f142da0da4f93958ab78f5ff616b12ce0b16b2ef84d3fad03ed77214848f2b4a46fd17bfbe7a2ba0d50de3e3648976cf10640b0cc9bf5cd02813b633a31c03f72b87dfd20c5705d397bf199d9ee9bb57455712356db02aaeb94149cecb8b1c8991b64c578f20647463686ba94f0946e0457ffa33a820a5aadf496a001853cc1c08d69a00fa87b17be57c2ada10331cbd1ec70e3037f91ce179e1edea9b72501ea0ded0d1a96696f013321bae9a0b50b3afd3f1b395dc20da1a40a0f064629c9781a0fa45983415a00dba9ffd114c263a6c9e0766364dee898cbc25c51a5dd1227ffb2814e0e1ff14dbf5a0b46f4dd242548a411102c456395b2189951a9d4a47968b09c4c981c85520a9cc7c3b23f1e9321f05af266b3480abd1b3cc1788582cc9ed29f1cf30a5d3910925be170155860a65c0cf9b172b414439e9498e17464239add2ff36d6ce012a7aabe7652848255319177b1e0d08adc28a6f5ec5d357d75bbb17ecf986358465f29fca66e028b8ad11a4214d8a97b0e6808b873068aa7f88c056237029c0e78c58d34fe994447908fb1c6c8e48c393679d9b13069fad6734d838ccad5d9c89f5237d1ba009776cc9114f4a5eb666ae75ab9f86e1310bc00f6ba7ee02ea644c282e2edc48369d03a2e557befa8581326c96d109b6b36990a55db97043915f9bc9f4b17409dbe023129b0a724a338aa859fe12f165e4e4e0a7fa87edfecd6168acd7a051d7bf26e09381430ed91cfb1e832458f2332e778821b7432f99845638be65eace5422f9a40c9f9c986dc4887851f10f0c48456dec791b50bdf6f56d12110738c799501186fa80aa1e62ac00c2ba27b2ce8016a15cd888b88c9cde57acb076b16b3e7e08685a609ad2b619f26076c8014cfb0bd211a3d10aee80e3485e1344d74f41d6b06c29557baa14349606abf6c6bc0fc9890b813a75b21357c76b57763e388a8fbc622b5dcd8364e9ba3da19dc3b9e6802d324f03b460633a5df53c73bab76bdab934f3bed4ec5785e4c7756138503f4690e5f223b9217f941a7e45585947f3a96fc6ae24f451451ab14fe4b3112d041a56977b32b74ad53617830390e8d7289e2181ef80cbf7d8aff34dabf20cc10eaecef3647d0af4135309e7970b995ea7edf3f3a9e55b2dae32c9e7a72c1d36383303d37bd8b7ca96c9b93615bfba73252fc1a80090f781ef5c122eae6ca4b008012996d4b4c6295e1cc2b28888f2893fa61cf0c4146bd5328be23c1385bf7d04d6c8a1fa3ceb3f41772879b8e55ccbfd8eb295190fea5b291fee27a07783f2c02c878d051bd4407bdd3865b9e26c911c1006ba5885fd9f19c1e6ae6bf2602b636f08618caa6e1549ed9f51077b5fcf4cae6b835606c4ead6a3dec6b3447dd8cf7585df8a5ab5521dcc5d1f12bf8953b1c76db5aecebef2de9a0b348e17c4e6c908c8ed7ec87dd642d2f518b0b14a98634e831f2b810ecfcac0dc77bacac87f6be338dc9c07aaf54c58feeb67f0c9b539cc0cfc03c319d880572bead21cf4869c474239833be6fef2c9c296c3268eecc6c98f963ae0bd43bb6a8567dfe1144d1104200171238a198b50d6e48d3abd854e8d1d7873a40b7eef39df7244535c0515e40169a5331be5990c4adbb4f4cdff65c4243752c0885dfd16a9c218aabdce4e1880910e48f8c2ba404198f01e432fe548a0f0fc6ec26315c215398d5d126cb645e1cc858d0ea8cf33ad273ee8176caf71176b96f1c20783f9c61902c9102e758350b8da241ec888bd2db10f05d4b281611bc0096e078082396ca816cea820f5768e4e80a60260a50b912628f388ef9ef0b59d26bc51f3c4e22ceefc73b05712f866e3df76de37bc50230513d43265f5b1b2d098cef8ed856e76bfa67edcc5469c99e696e114652869aa070f1d4e1be7c0b15bbf266cba0196cf289981213da8bac79d3d90a8f319210ef8bc65fa0687f0fefdcae4129778d9b39f1a5b4c44153f7b190308886a209ce0b8ff3a36763248002bdb0c45ab184cc2632e300b640ee6637af3778c818f1fe94720709954b17697198f1cd262742f58550ebc0334e6f01b565c14bb20b5e2aba39720890172a22bd867dd85d1724241bc96e6a3ab09b78da003e0c12d204761fda340ccefb118972f204015229dc2f9e7824180f688324bd9b741c3fad4959dc5581fe59006686cbc9cb80dfc9e8770d2b894fba527d4b23c1496531301ef6fdb4f8dd764e8b5a6446f9a8aba80b1fbf7f02754928fafefbe578948f873e1a71028d9195eab42baf80b423b4ad6884edf18ec57eae96681b3fb013796e3d3675f7ee5676df1fbfba2e32ca04b84766a57a14f02befbf7c576eece526c8ed2cfc184c02c0d668f1b14632629365cebaea15a69390ecba0674e22af71e58447ac4d9f1f8675c7c24edc4b1fe0a5cd63d50e8df1bf6a61786f1021afbbf704d122c54f4334920ddd77ed471538382008447eb08777f33bbbe186fb1e0c1bf3dccd737bc9e161edf7a32591de11ef80090a41282953c29376f33108559911df6a298973a17fe043498660f80f0d70065074e7b6f03d080bc22716d9c005b726116146ce26ca25679fb7be4de71cae6049dde7f2ffeca3be29df1cfcc0da47980a65581f15c7e849fee664591f6c1323437d784e1f6bb64e495adafbed99bc135b9cabd968aba0cd09776c2397d203d5885077a8a710211f295468507fbe02ab0bf627a24dbc1d784b95ed883290b484d29f1d8b36a067bf2b223fee057effe6f6d19e8e0c57d9ea6155e62aa2e5cb57ddaaacab62cb76edb85e6b6d43b27793276e19fc835747245c7775c3cf034642f66683c67b9fe2b9d70270946f8018f1348f58b481d818bfabd72b2ccec45ecf5d70101287cd17c78af656f5381dd5456f49180788417f2080ce504d509ca34ac5bc165ecfde4884ffce2dfb3ecce943e4fd120d800a0737ef6d17027f6d85686bf9f674ea9dcaa6bc92b89f2a3c43d75600ba05207123a2d3c4d89d08c998a5d1c6fc31ccb79b658ee0a5af000f4a696417472c25971aed63391558747943907a415eff6ba6eb0a0d9eb741eb87424e9be708c0b4587a4a884c4903acc80f9d9b52dc053eed1704f479b8d691cfb2ddab237f6e58704a2f5fda2b7918e0ff415f5786471af97ceabfc6dd1d8dbfa8752ca69b9c27d38c4bfc94bfcf5b7cbb59189e40aba854329a65fce2709c30491ea6e2854f7e92fc58d5df26a46770b798d273c0f4e691b6f51c5f616d781ab7cf842e73417819d455a1beee6619de6ab245dff2d8f60722fd94cc339c82c90f011fd1e21e4461b6eb219c0acbf5b52763572968daf273b18d2a68ecf7b858b35db83319b0d9da64ad5596de7ca08186160035f20b74533e1faedc57a650f84ffad2aa5b5725ede647af09d3700764f63ce7de9c30477271f3dab912669fcc130f40b1513bf220a84f64319a3fdef66cc51158107bac55aa08f9442f0ec3c0972d9155ed9f1621534c32d7295754438d5ee969c3e96fddd155ae2a573c1af74eb9d7a990b0658c11d1ced68772e2d2cf35a04a46c700e0bee99a816e61a556c9a86731bbd1c97289b819011f6ca103c3b7cdb0c2679b64571bcbcf4b8779b799ef2fffc66272ed45ed0bbf724c0ef7840b39a4c9a2a2e22eee2674de59f8605e608ea9941e73b578a50f551f41009f333767fbda1179cdd056081cb50e4b6ef8ae142c559fca73258e1ff698aa327da9bd8850125c83c940c1b097dfd0ebc7b32365154fcce70f1f07aee3af23eeafaec724a38e0ce2a76a32f3a340845044de2b5fb9933ad6781e958668280d1d3577df6d90c3d0e80356c0e1efc5c3a5575b7961ec24f4048e2b2d691363e3b6ca08237348f48c196ce84807b21a27f7ccacee00d1d7e58222c1d47a89e0253c9f402a78dc12f4d18b488986d1dbcc286f7a7d93597eb294bb1d664414d56acf3a2ea8ccea27600243f39c6e5d279fbdad2f138e2a3e8657cb4ad1c50967f91f25c441d1c389ccd8db163b45b87a4c84e8df7d143c0e5d399c7bb6b911b2128809172f1c277b8306ea6ce8115ddb4f658da5f534f4b8eecda218ece821e251101a40d8828b396ab38c3b6e3adb54a843c74d687f03642338c7845978236cc2145477c1799516d47a0be3c21b30a988f240978e0a55c94d33dc003ec7fdfac3d916fc7e8fc8f8fd327442efb0b0bc29c92e18a17e5729640d2a0ab9a7a14bef1af2599ac508bbc68a16cf47e65c5ec111dc14fae6ec564273b2bdd5317ac1a6f19873573ca1191669c0c228f715f56657aba2499a824b9ad70b8c608a5d38d38045b16a9c7d31c8c41a984e4ca80e350b67c6e7463677c3b95678640cffa44b7d32a5807f49fc8e7fe126068c645d83cd30268bc75cac5a91247b034cef17d921d150f0e1c4ab23c9297a983b714b5f331ecdffe08b6bc98c7fba2a3a2a4a3f2002dd023fe7c52f16e3a53ef4636d906fddd32ba22d25d14efdceb314294787cd58a7d004eabff27bfe1b5bec71c290720b2cbabee5129d293a5467a6c36f4680278bfe237c60d335c4db0682cd7fca392f41937e1033bff7449498cf2e2d993626a11a3ffa303cd6088d2c9df4ec5c10dfa5c4a6d0fa897ee3b4917614aca3a777d75eeaefa5991c5065548595e60dc5d4f906e248d5d87aa351310d1c56236714e86d1afe5cd26461bc79191879c89f10f2a00a75d14e855463aaa23bd6a35034d23d2547e835940de99a262d369595d4ec14ec54ccc792e000e74cb6fd8338d31408e6696a11ab82e75ee8f59c363aedb55aaa4acb43a222a55b1d66fe801f1c59f93071b8f06decf94136ac136c1ac2eaf48d2afdf7819894ac54d189fe7810ddf0de738b6ea275a2641428c91a3eb5fc8501dca43a127d0dcfa563170ebb90d3ba4b74c76a3db6439e901ff79443dfea1968f521eb1d2768ef9be3fb6135e5b88960098a1731effd1eecc1d901f48223697a546c3114ac94a0e97de5567a9fcdd6305968a5ae44e04dd5173054e31a022682847fc1c7ebc4921dc7de94eabccb3a6aad3ea8b8d8546d8f97dd3c1c21f0f13f91ce1af5eb6a04fafc6c0a56990599c485817d201c319275e405476bbe7a7942dc00d387c474da160fc7015a760c81ba4b11016e514eee5210c93fbd183ad2cd3eea22ac8f3097ec49349ee6ae4e20e55c8ad4a9afc0a3d349f983f5f8876282ecf30b8e7f17d3fb6a88cf5834e5c7ae198e7843640aab03038363cf5d5d7a1555adc799ec56997c51106a38a48c721259fbcea0f9c0e9e29b5eb447ea0f1f9ffc5cb3463d8774ea46879aa81d6ee71d8be7be01fb4b56419cde683dc89a0910f302ca9e0088fe7d8d903c9bc4a2abeda59f2a1ee322935cfb928234b24c90ec6f8343553de2c185d6da1e3844b18e3f0adb1f2c0b9661e3f939012a1279d72f27074450237e82be60e3ab2ff4986b26986b1fbfbaee02878410169328ea90627fb11d351671190b04932fbd945e783f5940b64bf5e46450f858457c6ddf1081f6c96a731b0d5d3b24dae3cab6158e481e6ff78458790cd8038f23196b87254ea15dd71df951b2022adb92f5cc27ad8d317ca4dc0354a828855cdfab33e9ccfb4ee4ea0e7c50b6ed34429703292d6b14184dd6277f57136c527fb067c0d788770324e5b48d53954777b18270b8761caec302c00866e137a243bd926018d72ece6962b82e6f8aaceef21e78431bb16ed83f198365ceef182d2924b6f1ffcf3b0b4cd4dcd9cd37380667d43f9827c992462c4cc4a01aad49dcaa7af7402251722ac8119334568470b6ca0aebab389ce9a2559b7a1fa3c102ae3e15babd3378f8efa31a240a30dfe4cb8db452630516b350534c53fe67658bc601af585682f15fa1aefb6f5196cf07729021475984e58edf082307e815802fba7b2f9308734cd6dbdc8cc570008b5ae6c5fa46c58ae4611326213fd5c5e1cb6ec67dcaed279387007b20fd9aed8f734ca366fee42605f6d8c52ace70db590bc0a2c94110f9dda137880665d6ad96ed907565254e8178f42ee6c32c09c9dfb2257209439f307b73f84832d84ea6151af4a06eacc55fa7e2c11e27e40f158120312158e783841d29209ce66099263635de808dda5c9c1c4f6584c1f5d166d1b5ea5ea08160f699163b6a052bc437f22f32f741d975e6a356450b7dbdd6a7429a61e7f7fa21877e505fb11fad7a7208a36c0450eb87fa6796efcb06f9d5ec5ace162ac108257fa7fd033099737bc0b39e02d591f79fffafe5878429d254e38e62bcf2727b9a9878cb2b37254284e569fa9362378e69bf06541681014312e33d1adeb12673b2b8861b75e6378c205cd175faf7d6fc3b097ccdc7e880a10f235c436b7c7ac76aa54be92111f306f03a651d28c67cd209b9539be60105ba0a042c561c57d703e1d3408974170d5e63db517ceb1f4a558745706a267e46be29d28d584ea838d645686858a1307ca94d0bca8f5165ed7cf967f34aa4e6c629d39217579445d95d0a624ccc4308780cdb6547b2472d27c42ef38be1a669b6868bcbec3476904dad864c4381311849f74b211f5446fb004619343ee04fea56ea61b540879f0231a944f90e6c1dda69d58dae23db724b7dd9e903f46f534f675725635f669cda36b9b87cc10e6125edaa6a37a5661e693c13bec57fbb08503cba81bf7fb94ee48a1f80c4c0453de0984d60f7516c896973cf606316a72fdacf08f08407cf0b34d8eec8613875717ef0bb9221dfd8982d9f46718c3fe94d48f794af30e0683dd0156ed26545c18b938564c700316bd5adf19f9ea4dee6aecd65285e989eb7a45b604b5dd3ec958da96e23ecab05a7930a4a5ce6869a30fe8662573beb64939516566c338e2b1cf25c8eab60507deb0f89d9bdaba7321e3b4bbbdf95b8c9dba29e147645d1134ebb846f65c1041a3a4fee14ad87434fa981377463b9e9e0669ff20708e629dfa118af3f2db4426c2740006a92c86efc25672200d6ec2d0add94b99bc2d88d8c979910a55b6d277b13bb6ccfb9ad05d2d3cf89d9b6a8f187fa3dd6595b12ae7b6e4983157a86defb4d2449bfcd8e643063432c63223938fb63301c6f3f480aec292dec34ae24d171e322aaf1ba823ad073f7c50e460522cc24eb71f246eb386d09d36963ab9a43206f1ec6bc094cbf11fec0263360e3086dd76b8fbfe3e3b85b0c7e6aaf3518d5365311d3f37666a5b754fb20c9a354484c90684d18904e1cccdc595c2ba71082b0f873f5933a3f12513a966164fe0cb5e667c45b46ef83c171d4c0d1f4f4dbba08b36755c0ab39b5b20b8fe2d6a1b86c20849dd2a2c1b1d77c73904bb493ce3994d5c958837183d2a7b8e7b3c9d4112628cea59cfebb2c33e0aa205cec640dd55ab467ba2f83cc662d3f574733ac5a3e1d5c1104e847b82b64f978e70e86ba010b34230ff893d6cac719b85cf57bd56f86776e5d4884174cf473d31cdc5424e7904360fe98b1905347fea14f36bbd873d1135f76d65cc2ce95cc1b8c772d863ac9308377b38a0e13dbfb3ae8fb15bc58397d35820b9034023803930215bfdf46961e9bd33be529011b56a5ecd6fb91aea5765b4d89fc47229dca7bb382e321862afd3dd974924b47a13ffd747e8bf3e782bd8b5680ea7226282aa0f15742e2b97a7cf51834d497a922bd1b5eba5867718d2a6864cd933048d0a1345841f0c9ed18597facfcdadd45b45cfe0d64b079b1a57c0eab90937a32443f0de3da21f816feb5401804626804fa650b0bde5d7b7cff50ed07a2236b04e10953bda96242f6db3e6d2530ba47ca34011884d77c0cad55b88be24ad7349785e2934c1641933287012f0750a3ddc5322854fb2180a825b1bd8dc5e65525789f3c386763fa17d1f59b2f4b717ee8b313a45bc99b6a11268c85d42a2c1e34ae928c789b3085fa772adc12c775473de334f1d7de6d8d29ff6a3802722a9a5ceef5bd5c7958ebb9ac55211fbaafadc8f01c1c05f76c40e31e36997651e4b5b4cb32ba501374d0d5467f0c202e8d39ffc200e5366fa58ace5520b05663746f8a700e167ab213c12c9e699b93117da20d0ac63017710aef24921715bd2c1c43fa05462e6bd5a9751ab24c7c4347f78f602145f4b3c85a7c22f006f3fad700170043dc79591d9e5bdc459bdef2a46dbc7350d2835188e060cb42fc1fff951191df379edc83c150228874057f928ab933a56377836eaef3f5de44a330212e3e6b330e7f2e54402a73167d4bf9d33efd6ff199618af1bccb98ac19a5651cdfb271b113bff55e180af0484812e494a867b5f92ca8124dcd4aa8a25258528e3e37e7033b60472853ff5912a43d10b67ab20bc3dba625fb307fc28c488e0babf70899dce5d64dd42bfd5cf150f639d3fb65d023e3d527ba1a91e3e8271ccb97195ccb51e3cd6d8c02dfc66b9359f1c2cd5b5bf38062a385838f374e2afd9df08f31639b59b11047d1985b88f4fca81b4149fa8604330e9f4999c31ae11fd2d64d076701f755c1b72fcc3a1644ba6169a5afc7d8782b853173c6911684362be7b41404d0aba2fd5c474cf0e17b707844430ffba048c87d7205bde99c997560d0b6b04121f7d89ffafe5e4f1b961827caca860c5626acf3ec9c31b8bed1c6d6a96b5bfcf407417423df3ecfc6a0ecd76358107dd7ef8e15419f98e775cea3dbed31538b97090e4e2cac6cebabaf324dc8060d2ecc463858525c817ba40045bfe6a482851810c785929dd857fba5447295b1eb2eac76d83cd98c8261e7723d878625718e8abd6c256b9dff42b8687e761097f4532abbdb543c95456f7df2e1edb454e7b36a30b4485e9edc0cea9c9952cbb5cfaaa358e651a9bbb0305dae0b70588b33561e25a0ad1629d41f761e36259f35b9fe6c11882fb90226ba026c38f01fda5936cb939908bdabfb686ede573b6ba1efd42c7071e375a03da0ac6d1cca915ae578ab3180cce999a158b89790d60d8ea51f6d4cca5bb896ada892ace4b65554a4769b975aeb33e264e54c1806e4640b8eeac71a4f43a949a210e151ee14a47d2e268f1d980cef2184f3dbd6a2f33fd1f7700a1403481b3f81afb150d0c520c0e568cdebce0bd1d8ccac1392a3339d8ac01f5c2fa197ca446905fc2dc3b55bff14ea90124b0269f90982b59ee18896b54d9dbd12d778e1a21a6d847247337b0e0e04d5be6ac569a9e01b5be5ab2281a5c96ed3112df682aa7325fc2417e30ff680ad07e41ee3623d3e76e0a837c99fa21d5571d9283c7cc9e723ab5021e17b508d0ee2f322448db786e3c8b0857f570dc165d5e1e37e66d79a640e25d7c64241cbd2ac1d41a996f57ab50f3115c6d80ba2477bb3ebee0a4c39520b22df0ca951fe09cfa25926798b876c8aa9f8e97b36f9c35800eb043578c12a477241f086b50516ccd733abfe77dc926ba46cda88672ba8a3b5ac53f94703d6486f78abee17ea4a05f484f1728c87468bbd211b50f11d38048fe921ce75ad3624149b0c8481d4a203faff178c4ffc2171845f4098c32eb0c9362174f8ebbe520d729a84eae1adf28c6e7e6cc985d61f17615ddd7d0d0dc874234aed80ca5908932a84a4970b69daf7322dc520bfe3268073d97130b4c39788fb4683fc82c7bbb6ee602c9a66cca9df0349fcf05e094d18a05b770574380dcc8a5b42d0731f84fd5492e9a8b4ee18501cd3922bb83a021918c0268a2f88a450846f9128f210c68e3c683fcdc32cca7886ebad99a4e0b96b2882e74f5d93c340c52092aca18d81f98a242dddca97b039ae3026b0a8f225cfa2ff02ab833fe715aea826346a61a3b1a69f5ebd8a2511e9cea941e342914bb0f2b76bf96c507e5b4aeaa0b3ad2a18160732f78e201cb4c13edc8d48dd0bfa878c122ee668c3f0a810f9c680a5f7d46e7f345b18b34b6eb8dd5f8541fe1f82f958d3ff17b173813832f2823aa015f2461f9263de59fa60774c77013a8480f78d087330b72df7038a4a67c453a2e0ea29a36783b82363fd972669c3919e774b367a2f0acb69e31e310b0cf73e3bae59de8c0dab378b9ac2570e076530bc877e9b62f95f73be8ce406d8fdfff2e5751ad99bdd8e204ab8ba77618fb1c2a83f9b63e27f91f7d5f5a2267ee0ece001a1da18965c5f906dfc660780c0fd4475bbb0c95888b136e7b34869a3ad3dc07603ac2376eea6ff34284d1a74e07c6c2548df5b8a9fffea6b7ed60373aa74922ccf534b4982e2ce6a2769c57a702f8b7ce0e81603b702a0a204b76519b1fb2111638764e9fe079089493ddcb7507ce78e9d1b86752852b5e62f0cd5b1d1a83d0f5d41d8e84e67a06e4a9b74ccded6bb2a1a6a0734c0ef6df9a30b0e75e1fcac594319a584932bac3e33498e097d1e9f9d09d3e9cdaae22ce5249fad901ab78bf3627f129f16d18b9431873973ecf9bd6d5166e812512cb069c0d32fa841bc8659333a3fb63488b4d94945803d7367b7213fde0b8bc1a31c37af598603c5a98c943c325f232c4ee7f73f7c0753aa1298fde9442df2c9c00fbcdd0258ddf61b68dc923b5292f90541ca3069c51b7015b15f8f11a585b5e08386302264367a8fd91ea1e624bdba7b6f77078ee575bc1b1ff744a501642aa62aaedb32849b650ba3cc147e093348caa659ae5fa44fe2fa81e54a479d5b06bfd4d30483c2522bef422765d3db14869a4d175501c33b86b2eba62b317d4da89673f88ddf147eb73df6ffc942eec633a618bda8f4ec92b5c22c4836fa66e5fcc3c3c3d37448df2f4fcc50a6895899d0c34709335b5bd5fec23a5a27b9faae6bb43c6b96159b0e57212b004253e9bb307f6caae5dba496ffba7e4a72e485fa4f80b0593681f1595b2b556940f7ce9cc15cf847240c6b7fb40f6083bf798c037f581058fdb8bdc81850793dbec1eb38b4d262fff31079dbcf0123e797952f8f78ecb360afa50cbb13c476bfa2fac8ecaf1f2cbaea8e5d73a054517c95aab552fc6e4a6beaeaf4a233c64ff63bce1078da1a7faa0a00a49e5a5b02fb4ed05e3f164b6bcbd6253d0213f3f41fa8422aa7398f47469dcd47289425b5fc9f350e438fd89765a8ed07bbfb1b25fdb23cad3b1be5b456ff8de570963a5f420bf3b789f1f17eec38470dadceb46af4fda34f101daeb16c12ec7ecebb3d3f765261acd6c5472b88c0570d0b65c800db8484a3650168415d81ba2da2c0837ca909b253ac7b46f24f5f6949b653b3cb9afdad672f2b3a0b753ae644a00bf2a7960c7bc5c691f544dee054adc92734cdeac53d857623f9fd7b97c143865b5c77debf51cc109bed7c435e6a4227b8b95f774618b1ede626de529c5549d0721d523432b826f76aa9be2ccc8955ee5f2ec56d222f22e67746db33505cf5d93f2e687f06217bb975f41a5b054782eff601f0ef7fd1e80229308fc99d36cac0e8e4ba7b672f58a51178c265a5cc8c8b83fd81691af0ad19ec5b2c2718289c310cd24968819d1c6a16c05e3e0a0af344c4f74289c35aed27e613a9c70ea39055507d08298cac0b5a70559ebefb66e6c8c81d8a289bc45a628fe48314e5266f37535dac1220b51fe6676d7ea0aa4f277e2467ba4a9f0e91887f122e7aeae59753a5eaabef613d93b74caf697981fb21a763f17b7c112011a72af25dc32468d96642c00f80578cbed59f47071da7866c7bab7e01a8617c57168527c20741c76645c8a297a03baf57fe306f42a35c3b8bea7f6d03350aa2e00780a20878e4e02fd9a47c38f787057fb85994564a0f96e8d16d8aeec517a5412e9c4451850883b98a3bcb8ffec19f5c80f1866805725b2e7e18e3b36aaff43f114f16b9a3f1ea7fa76d31fbf41a216b8ea6d1cb486d867bdecdcd005118f42984dcd09ca40ca59d20a3b301a8797dcff39b1291ea4a333324880d693263375dbc9bfe1bb5640fe724233ea0e319068aeb6bc90640bb91d9247e127d9ff4dcda75d5c3c1265ff7818498ce2864a49d0d7387e5bb1510c7c5fff779497c63378920c505ee6902ead78623c17083d0171568c4628be900d799530553856e75d754eda24bea77aae433d764676039c2b5ee03d2ff2f1a7ea06363246ab2f35a3b73f189e06d3ca40bba6380f9839bebdc0dcf279e34ea75c1518be650b978c9960e956e25564c308e4321965a97119adcbca883f13e1e2ed960eec93c6f892aa8fd929199196e5713f6ff8912a46592b69ab4d9e8dec3edb8eb64f3db9bbcbdf35aeac402840db3d55b02ace35344b1264703a30d742f29381a26b19574f374baf97cc41a3466bd5bd51a1c07b29063f8583d77c4c46bc629aece7068fce4071aa8e1e4dfb5e73b8b1f748a614f5fba289c580a3f2e14c3ce4c4fe80b1174fa71b90a3ee9b7793e613cde8a73fede2abdffa5d877327b41de046a5b5c716c7f87bd27bb006fd8e4e6276301e361647eb5bf9861861d9d2848267cf5a0cd5533a1b9cf3d5953e5b5169703c10919c975e1accc55f521c3ef0f09e38e16a4d71b73b80045ef82921b3fbbaf1bbcd2aa326edbc845572e0ad9e28fda0673fdabad9868bbbb056b532f07a5c73740ba13d6375ef36445124b6abe860e1c5c26f5910178d4d947cdb890ed9743b308faceb8d6f434b48676b5118296dede5b6e787d030af15cb8809c741245848375bd1e21e51be3fd50a44cc1389c95950dca6b02d0195679ba71513225939217dc09b58533e20416eeb6c713d93658f9e00485079b37b896db79433ac393aa4b044676ff0f2bda648c259440dd601ea38e9b38e2f04c78edd9f8cdf653d01c7c42314223c368b7f3accbfc59e8412a03d180edb203384eff289c68acd4b98533e783f4ccb1936d8b1f1e5d6a192666c2e0564b8bbabce78adbadecd87b6c05da9a49ed616227477037baae9480b465813190f7a7b60df9812a8f2a624d6d9331cd2da069ab6c053cc88a4ca5a2bd71cbe0ee360141e2bdda6a4b0c3e5cfacb2d04e0c9db9dbd63dd550fb4bf35e63c967495e8c71b01c18cc6c85dc761c7477e0073369a5f5b87d1609607e5184726622ad68a9316a3b2f260d5f804cb4d9c2317bd3a44f8ca00c572d32b55f87d56bf369141185f75517aeec76c1ffd69b00006e0358bae0f48ea410eebb10a47cb47c21833bac923386e1a9a54fac7dc7bf98910acd43c5fd2559cbc8f5aceced3d8f3531d293b332f554fcccbefa834cc5306ae5d33ba26081abd990ce0b7f5ed329b0dd01dda789ec6c38af10cc923fee667ad0caee51ac4da2adaf47891ec6cc1ef5868cad5e5deb8274f69569ce36742a5526e8c56f68462832babe929967040f9ff2a15221bda163f7d193f9026442cd5ce9872f3b09f39a1b81780726964072ec0d8b7bde789a889629f7d9b1f80223e56ac1fbe2c95c2983acaf6611f1f8d4269bd383b562c1792697e0f3745055f534acc14707547bb1af05f98686af0c79b0b6b6d97bdb09366b811cb08510eb63b0c7c2a0a38febfacf5dffcaaefa96f1f559c0ef70f935da7b838ad490e40aec1f28a561841adea0180f0e5220c25d279a90ea22ac0742c4f3a090ddda5056c9c894ab9af8f4fe7879c60caafa7dd1c95d522157187bbd059d936910231cc698eeeb6e30ed07ffdc84c564ca0e02461b5b258646d5829845649ca7c7ed83988035b972e64e43ce56fc7b4059c49ade591bc99e562c7a79beff6b769b9c3ad17b9fa966514f58aa366c4ffd0fdd655c0af4364abd0e28b26dff927c699178c97dcf64416916a12fc507b2f9b5aeeaf4b7c6e2ccb05a5846b5d1cdbe49e501949e42b00addfbe7450d75ec4164e561eb45da2eac8fef7fb7b9a71cbc77cde1f57bf36329a8cda40dc0db091801c1cc157a8b8f4819ffa44c73d736618dbcf2a1a9079ba095</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave"></span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算概论C</category>
        <category>计算概论C(21 fall)</category>
      </categories>
      <tags>
        <tag>计算概论C(21 fall)</tag>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>专题：浮点数的精度问题</title>
    <url>/2021/11/11/%E4%B8%93%E9%A2%98%EF%BC%9A%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一位同学曾经在群里问了这样一个问题：以下代码的输出为什么没有遵循遇5结果为偶的规则呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">3.155</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 上述语句输出为3.15而不是3.16</span></span><br></pre></td></tr></table></figure>

<p>这是由于计算机表示数的能力有限导致的。我们应该都知道无限循环小数这个概念，在十进制下，许多有理数都是无限循环小数，例如<code>1/3</code>，<code>1/7</code>等。同理，在二进制下，同样有很多有理数也是无限循环小数，例如上面出现的这个<code>3.155</code>，转换成二进制的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11.001 00111101011100001010 00111101011100001010 001111...</span><br></pre></td></tr></table></figure>

<p>但是计算机表示一个数的时候，只能用有限的数位来表示，因此有些数字表示成二进制小数后就会被截断，从而比原来的值小（这个大小关系应该是显然的），因此，<code>3.155</code>这个数字在计算机中实际储存的值应该是一个比<code>3.155</code>更小的值，具体的值如下：</p>
<p><img src="/2021/11/11/%E4%B8%93%E9%A2%98%EF%BC%9A%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/image-20211111104545769.png" alt="image-20211111104545769"></p>
<p>因此，保留到两位小数之后就会变成<code>3.15</code>而不是<code>3.16</code>。</p>
<p>这是一个很好的了解浮点数的精度问题的实例，你只要能通过这个例子认识到浮点数的精度问题大概是怎么来的就行了。</p>
]]></content>
      <categories>
        <category>计算概论C</category>
      </categories>
      <tags>
        <tag>计算概论C</tag>
        <tag>计算概论C专题</tag>
      </tags>
  </entry>
  <entry>
    <title>例题：打印月历</title>
    <url>/2021/11/11/%E4%BE%8B%E9%A2%98%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%88%E5%8E%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8406c4d0a70f4e9af50afb2efaa4c751160631fd8bea294f55f9e5c6c8032165">b1c8743748ae1f554aaae721c1205cc441f57087a8f982dede0aaaefeeadf34161ae0ed054b6a11a9531566015fda12e00e0731b4231593877cde78bacbca8f124b53dbc44b7a78abae35725fc7efddbe8148e0cf2fa2bf390a93821403200cfdb2d99340eafff841edbcb8db41bfcff00c81790a81c70e4caa034dd87e473137697c6de7a64df8102346cc3a3c38534b99fffc2059f0d9571913723b46808d41a4eab3744ce9fcbc8f5e3671fe5623939a49d8676d04fa448bcf04e499025d9e0b442bbfc059429af25e8feda6ed4567484ea139a69526651fbb79007606cc948ba374d39d891d50a528130461cc81baa2af90102c2de44fb3a002bf04f0d5facac9f1c8aea8109da59b77b71e8b680faebdef79de2cfbd63a540128c2157abbaba83266a5423e1f75e704ffdb306601810d8c2814c6a6c77b7c2bd57fbb1ad7c3cc1c6626229fa71b649682bd3982a1ea84c771d3efd90ff7706f2de2724ea9e8c388c7eb90f588214ef8cd7cec54bc0a318944515775d262675bc78ac1e46d63f49e7fb72eb706c5928624dc3dc049cdb9201b77f61e1a32ac765de84130d3db39cdee12f7060340a8ff8ec1cdf28eba52bccad07162f7ef5ef4ac7d2268502e0affb3125b4fa2e92a52931b14d9a333dbe0ce30b50c0a7d18e4180b29ecec89fb9c86c70c5daabd31aeb564dcbc5c55f51d2e77c29d4d70df2c5c3eacf19956f2cd8d0856a286ac5088267975a3edbaf6f82d1a1241dd119c17d3c53f19b802b14ed567bd94cdc3df68774084f91f93558e9ad4f8ccd832e5995c95183e8324d431bc1f7c1622b8168b44534f268402891949e63dd04029793554237d7ade3c556d1d5a9336a472634e1680d3c17f9653787ac8169a90b813169267b93ade9334eac088891dcd5589621e36ba957d3f75283e829bab44eda531d454522e11663e0acd0566cf73bcd90c4eab33f7880dcc871f213b182f42da2858e861732284632b2bdbd48fc4a8a8366cfba2b735221f227ee471aa56fbbc3dcfa839fe64dfcaa96e80d3bf6889d2d6f387d94c4b90cf5bf26d1c42e34c838d3487c8b78e6689c60568f64a5854a803e2268c6f62408c1d79c7d01eabcb03c0d3bcd4e21083ed912310616024a70e93c2d349bbb88442498f054fb744de4f32e49a158702bb82db54621c826c8fb74ebc949a94e8ed085e8ffb84f4b2533ec4614c3cdbbb716e278c55bd964873a24382e443a6982f8564ab460f75f23d5c1bbf6136dc3d5433cdfec2c75615375034ba8d5599cd0fd5f6e6ce65804568559771fcba77da645220f1ed7a86d784f15cb9b349d3758845a6b3f8ab6b2ff22a4eb0858075d75ebe277581857ad9c6ca697c4abe4130f932f6aabf02c518c5a432de6af90d1eaa03dc22f7e0bbd91074fe0f0e2c7846006fb41129cc96e1d71760da6d6c635f895c238993ead7b7827ca805b5d236af57102b03a319c00e3256bdbffd09eb598de976feb50e46cdfca01237852bbeb9943742b30808a2fc0ea96ff4cec6ee8c82bf93a358838cb690728338a8450c9928e9f56d66b0a1b046e65d8b2dc57b75577298cb8bca7938f862b3514eec26c54ca4d81af85b293d107b091094b487810ea7bf14ba5914615ee04c09d48df2a9dd19ff15ff9b3afa08d51f1e0c664a565d662fbabc3e7c8f27a60e125f2204c3aef0b9dbfd171ab6ef29c58d849b3512477fb3558ad9c6b3bca54103caaed51c72f28f29ea6c933ce6251d2b414c67259c9ed7d136734b37bbe56531a585d65da527e5b2679134446b7f90886a235cb11925d9b6355fdb80a236756c7a5adf5072fc515a7206e5c7fdca1a6d8fb48eaf86da450dadcac5b7814967e0f380f0191147abb981cda32cff34c01f6e90c12df465c342eefc951395e30e511ace5efe95976c3e7373568edb0a6aa4dab51d6905a385d4de191d80f18ee2ac03965c1114542db9943732f727104f844c54aaa8d13f19d0359a1aedb8b4018cb90e1942d6bcd14a6d86fad3e963caf6aef1f3c43177bb2d9ead6485405c0d78ca9343dcbb706ad03fa45ca5ea8ef203ce44a51f7543fe7a1bbe4f55d179ab905ee1e08921b9c74879748dd4190d1e7e544610fb005143a80b45320b114f8764fe699f75fbd3864287ee694baa78f43dc5b4d6bd514aa5954f1c8f03cb042d189ca72ff1e6d4c23fe2d9d625ee0d94d214a495b082044a4f63a8970b0b73793d07f6c8cc8bc4dde204ba81ff93fa70cd4573085bf7e0d8e029a5d7297fd8d7b33012ab2a85f7a0f28f906c5d561ecd328dcdc964ff858aa6514c48a99365837b900e185f807bc3c9107c2e86ef2082b41e76d9f81721c178e9f7f88521152cd40f62e8fca94675573b0f816595848cb0fa2bceca0d754f4769404fa566c63c5bceddf5ffa2408fbe9fb8ae47564334cb8d2d7574fd3f5a5fbfbaf1af72cc0735e8119c57feff065db90a9018ffe57b641e0d9e50e1ff343de4415183d067fdb4467109b964f66724dd09017108aa9152156771ff8ddd0c2a41800a5a2647f38e5e0bcff1ddbe618b31ddbbc60a46c4468e5b9f04af44b5aafd09cb4a476889718f7c8d1282f7e01de838e53232265741c2679dafb8d6cc3cb5ff80fcc718f5cd739f155116e9df759ac81465c8d7460ced0ad779c34d2b9ef52d321ac417404422b28266cc54301745cb2a619dc4545decbecbfb8d8ca838c446d33b03a060bf2651c0c93a9ea8363a98ebf8ccd9304508626fc105a8eb49a2caeba9af232c41ffa96419f91761a39e499b31130968dd376aefa2e924305528bd7b267420761844ea866fd511d1bf9fce1b1a40600f821fa659c98aa0eb0c689453beb87f854d542afe1da5dee5b020ec9bb1ed41ac2f8b9663ed6b9a9cacef5c3f5ec473396728ec4b9f27dad1a79b4b2943afb3f3ff7b2862791e4b3384bc448271d5801c62d61c81581fcc70f560a97cb87927877dad8eb482224bb67d16517d2b06887c861f49850edf654c44ac450ae66dcdde919b08e3b66f43fb50af292b2413adb4bfa04eddb4a5f9589029cd70095161cc5e1eca8ebfcbb1f3b8eb7fc3d6e39f1caebcde71b75833469e8ce24231a64c829ca73f1fa193a7f9ca0f2eba792bdf003b2ed0127b9ac05136187dc6c48800320168b6eea1872d3fce66959666aff14008fdecf48fa99d8fb37713e0b7c1a4ef59e06926e69f528a2948056b35f9f8b1a4edee567ad3d0646242beceb630268797d6c5da7b0ca9e7c8b3945f744463d32c3d8dc94772e4e47c367cd54a49e12c0a8e41e1caf01d8c72d2adf8514417c1e9c41c3641370f9b2560586e1d604511df5d95378c555fb9754ac58fb950a217fb79a27321b17bfc63bb4f422b05fad8632bcea3aafa276263025f3c1f0aa01fd7f578061f830da3d1df8cdc3cb78393a9f6e6f1b71326105856e9f0af3af5e08265b0311ee8e9600f54c38e9e54a4d9f2e32369d36898454b0647654b56bfa4dd5d6cdbec6d848765d4661c4646f0038508da94db1c478d77a964167bb4aa7a3257f5d88a7eb8ee81b10296037347c9b3c0d6aea452750afac54359a821a66eb69729afff8279ffca9e9478d25c729a2e574f68e2c9ff3478f03a1cc2abf3a11dead2906a14c3c305ee597ac8718d1a087cb605708ae5286f00d400f76d2cdeeabde8e90eb285dd47f50f3b06fd28ac3e1e39832f77b9517b2bb9c2e995bf1568db611db6c3f31c2f516858bdb535fa5a9ba51e9c7ae9654fd13b64b77f93e129f7c0a34f8450922dedba7fede0920e8bf560d9f44af780f0913b47d3b7f71c3edb6f73dbbc14fff1e341d298ada478145ae13bb67b2250d5d9ce90ffdeac55aceec46308792bd7ed6d05955b0abc100e9f48b25d298f17ed1321ec16446eae7820bad27073a5fc0a597d3ad9a595f47e8845a218693c79d24bcdbf7243eaa70a5b7dea7c8cc2241ac17a7a980a506e883b7d734530df713862678d6a2b52d78a31ebc329bd754801b7c2291771e758bf8e6b5c6a38f7dfb3a1b48a8007784057f0f7bcb58ccb72020a8168d0d0a60c1acf4d97e8489fe0f58f02bcf6ed0fc4c4e7f0266242586b57928ef2043379970f9d175ca1cf5994fcefa1a0d30c5d34c411d6fece30c841370c392efc9824d81c5219d43cff825923f7ccaa7d2d9f46cffe1560f292ad6394a6691660d21e29358c4dc0cf8b5755bceff524623c36c9af48e5a7721d006e3066b2d0df2f37b59b4d977ab3c6df14eb32808a76451624b9599f858f6ab0fb03762b117a2aa4cca7da96e5f58b3da411b6d380fb3ca9371cbed8a98590067fced396ef2164df8bafab6faa401b31c94348bf892745b455b9f8d28101e08313c12954cf5433c5fe52483f2e8565e9270f59e05c78393c979a812264d906a291a6380e4fe02e3305ff67c70c8085974e1665c92ca0b5cbec7d70a84114665a93d01685971bcd1e87061b23a99cc704da9c57ad95789ea06b65be09fc4d5e8d9c6c971143a04b3ae413afa476bcb1a899fc894a5dff323926285b78188ebf697023d47c9783288e38bf21a2baac8167c775ae0ba7829843ebb1b02e448244e3f6b1864df48acbee33b4a3229b154964c131a394b2e787dfa0b461b1d818b460108b1f9184a919f73eee444c3683453fc5bd145549c6740e5c745a265305bda021826745d4756290d843a783fd56c9a8bb4024ad0ada0d295711ce3e7ebeba2262497c80f2753a4aa23daefcf30070197ee3e34f824804f913d1d34b7deeae5b05b5fe597940aee9bff5f4015ff9964dbb9546e535b0776f1166cdcf2a280f73fe2f7ad997a016fce02b26e143fd407c0c8a04016a613a4683183910aee7b531592f488f573767db74e850b5e82ca7c5d90b55e8bfb55445ef93a93fa7deb26676c486c21b561f5a6786583cf3ecec183dfed046965ae1eb454674b7295544e98d6bfd4cd807b83b349ed89ac90be0164998f968f1e508d1cf099f6abda6400983fcc63fe4b065180cc61e72bcd670024d29f2f0f6794fb149b5f086c61a3f287743b629f66153909f3090b742ca29286f71c057c5752bc3843095affe4c1d56e821b82546c6b22636dad9b2ae06fe54d10917cdf531acb55955e500dad097b41a06d3b05826ea2363467ca3f9cb3dd8208fd265d48b1fc2f35be72bf15d87f494dcbf80ecf8a63ebb6cca28b62aebd44d08f432f17e056b8b592b7004f37e6ce93ee57cad3b56d4ece8e6a446eaa1dbe19bb496b49fa241416b482185c776666dee5a46b46f2e01a6a61418f1e41d1793c809cdb5472afd4216d48eb5910e8ebd0a45d41c0eb329e1d9b9f96a4f7f94f2a23775e6d38ededab3a48ac1d0a11ea6b44d45046ef69092b36d930742d9c4d82cb297b46dcf186065a404b8da720af7060a75ecd456137a42cc848aace0cdebccfdb0f71662d942d6461c805fa2fc23c11590a424728336414ac0288fd88af2747c0f4762c96dfb27151d93dc56267c7c8dc1ea99ec2e4ccd3984e040736bfa8c59ecefe8f367479634df65f24c89833bbb1e5aaf84b04feb9ef32547b8f8e5b3ac35157913f2ddb99fba05d685387cad8c2ce7c605c1a482dd7a1956e0802d88990d1d05bc546dc598996f29c966426f41d8afdc71751e28e4479c491d9e97ce5ba0b460d44cbcdfc1ce7606ef72a1ee021f83eb15f4d1ea92130df8a6c7f89ceda9041c42343447f1dad64d0795db90d16a9e620aa778c3b794b45ee40ab02bf101ed8a95a3be664b1e6d0821b8885b4dfb10b68e283a02c87a1c2c54232cf23db5df51ae44137ccad9c52eeaab84a9b4b75e05d7e0f82f1377ca21db3c3ffc853a279cb4ae401f5a3d93ff4275757144d32dacfdbe90c12c51c129616574cc9894e3fdc67673c39ca9b5c6bd605b9a2765480faff3ddc77e86c62a937f3b00c1ccaae1d1b229607f1d59afe8b53e937ac8b14d5228b8d684b8130901817c0ad98d95f93361da6a632d78e7261b624c795f6b96b801c931ed005251270fbd22c28603dde03a9c3ed5f44c384a921b32c77933dfdf8e8021752c08c373526c15a14b0959c4aa059b2b9da6cde26c3073111a0576a50541e3fdb97323cc19e089d099a2dc3788d161daaeba489c7acec4397f86c499c5d79177731bd4f4154dca287f204ee137d0b4b595f30a2c429c9c14f0c40a2e3a62acd78c06a42c5da57c0f2c8e828530263af017afa44424a95584d2a0d19adbe8e8461c91344a102e316806a55fb53276926c50e03cce256262d4387b4979860a1270c7024e7ecdd26dcbd8d06374d09031a614028b599831d8f76e3fd237bfcacb945b073d75b64bc8005e58a67fa27f9bf3f57c2a3da314851346996c28c69451fc11fa4f1610db06e5d3b24bd0f74d74196073a65b4b13991ca1826dd8da23c6904ffc674ae875c057c042c6be25e84f2bc4c91e4fef75a3e0f4fef2ed89a7123b4eb1f99ae25500e704e852fdc12e8301f83a87d7c7b7f2119b8aea1213e035538b83942fa089ae4bffd2a814cbb6ddbe372a2b88c8acb71f73910cce9ecf0450c15bce9447c86b2dfa529b53e0a1e00b38b8b7578490aaa1410927d7be2a717dff79fdea22685537b5dfb568be21e3d3d701c7385701fc404dc0a4d1342d5bf28388dcb99372b563ed4ded9fc1ce21042add2e36bce08e535b21b2c4c986a69c4554b7e7e3d5de77e1b69fd95e4892f642a2163097bf886d9042fde277786ef4e01cdb9b6f8eefbbb2d23f33d4ad7a1481477aa96f37f49986303851d84452bac805c81e51301b87ce2dde1eb613b8d0aa93a12520c1221b6613f13204bbfb691ba1a604d9e0b6561ec387aa56aee496a8ff69d68f99c116d0951b94a64b502f8f788446cf5af6e31f01e66a2bd1c0bd678cbfce376a970cc6367e968dec4f409c3d4ccc6c2d5b5302c1eab589f283de2c8c7d324cd720dc241d995f593b13f3d59c7adefa08ac7e488c83c4d8dc6c828df77fcf1abe24a5cc393871a64fa8f33039b7f4e19dec556640ec840a3837c5ab6e4d5ad082a982abb70779ea1771d4a516900211b9d83a5cc80a5a2178cb3f2c9de18a016b4c0b742825106f106f25c0d7b89eac9ae12ac1ee9f2e840fb06f37993fb0268729320d3d5757de9ff00951371f8355c130ab29806c098f7c75ed1c09738071efbb1b1b273bb52c9905a5a3cfcc6f94f1ef9502dd189ea2b994a0d7a88136a7b53935574bfe05d5c2e23e0147c965333e19f5c5bf0603758a7ee291f9609ab62fe9f237ebc6ec0a51c0d253848743b9df59eac16257d2699b5d7a27e0ee5b3e014d7e267a84acf5c537300d36a3552ab37b287228c6a7d0e7981eb75b7cb7ddd4a9302f26d71555e2c64de77882f81bad682320d8076e8b82092e2053942c02cb1a4501e3823c8a3174e1a5380971252e360e3a6156b9827a4becdc387cc5b25b395311f81da8b04801847f5e747904e17b27bce3df0a56f5dff8729a2a0bf73f5e62e6d21aa0388ed2c42838e217fd4734f87af40afb6e3aab973aa8e3be77e9d9a206b402df91442adcdcfd62d0de05a539796ade5f3de4bbee0aca852a83bf44b35616bd439a582fda8874f0641f133e99dfcffc0f3067fe9acb60d9ae6c369c1aaabafafbc8ac40794b92f7cef7d7e2df545f8e0dfdf6305372b9e1a3c8b4a19162ae2c5fae741e69ef4575fbcc382e969c9890e030b095d1ef5ed49b295e34d3ff960ee6ddf6b3481c11fee25b4e30f64b9d560d96814708cd4f97614aaa657db01bc9343e9bfc9b06c57dfc8d22a3ddef8c51660f244f8d24e741447240dbc455189f7b17208d7e02978f7a9c238e3100d86ac1ca26d108f0988f4a1d7e99f85d4439e1b4bec97718143d1143859b1db37deb131e24650db31e784d0dcb8948b89bfc76468a2a7841f2fa2f7db1412265256b71cc66fb95fba3f4fcc43eeaa13c563ccdc80d4e196a0be566ff2c3bdc3a6660d03499dea6a260fe9e5ca800725f8b4267c7948d707491a431bffa22a1713ab43006cc892cda8969aa780fee48d9bd8badee3b31e924a6dd5661a0a156c52a7b30dcfea2ac99b25110c1ba04d5b9cdc833d73c373438fb5f031e850df49c713750357f9aa474edf1b92fb7a75c3ea68ab8f2220bce09814cb1fcb84f55ed29c64b140cf45b09863a1b834fbb3d97e942ce39a4953a8c96ada48531aa1f2e269cff29f9211b06526888fde9a7f2f45f1b41b8514ce884028ec5c7a9c4ac40f929f344135826b5275db7cc85fe92a96f5ce6b00844bc0596b2eb14621a8a8cedff1c725ebd324f44bd88ce552c57331705d5a857728a989a49ba623c27334efe171e93b44ccdfc39b9c4fe5d7ef0426c99e1b3ee46267b03344941779d8f01c9f3be06bebfed63b51b5746224c40a2957042a0d3dcbaa958ca22969f185b6bc12a998066de861575945632eda213b82af87458c9ca6822f3513d8290e8200c2f29f27878ef3ca0d31389cdaae8e8ac756bdaff40b39f98d1501fe77dd7a20c5cec9f4a3cdc29a415703ce1e393a161ed95d1b46acaa23f1f1c0acfb161735a0c01a78e8636c2846494413774e209e6e60ee3a8959a399752456f1f34d75c3a9d808534751a86be46ef3dabcc4dcf53fb2595338f2d9bc981a69f2fbcfc8cb454f45851268aa41348232c357197b5e69b34fa6a6e97e56a802551fd063a87f925e42ac829a200d10a6e5b1c1df3205defa50fca617f510e7f6c32412cfbb9120fe4f0f102b4da4566362e465b0b7140906a109d8d20482c44a18c3d8af5cf511b992f4d6266901d3f91f443793c33f216933e707e7492f66ced6f989f0fb2e10df4ee84b9ecc7228d5546f64b8f78c4ef7a5940a7344912a5046adfd7d255d188673fd47b3183972ea15b5740fc4bb672678a6d281c1f3201fe138f7864d1cb8b8cb7e247e361f4c7d7f45689c2df0352fe8a3b6369cdc12b5ddf8b363fd76188cc41b927a3ec313525a5d2e6cb187b8823a980b843df0f99daa2497ef90a1794e0755ff78894fdcc92e0640dd9b310c5da9e1401a306b23471ea0088e721d1b68121ab0536bf41da0e2d8e30ab00507e91965548e3bc7339fafafe10293ae2cdabb366a8c3c847fd87d2ae0993602da7b1e5d4a44b0983b1d63a9e2b8dd65ec41de27e5f9778297090e072ce5cb2d9c3ce18d767d6579d61a9b5709ff33569b41161258165e3321db41676ce7c56f0aa941e452f54a5b46d01337383c5eaf50fe6b6b6216b90da26c3a0802351a0e83f665c9c9ac84584880a667693ec7e092e5d19db4044eab6bcc49fc74fee09ceb7389ad167a7fe5663bad22f5a27a853a3a30535a28c596ef79f98a326a2e8c7bf16889aeaf8cdd871f7a274b834771a896e3f56c71f7a19580d9bbfb337e0567b894966a8d6b58b566a2d9a0b003ca308e5b567eb47886b5773f01d4fce55102171f1965161f4e57346bdec0ce8709883bedec3044424d266f1c87ec2adbd48bc99998456dfb3e506abafb46c1e3a61e7738a82b09939f264c5079bc684679fcc225a379a0aa52b99fb7f7cc1a29f8be022bda6e439b98abe5be8cf8ee18812adb2470f5771f0b345088e3bbfba1af0509e09dee21f6a1e9a82daf82af99f59101c04432119005724f2fa9c65a55bf3de1b6c0d2c2be80721289b129b9f0d462959cfc16619aacbf1fb4af4ac249464accc2d6e30e48cce76b9c9e26b0e3029ce26f039449b92fa2815c8a2270fc0d415013bfcea1ff9ce11cdc29bec12a3fb2347a79a6414de1dd0f7299e908e107debba782067a21c76ccdd18b9d00de6e2e9a78ab3520960f86991d8ee74aa27b45e0b094242214207eb699ad4c6af84f694d8e032cb2017f57ca7484a406aa34fc41d6908303fed658e49c3767d9dd2dee8acdd48185564f3b6396969dd79669218ae55d4dbb42eb8e8d0650f2f6c144ac7f30c0c47f2682f4b0af88983415ac43f79144b484f1e8865652edcacf0a0d5734d399751e830936e7b70c1cf2bc543d2cd05072dcaa795554b3967e21ba1d6b361aff68336515c99d538f7f9a7f65258b6836eb19a34789f8b9895f2891e4c2bbd06d242bd726b29f0eb55402066617c9d863b7cee21b8140e78d04e28b76524e1719602be5195bf5b797969ebe147622f5e23fed4d4a1fd31236d19995643e84004bf9b3c5a5c7b6b018f650b421f54dd43361455739dde241a8b670d9b9c3ac3080302c58a7d2f9eabe0f635a05d50523090867f251596f87504de8aab8eb3feef635b3d8ec46643f293722cccc74a8c56eb61c8079f00927a7e86021f8340734386d6c189e640fcde2fbdbdf3c8c2ebc3d7f05dcbb7d663749de2e51c450ec16cb4007aa5d15cbe6231fb19be1bb80547628be4bb414e80168fcf0a2795d8806c12e96b68bbbe6e1ac36fd2088807dd7471d8119a6f67a783ee5f57f1c699f548e24aafd32c4570e4460344313c34ac9ed110bcd504a091bbcc04fb0ace0e2384fa06b7658a6cf62fb24cee4eadd3b024df690f8ed425c96bdb22a420c4d5a7413940c030d942dda053a49d3ea60d2dee6d17f22070aae44eef351f0d8bdb7b37487e6a1117da806c220a9d03c08dee3d880396a3bb33dfc2c50cf7170fa0ba79a64a5e580af357a95d6c9d53e434804cc2c550140d1b5139d75b30107a46371708f07a733fd1da66a1e1474e789bbffa8d23bafdd252ff0ec48e2be16fe6a4e84b6e471eca2b7970f6f80b4459a6c3765ee77ba95d8f57e92dd3e7e9fbf330d24880e1b01ee777314669ac8fe6d2c398507eba58784a2cd69ed8ac40f59d1b3f28eb2c1c0d0a6ad73375bf8f2bb7b52f6ebe8789ba1a44971ffdb68bade521a55449763060f7282c5be03bffee1b8fda5006de98e95bbf06243491b4b6d733f7a4e3381b8533ee01c75cb104f6843fbf38391181a2fa1016f386caf91a096aa767a6a800df1dea6e0792c158dc95e395100cc2daec9755df6686851db43cf686581d2da7416c051e8bdaa1e3b4f0da6b653a9615863b4b1c6763e2145f408b5bc1a79419ea049a391a9c8ea81c24e053af6335d1921413c2dfe92dffcefef31d9cbeb02f2cd53579994daeddc5943763c2ecab1885c743995dc93f0ad723b33f146e487b55b10bd00cb6925869d5ffd16064efa2966f7a1895b63468c32c3a16d58f5caa4b4519da7778b11d31aeda503dc0855cae6b9062ce573aa324f747466c75e41303ef6e81d2adfd788fd3cc2ee156ecc46e8ed4786a501f02ba6cb5c87b424911d47c115124a6ba07f2a802f5bf0ae178a362afda50f66a5e2282c0c999579224fc2422cf030e1738a55c106a7135dac0294fbc185c782a54a2b88e8ea9f3d7a684ee62cfc9b65353eb3cdef9e9d3f4cbfe3f313fc6455f8371e90276402f4d2a5969051a93a2d80d903b0ff7ca5401d7f60f7b63cedc9fa1dab248715ac29d0c9ae32cbcc0729817b9b34cb14f71906a1a354aa0ebb85baf45836266bed8a523cc3bb75b33cd406de3481e98144af6b8b09e208d7199936f99c38a25feb6d7c9a3e4458a452a751081c6fd4bbe1b9242a9247ebef1da5a2cfdc398298c0c6488db9b6a08c73512b6958affd09ef816674aa67e623df378e86890ce6adcd8faa420b3880a53634ab7223413e8e00891c84e7897ccea84deab9db7986aab8181e9addd2ab20628ec263bf18ec64446d2fc4bba98bc004001a008beb32a9409eeb8ec3840d5e1f30d0eb1c7f72fcba860a0575f2548f94b78514b6527e7fb1ad1d9114cf3acc0882084ebc59f7f86f294896546a26ddd3739af6e54cc613803a9e4da42f4c01746229e913f0cd72d6c4b56ebf053f08ab4bdfe25a0cf7ab5e18bfaac67b488f5cfaa34ae105f863a62b5dcd70846c1ba87befa81f83635ddf924d4b6e11341fc16e233363e87dc5236491bf718b1ce7c485c97801f111dbd6df00009986c35cc63deedfca6f056fece5acb85a0e9a7adfcc05b3c9ef2a8ccf8bc3a2312e5aa0560deeab50b08667227d0d9896acfcc2d4d548d7f946b0ec2068c3ebdfd28871f824b7b09760a538135879dacd061947e6bede9375053663ef506e744ead47fc4785d318cf4e9b6b27faa0a377e64cf312a530d34af1e3cce2b63a03c80075e26448566c2a4e74a03061af7348017cb054327c7825d9a6c66bf1593881f9417df7e78afa48657d4afd27ad9737cd440cb5017c1042a44b8e41feae6df9d0776eca013fc0bb5499cfbfed56d5e4b23b677f4a28b9bfada0528d6571e9ce8f1642b4aab48bb10d0d13e0d2f1bdf91141d914378522a980f307efe97034bb044291e86ee63ab22f817b2971967b2099052615b0cae820d8dd240126ffeebaa1e5b55b82eb76123e240982a707882d2c7b421a92aa553704742a9d5e14f6360a75e823ff1dcc7287fb51c6dd3f5c1b87bf76c9546a4fa2298494807ba35b7fb5b237f23734e6730b5e20a47efbce8231a7fe7c6d308d0065c67c5de9b7a001399e81961906ad34436c1d595b5e09c0627ccae036ae8937b8a567a06d58e97cbd6930f2f1c243b8944db3c35d787c3c3c90880d4da7b2596fa480bf08b537032e0f5d58404ba56380168b2a698ba378b8242fe7c073b325660f22f7129f73f51b1d42b9c1650872ee6ff19ea8429331013576856c89d3c60f07b0ec1669ca17a806f47a28f96c7306b730df6b00503dad87b4dc5c23e2992bcc53ad73cc8b0373e9cf54731abdee0f530713dc006a18a3b9e2f419901c8955229594f01dfc3497042d983aebce495cd7c27056202b5387720f2141ac6c617fbd4a685ff1cdff19a47f8b6733534c6e7c19278588a294ec5745739ca857bb54fb878e163e7f4a8cdc352fe4c18dcf2eeb6b978bace8fa1ced6c3ec9ab6bba1f36991d65f51724f30d4028aa65f1a00908de7960ff4e0538935a865a5593422b6124428b1f84646b0c333a190dd2923a52b842ff28f3379d0dc863dc4b48954df11de097bd2808a6fcfcef26b2dfcffebdb309f553bed1e9efd64819e7f1a377b2582f9724bc0e80e313a7bd4348fdfb0ca709c5577861424edd768ab21d52f89b667b050de1fcd01a2024e87e6b443bd6a056f0f70c93dbec37a738e6edeab0b4cdec6d88e50601aeaf99460c46bb51aef499c9ab16b0d00e4595b0d64dd310cc4da2dfe94a7f9af4cfc089a219e5c654e94b8284ec219afe5e3961fa5e4e8c28f822ddb4d9d1b46520a30e8f1804981d2c1b5923ed1c9b4f6b408ac483be8256146a5be9b787a84baa666ae7abf7f4f5f0c2b3b183c2a7b2068601347e869906b5071b5fb09c6cb8e45fd482fb4cda36ffe41ed2da9603a4e65162527144e7a63eb5298363cd30f85c4575da9d48c270ac7096b17a4a33cfd37bce7c85ccebf4ea32c0170954fb45d737b310a55489bcebddfcd29047e10c6dc126a3c97711d8edc6f6f0ef7816305a30233e4a5083cfba5de6d28e9da73894091c348cd249d3b9bcab25a64275e7587153ae5e2a3a6d70d6f45cbf6e6748796896905e538716e23a45bbba37b457d1a7739468f0c9fbd651b560e79f40f0589cd537be2433c9db21a1064b0cc815a06703a8ae3b2ac3ce53c5900d70eb10f1409c89d9b83a0d4164a91470eb85fa9ee34702fdc3a657b6fc2dcd5b6582486e89eb43f67b0c413971d1c9c60cd032f2bd824bf7a4469d165e4010d5395c119227cb6d8a12072bb346c8c4b0206b11357e3bd48ac5253274b3bd9ec0d80e65c25e9be33112539ee5d7e7be95e4c664730d0c67f9b91d7575ccb05145469ca3c70f399e9888d22bd67dca2ac644bd8b90966ea7abd4538109554729364a9fbd8891cd9863a74addddadc0da3bef9a477f7e4e43b65a8d8b8ce3d5a10fe5ca5ea17ed8882829641e00da17a486ad970dfa557fc901e236f1064fa39867cd90c288dbe7287b555280b56e37f82b20cda36e5842b68dac54ac76a0b619fff2ea20e85cc9da30d9cf93f8ff24ba412c051ce62fa202d11618bdaaa267a442373e16f123dda8363a9c35cfa52a1547ce2e3cdc1ea13dce5f669cfbcb00f96d843d8195f6c3f16df76b9d4228f8497f1a05e4086fb9aa82cfac2b186b7c612097651a48160b7a3acdcfccca7edbc115c609daca31cbf36b1926e950dc7e1aecdc7a83684023901399fef7e1b58f8b76c0e9696a07a94e71726aa1f3769421024a999451bc5e1245c72725dd0aa6bc17be3117ed290f928c9ba58a56ec5b44cf325c40144077d34875623ce91b9239f3daade2548ea55f7c48c11f4790215d58252c2c38d9606d370705c43202a5252d54aa855bb0df6449407c0b3eaeebbb851fad1a8ae7d16b661aa49363844a6f0705102101126257534999909ef2d536d30251d1a64ae3b197ae954df5b3867670eeaebb7c3bb2b9c455df6e153c0a917ea0e201a8d80ee0c36f3fb85f67ad57500486eeccdf2632781330529bf0dd3f9c61a41b2b1e9df4a845a4ac80e696ed898b070bff9611605852b49e87379680145964225dca726ab1b34b4fbc6b5bc8c1f8a165eb279e7bddfc46d2e2ff49acc5678235c3ebec8c6b05e7f727f5cc4ebf20489963310ea1d7bc29bde2da890e427cf33e8c2fba1cf5acf4759d5594e1c8c4813c46089cee20ce6acb6dae6a8a377eb701053addc54c8ff20a0c69ebd44f23924fd39343452e5bd44d50e7ad39e7c8c46ff860858ed5d320c39bb22eda3187279a169fa015cd4bdb182a7350028bdcb1371080d04f136980f816601a8e51ff0339236b96b7e7e5d4e3275ac4d268e27a50eca13dc1f3a36f8ac1b2dff34c26b1994f41f0ae384e6c674a3665f033fc98b57d15263fd95d642a1a34b68e4872ecb1f4160a04c33521c9ec17067583b283b26cca109e41e6d19b46761de3998387edda15e79549d456b438d1fdc6463addcdbf73dd4599748f633efbd235fbf83b87d3ab5dcf1c970ea732188cc3c2dd228d90ec09a46a7131fdf7066c7e4b9144a787a527ac96f21535f03bfc74d26a972ce9f77c363a540e3a95962a3411b46be44180cb4f0b7f1aab02b68806d99defadf56d5956be691d01830b917ec90c7230992c60fdc36893273db41d1cbb8d326f4dca59526d203e58ddb10f3ba27d490fe83f7a88fb4fefe3c97900c899f2d4129220e494ceb7678f0533f1c3e1abd11bfc5191dd294c0e1dee627362c1fb8e18ba6867673f6884dea2f8257235f8e75fb8e7af38ee5aa0181bd2260abc16ef6c5522a44ff59f31f13e60a078fd2fbd89f9eaf2d12ad5de76b0548cae160a3a5a77a377e45ea1b8b9c42253c3c135e402c53846a55640a0036a7c7ba8e8d1470a079931c54dc40a6a8a0e76b1d7ba6ac55588fcca0b46a173c152d60970aa4e34f1f6d39952600e3877909e1ef0de00c36fcb4ea3eab97a7beccbcec4244df5755d2ea5caa8bf06673893daf739b04fb79d29f9a43c99270998263f902fbd0ebe9649289d07a785fc74611e63a293a742ce3c3aba1ec263b20b3603be79276cce8d355b48c65ef2fcdfff22525fc6509f7c31b3d1c18bc1af2bf79ba43d349a1b3a03a9f11c2090db0059eabdef694aa930d4ff83f875b26bf1cbff017a06e2581babc025a1bff4f8304b64ca83589623d190443f2b0b8b5b5c6d8d62b87d97f209bf30c97b08b036584f2238e6c08f83777bb471e4bc4de9c951fc267ee0af602ea7a22e5b273ef30a869a6b1667d20389c7307b54f2422c1ae03e9409cb6440806c276d214cacadfb7d29561b42a64a127c0ff98e921e65d5174bdf109f963c1ce8e9831286f7512dd16b6c5acbe07c17815911234271fb7d35dc8f3893330a737eb58edb7aceadaf4c7af5e27bde0adfcb600c5a8a9dc812ad16603d182f527dd907adf402d3102d675f352daba2e41eea5a562a979d5945706af542d6a4a039ec514d4bdb0d88523380cc179f18270be8912ebcc539011c8e0a0d83a4a666350eaa72e6a66b54a283856ada326bbb4d5cc9e42ca947fbbb8d9e05076cf7ee24c3e174398aab151c75fcec0239b8c63e8ccfbc9984b82e9fec8a72e9e8b29299a336e1fae8f8c1790bbc82f63cb2ca049c1459c46159d1e0ec5a9d9111990009fcf41f0442db081e1a4d7bf0005ce66a8fb79ea1829e6bbc32ebdd76517a4338c7d2a8618c7063d1253aedbb4e4f2702ab72c9d695799a49aced9f12c3dfde73197ad3067db5113a7260a4732b86920cb354d7e29c3d4a84a9f7ca18d4081408c662455d6002b9d9fd6cb3f4cba97c23e3659afc9fdc72d106404b1a7a12800ae37faf0dcd496e428f01395d2a3dfd9458f2fb54bb31bd358291f3a45a65f269143797bd6bd3075fbab36155804aa8bda0b530d75657caeac865ac81944a135c2073d3520b3357f302611777add44eeb200b64fda3c11fc9c7e44aae6fd4b7acbc0c4b51bc33172a74fdadca05ff3f33075f0d6a1075947431f81ac02614fb99a996968f46e4f95ce3a638275f8417e15970d514d6072ac13deb51ee3c031d721f7919f96ceb7bb2c9cc081a493e088294887aee9fe198658d59fd939204550eb52e53cd473762f86dc5f16b78aabe45bc6f8b7e943c6687fb17a99f88464152ac4b90a1cc707805f1514d64c8b2cf4ea8f5d41d9f2af14dadf968fe3c9ff6b65abfa9e49db703f0bb2bf792c0143d07fe96a2fc715bf4df36a69d6a8fcd934f8f177eb0a74a042928255223635c5cb342aad3a85cbd52e2f554e14f3dda88b8890614259f00a5b92571002d75f342de84f1fee41059a3c519ac52e726f68840c953cf774d64949913b2806cea39220fc0a4d18b1b344784b1075bd679db165d5f92a2d3539a057cd5a227e9f88347d2770b39ea6d1cfa09d64535bda54c83a8f0850dd817eb405f4585a19959c9c8a0232164ae801a1fb73d637c95dff0b6e4b23bc9c72db88748860a9a641520fd3903ba272b914b7b58d9aa7a73447d25c868de560a43037b01c611118320d115744e7c928d75114c6ea66c5dc9f6ffe00954992b5da3302fb94951e4ddb85c9e33254df4e3882fdeeb36f5b6da2028fa08c5d21ad4b42a33762cb5b6f9c5d7dc9e88e333daec8ebfd87de14e69fba1bad88d6154c196ecdebf35751946539740859b9d3e7142406612c6260ffbfb65a739aad5ff0542166e32cc2998253508f6109b7880be6acd1893c9fc3226568007d386ef8a4ff5a35f168a98619cf124af4c779b675d72e237e76aad68207d4bf8fec326b8a2cf539b519a132f3de6a8710bfb2fb092ce8a312e9e2e9685eb616fe1ad3ac2d54089b46d921bf05a6e83de629878b5008008b15da743cfb1dd8cbe661fcdfb7b57d14bad81d81fcdfda21d3f769b905b50e2f9f5af92eb3d0d17d0e51bc5a1dbca3fe105d39ab3205305c01b7f1f187a43257e4615168c86c0cbb8773f0cc1163f167f599e376f48a5ff35d6eda90ef26b031aa9944f183f541a30ba764c2dd3f9ea2558c24d10f636405736bc5fe854214e6ff5e3f7b172de129d59f3fb9fc033ccdb0a9e09266419cf5cc5f7d94920dbd4c45c37d4c3c4dc3aae9b02e1159857db6105e80dea6a2244884f644995b917089f945f487057fc59032f0ef70b72bd1b8840d7c78b74c7ab495ac9ff72a2b2e9424de5566ee6d59a9e602a67c045dcf8e3e5761d334e08e1217c197cc8dac247d32d460ca32d3d7f3164aa4b5ed47fdd063f4a519676a54c611ca02b12b0a8ab0b125b905303737263801b0ee0bbc9468115cf8fc51c971bbbd50c21b182c5982ab5fc3bffef4f4c4a7c3b724554a729657bc626cf1dde480538000df6efdc9108116aee474006a45a4458f73c6200806af862d5fe14ba693105454ef845a50840383a60959f10c237d0842eae005bc79ca3f70ef2813301cd4fc2eb87503787848f64ec22c426070462c6a2d6804b9f5a957f3d4bd2ee4e9f292156cac338457bd96afe61ce60de54c672cfaa7bae4d0d337e130381588f59e91383211d37902788c40e3d2978b0e42e4abdafa9afeb83535f17c989d89cc40b8788a5ccf76b2d09590ed0e2600dae7cd764ac76d17cd8b30d9484b26629a6c80bfbbfd225e72c80f83010be95e43bf640cb846feaf99d5a8db810c2586c4266a2c3bf7b17d968e33279372ff5d2594984572f37687d300b4c881c4f0078aeab7f64335537c6c8baf59148cb88f62388f7515c1d3e59e5c5c6e494492d0e8a4561cfce07c45a89cfb8d8ed820749099d4d72db886830c940ce1c6700e1273df02d6ace9cc51b599935d34b4f250dc70c7d468db4cc8b15db9853e21cb541f7f9307533d040f7c6cc666c1fda7cadcb7094eb3ef25a9b9d3c7bb12bd825f40dfa3d8dc60eb1544c9e6adac4fdb731887d303929a48cf378659da6ed86b65688e4f358c5fdf6d35de6cf09bc430c6661412364576f7c0366c8b03789da8d7275c707d1479606f38c59c3c409e5e365f666d9662dc36a617c175a9a51c9e6e23cb3f225baa1c1d561e9050000ae315a46ba213d1c71d5122536baf484d4b2100eb10520f9f60c8090b1ed0d84bd9fcf2763c1a2bfde2697e0f064cf53d465e1c244060793f764411c2b20163564bccfc7dc72de154b8fc4b7a446076110ee87cdfb7eb3f1e71f98c15fec211818d7f46c4cc6edb35c188c635594a77836554a2a8af7dd24bc4e852ea013313b37b6df84d5c5c55efd0bef985b6aacbbb6959e8bbec83f59fa00083dc91f413d2042d5cb0472c78074df5677763afac124bbf1ec1aa4b2dd3e6db20444cdd9716d87a0417d2d9d6a178c83e4dcb6e2f9cbf0a5444c94f3eebbc0085c9222afa501a55b8de0fbf98d64c5138dbf9fc8bf9229f5438de80fe4f00eb669d8ff1aaa4b564a3c697a92f4d433474d2dd3bb86286c050edc8b4e1b2e91f7cb1e5f48614ca3796d38ad18dcb1273372b37be5f6085fe5a9eeb0938a6d898cadd467f5183dd2fd8d60b8a77827df3d50a2c42d9172687d0f40c84bc4ad92daae39121139b494ab24b08be4b9025f2d41bb19bd5d82c22badb4d5ef5afe3ea7cd926bc5afcb88dc46a5c15333e5b9a1c508f147f63f2cfee4c9b44cc69d05f9de1d1e63dc52c3ce7a556ba37507e9cdfedb42c0376baff64d54b086e640cea88033b7b8b6e9c6eba80c85739006aec9452c58755f5f6a8e8edca230230e76d23db7bbad1cd232ea23237580d38ed274751fa652c238e3877d19aa38499271fb94896d1c63a2e9466f48cdabb293457f12fc242de7ac71d7c9c8ddeaa5e36bc1ddebca89e2b503dc2344a4ff6d924114ae4ec3c886db3a9a662001fedce0be14b2cfe83facb3738b86a011cda1dd2bd94251fb1e0767716b051233c7ee8d4cca9007ab31383c0c1a24c99ecfa3b4275c7cbb7461eaf8f3c536053c583476e5abdc70a84a6fef4a83e2de7b8ad693d953220251df5474e3e9bb35dfd1257c1a22199c72c6bcca744e28cb8a156e96e80b95fdcff24d4a08ee6743ad40c894ed2cfc8576cbadd5f338c96a0fc4a3fc5bc92925fd8cf46611d33b1dad730692062f4baf310ca4c5f810ebb2f6ba28a6faa34268b4b2c8f30f4893a4ff111ed71b235440ae83719431ff70709741d806c497cea6442468dbf47997f1ee625e4a3ed48c3ae58982f1c5999138e0e027ec09675eed326b843b96e410f25e9b6926fb33afe0c0cd4edbd6d5843bbe32e7b0c4cd692346e24f361b77ff24edde3f41c8c1f9b0f703c03cb5a4ecbaca7a02ca109de66d7af0f939d2a7381c550973d37c0c17fcf2bda92c55c49d7f586e56cb0a3793e89ef10dae25cbd2657078c9bd88f4a585b97125299f7311ed820fa0ffc59149e9ff4ae41e7f462a941b86916cca96b4926b76ad2f049d77948121d6044e03a899d8b0c0aa42204b4bad082ce969d7b63e46e02e9b875d2c59cb94a998902b0180b80c91102a14db90737865548358a8daa5f5050bde3f37a8b5453797506c24c672386a07e16291ac728b1ddc8e5a6b6c62978970f9ae8c3cac2b16d2ec432a6448368c75e46c33455d797f6a20af44822976932968e20d195a04340b5da1b1a3e46c1eada9bbcb2700dacfa404ceca4313218942ae674245d0ee5680d3d0d3e4d3006ef9e0abbf99b3beb9d79f8e79c795b47fd4b776b923c7a27433ec4f7ce5671bd5ad447ca7f5caf55516117a0accb96885e705181ad89af1f07e03dbeb5133ce5d4af9309854bee92688f319fd288049f391bf2eeb11bce2fae2c2c4856fc88258e4c0897aa339203388af39e1fbd764432ec7a127ddeac4583a4c404280bf6a719fa532d2f9389cd9f08ecd26bfda35165f598b2cf3c16f5574cc785c01705d64e4bd344d83d075a56444ef956a855b501f115b59e730d52900e60f3e6f2ca3e36901a7bf231326e7858d4df4525ad61a6eff3eb98de39fbb07c3d1dc96e338b2ab0236df3b38f326e9364d1f3f3a1e27c1fb0919695b280bc1cbda38de324a16d74d6874c0476ce37afb00ed45500460b017cb7ce44ed87ee595420ab238e61f79150d805a132dfacf4ed4b1b132fc97f4b1cd34367d1f9c3cc70e483b6f6afece446a2338394aece4e8ceed8808be06e5aff5849c50932ed4871250d7fdfb0ec459a52eccd7c489648eb3f85ee9f563a3724359b7d7bc1d81195c9318c9127f0c7ab7dad161873140b5cab5b55f15bebd9e14dcf793f5fa9b2c37015b7742a9a65f457e8f73f705c6c9a2e9ed259289907a2c46913d2a6ffbb14794fb511ca661424a4894a3054ff75490c315b8835715a68d99ce1216d62d0dc78f0bebca81c317ce9921b8ca0592fe417c6679c582d5878f198996ebc0cff92fae90378a214950b07ad296f13e27813c7a55f67a69f9bc3d171ead814886db2e122d94b7f159703a2ef9442763aefff440ec8c1afac3e0c512bf2204bd985e0b94a4d590cc9692723ea2a699eb68c8400f8636809743016a457611d87e4198655564f7f32499bbb46f2eea15349d9fd4da0709b0c143aa3d4ea4b8339713a981987109de3562ba4aad9e4df6a1775b317e275cb565dc61a406c483229c3fafae35a5c2acc3cfce1dbce6d5418f599f010d9b6378f32cc0ff771774fdbecb407d91f1d7c52b14ec21ca558bdda4254d8e27c718c929b7e553efd3f2b998f3d377aef65ba29acb7cbccd1e9a56b880470fd3860b7f1b677255fb781a393721557e5ac1b8430770b265da7dcdc5ab6319578ed6afba028344e00e073a77c2010db1c520fb768faef79364a6947e4a8979786a6066516a8432d4819ba31e4b5a3b89816ddae52b4373cb415e9af76a74445fbcc10a131ab112dcd6a1b3326a35722132639851d9d17b2500535b6f271633831cfc4d0dd5c5393abfb5625faf2a4742d2e06e6639be7db1ae5d6e89c89de01fd3a186759ecc315ed120e066c161eda53906227af25e726789768aa7b00d542ff52d19763ec611d4e8be563e5ea74465b8320d339c26fed3517333722e4fb63cff268d5375e57833add30a29b7c141feee464c906d6f1b85157335032d20879ad3d8a7aa931a2b365cad7ff1e972afadf9b64c7629700cc76ccd48a3682ba1ba3bb8f4abc2f1a6e07d265d4c1f7f5ff7722642cffb2f0eab62375664c4943fe6df63b88464c4f409005767fe92f19391f2546d224930eb7a3ee17465922a257d931ec8e04d62085c0f6305b87198a34ea5575cac0a5bb910bcaa520620696137d829d5f7253bbabff6b4028c8ad22f6d1bc1a1fbdb3d7709915a4e7e83e6cef68db8968709b44ded9a4d23bcba90a2fdd2266adfaab9b7d49dd1a50142f46f276ed91da58e00c5be6706117bba4800136dc98ba77aaa340b9f07ac35053608aa85681e8213719c4fb7f4419fef1f2ea28f3a24e8a9aa9f70813ff18062515e79721d4f31148b641ea0d0a5cda4ca51d24d951ccfa2b1ae5e78861d4b054d42e9ad35619f4f60a86b30edb3cd61a38466252430a04915eb6380c1e42a3069ec7f9a13b09dec4a2e855696392758ba299045788ad166133d613f30986f645c994afb8765884067bcc39482ddb4c92642095a8280b2ecc1669006aa290e245510dac940261bc67cf453a26679a565310170b64eab896a22f8d7f9f45a63c9a8b29aebef3d96bace4af06cbaf5adb9e92b9a22eebd7cc0e95a2a112fd90220d37958afa8ecfd406be66436b2522fd1aac143a57bd06a29b48ca00691cd47e9e30131300a99aa7ae0915442fe9db124ccdf3f23a192b80160c0a38189cf59b1db31224f93bdd23d107188e92c7d3cc0b07dc1b0a22b7cbfbdf1b846c0519ca1048e52a7fc894b05a0ca4230831c7e5db8905f6c5fd0d6fbd82e3ba76c12f40991cf89f1324ac12b8db533d1022be133f8578a0b4f9776e88c64287667a87f85d90318fe7b108349dddb661b4fbd96316a41c16c4b25771371523e4d9bdcb6f6d3fca184b0acf302c38c89d57c900244d1c7138509329a60c1c1e76ed8270c167d6e4d6ab52ed1bf8481f5193508885d21134b6586d1f44f167fe29d7eb87f9b7b928f546bc958bb4e17b9869c09f9c1020f4cd869689d18bc975bf4b664c168d65f15084bc430eaeaca82fdbfce98b3d5cc231b0bb3d4ba08ffe91ae48f18c282db4bfa6dc2b0c14f9a2fab0f866623fe7884336cdf30b0f6fbfa77845714dbe9b69f9c4e348d4b268f093563ac055b45e7d6d5790090c22999ad6e5ad4f5692ff30affe6f1cfc3d2aecaa8a66abe41fa0af4e34391cf7e84d6bfac193f77762f9ff61e579af2929fc543259ddcb1900f10ab4ccc308bd7c7e3647f9eb770bcb62a7e4d8ea96de074231fd717c8c4635277192912c0555aba2c7758ab5c94f1771e6b345d35113d3bb55e16669beec437267e26fe8c46bf24762db5987c8cdb4007382daf8dba42b35c4c4956415338bc9a7d066614498b27a054782f2b1127f32edc83309f83450ecd360b9841401b653f874061ef76bded853c4a701849d6f708df25e729a6847291466f4c031eeed132016dba59b866bd91de6cef41d5bcc9316fd56c3b06057b138269bedd291308035f9b2c43a5dbe994713a7b1a8482c3355aa9e6769ddb4dc93169a978da12c5e186efaca8562f6923972ddf1a387797fd4ada362516ea122e10af4c57dda9f2224a0ab71c96983524b75fcef7b4e5cceb274a4295080663dd184999675f2f49550799fb73991b8fde00985113ba861d1c45e090379462d8beafb8d23c9f0de1a1c82fc3da1532521ea8f427b6e85bf707887eb5f7b1f357d3c805d54a6139a7a0a831fbf5322a0e3926a963aade1394b0488300afff5b2262d0a34a660a3cc804c42ffb869dd513bc6ff7975b973113884891112446fd04f96812a5eebfe44036620a32a2fc08b84cf3123af3a776b274f548b37fc4428058a3126c5877a59fe40a93b50547aea635b5a06a5acb9f5c5e792720b55fe88c49e0cb0c7800170affe9de5cccd3f821f1836d381e499dddd09b38071f4d92df7f7c7e94e4bf6d0cac34e9b94c8910e945811640da7fb7b30a40e65caabd612e48129d32d07ce0d1422b577226c79781dbe8adaefde1739386f563971524d7ed3cbb94ae21b2cc2acedec8a49f32c8b668e2292366ce73983a72b2ca84e000608876f0f53f3be12f5b0d76f977f53aef742d3f563babb61fccb53d062f1ac827faeafa9d8e5d319bc0bd9a21f9b93b0ec24e49d66d2cc1f275aa512e862211388dff81e797fadf13732bb48b70c0ad88e7558f4d4ba276d1bfdf6824942c7d7fd0991284fc139034d8a6403b624009d8d3bc3b35f7332060072ab82e80cb018293db921a3e469f8962d0c3390918e76d37330469dcaa84de4699fa1b205fed3400d3890e1507ac1ed1f143ba89fd5a60a48aa837a83ede4860d42ca61762f6503a8a69210e2575068b2125cfa79bc74ca4f266ffae6f5bdf302d5552e40f53f4fc2e79ffeccbd49726fc03e8093cc5634cf8fe1da2820ab7c85914ffcb5aaf7d900449956e892901dbfcbefa3a710f19024759dd73b0bc395cf67df5e6c4735db361d5723b054d8bf8f1ebbf6ef06c97b32e993056bf28ebbb13a42839c819991db0343acd89429fc04668ff773532dad6cdb101230af927802e197134047e3db8628501ff39faddadc97d6ebb5ad49cdbd160b74d9d37ee133ae016a43156b6f83a088b7e4a57d5aeb103f69ff3ad7240981628b019ba4badab32fd749d22672231221d7ed0968c90d969ddd01d5f21699dfe2e8bd7365b85ce38fd0ca618b61cbacd791a8ce97393e6121c9f7005be5c313346250bcbaac5274011faf9c20b68521c2f184c13fdbc025b36900911053b9d33c88f0aeac17efe988256f97c12190c0d60e94910900f80340702bfa5847986d21ea0cdac89c78f855004727681a776f68ee36e04aaecadde8439bfdd9133e762c6352763d40871bbcf26196c082ea8355b65ae42155d2d7d7ad0b056c2dd98dc9d5da6c66e42a292cb9429ff3aa14f2541e3bd6535751169b04b09af06556d08b67ef2fb6f4087f45925f6f4df021db67eab0441c8d71e884546c954480a92e87db1c79ac7e40ba29ad5a3f6a579ce0be2cab8e2b01b3d993b00b207ded8d64698e8513d11a7bf80b590eb67eea72b691559387a9315316327a41e2cb223638b347be69f9a5b3b2cb86cc6a88185e7edf2f03f81ff5874dec15d58309b2a3914616f8d43cf8a56dfc778dacdeff8c545f30d7f3fc1edc0488e032458a0487697f38ff196dc02fcdb2b3c63455890b31727057ca826b1e79d9676e47e6a2173a9f78f442e922cfb2b376c63dec1951cc518ac2bde869373fe49549aa73d9ec02b9c89e01fae8da2d2939562b9866cd55126e9d524c8897057310ba70e7411911c7b4defc24b3bb4f270598f06fd87a0c0c51836b68bbde1ba11623656894b5cea539d2f1261c57a1321a4115c151ccd56f32edf1353a9a9ab08e7bca169a8e80037c789cb93cbf6ced0c18d3b2dc63c6215031b69eb908de8499c9915b7a349c8527efef2336bc9bd821b148452945a9524394c6d96b8b931265b7a2d6d93e55836b0e206ae8f732b27276a0d3a9877063ab30c2eaf046a49be59b6a09da36512dd79483cdb9e6dd64e2a1b56dd801c7e14974bbe471d29d77cc0c22fa9080ed00ae30c2b20d2da8491132cbc61601cac7fa934a0acb23ddd95b19dbe3158dc9afe570f139130b8fcd69e0336580d07256ec9838ddb94a4f93dccb0e6e535485c8fc70c39073452e5a6cf39d49788c255f175e7c487a711c81503e30834fb16721a79892bf97497f246b57d34ad5b1d2212275d9e36a9ee4fcd38129094392d3f53bd49196dd59a2abddeab4849625837d0b3a31229a19b210f1ed6d6afb5309712490eb0aab7a92f83b51cb1fc2546be43f6fb408f1a22dca3ad12c4aa81dff46cb83cf9a5815d6929550607cc3a5be8af3f3cae880b933e019c2064de90eab21e27e2ce7b63655f55b334648d59be91e4b1ccfe984330f1ef75e1b76d50486c87626cf23f99ec80fc2cbee81dcd0c24ec57fb9d080944a86e8a543926acc99ca2106608faa1843e1f098ab90ed78614b44d25f7de8b14b9acf1d710c5811d182f3aa43707a9d1d526b5909fb15d6246d003f15c54849f78a8b3d3ab0a9275e5de6ad1aaae5f4a648679c3dcc279a60220a5348d0abdaa742dd3ad53aab2fa2c1c72a46c9434474b9c7101e84106c5d714ff140118d83fdba0ee99fcccc60c1ae7d0514343bcebe14e7a6652a65fd26516e20c95dafe049743b0212b8a4de45665d9a0ca7d380719d634ce31e1cf23e6ecee6aeae6feb736732f2af0c2f5f5cf127ddbe09a7c42183bec40c64e205c04c472ba4e8ff2fe42d161f3c00ba4af7f7903ce3a79f0410c268733a15754cf0c976ce4ef60a97eb6417429f33e0a5a91f0d9334d322ae58f7140ee2b8afbc7c5fd7012f92b2666171c01fd05ab671885f69d5a19a0bab331f469e5e83023f1f482bdec9f4eba7be5d02782ec295c32786e5ce9e6ca0a9cd42e41b8c2d0f2afddf9091f5c7ba24744bd535add2ae5212a2cd4f6abe7885e3af597696a9e147ab7c3dad76d99c5c69fbcd0c0aaa77f55600c51cab93c486a7aff24d94938d5ae9678b1e71da6826b73b8c9061af8419cf3334f37df4a970e835f7b1b293040ed43be33bf367bd4bbf91d3912f11ebd8cef4919cda41961253f974bd3b06c4fd7e87df6edca1b0787ffc539d53c37eeaad877a3c89e9b443f417a0f97d327d23cc8167b833ee12ac338c9b8ede466f5c89d3926c5caad9e5ea56ba8b7ac3058b242138be3a7e6800380097c09598a3eb33555a7b7b74071ccd10230503f9c66c0c0272f948e4897565ef2aeeed32a355a28c2b0266c0206e97c1000fcef0a3a00ca098c08acb5681669ad2c55d62fe2945671f4bf81b2984a85198700118d426008fc92309849e9bf3770c34a59b82d25d6b43b8f37944a2862219adb21476ff6999de715f93f8e864e20acccfd5ca85260d1a896f1dc320fcec3049c98b422d5c3457391b9f38bf9f621ea38aecffd5c9ad1a8a3ab2d4fd550a91e1e6288af8d8f133ea313a086852f8e1ecfe79cadfa2a90e12e7eeffee4576e0de03d0d6a3b4cb4e36330553d153ecb3b21524a0775a4d46ffbbe433f83b53875752d918992c4c9a6276ce2bfbc0078299acdabf5d04207dfc03c90c3fb7210ee876b440107d16822864791e6f648240b47303e59f216bcdb6c7d85887e9f104c881ac6f0de008f1b1e7ea6d81d8bb1980f9ff0264cefe7b8b22fa4384c2cc1809ba124ee28f78c5466118fe3dbe386985514460989b019e69a9c643199387c26b68ea708574e1570caa21a408187fb657af1e9c9c9bf89b4b1fd9b86323f20713421dc6b959dc21178c2d4ac8feeba2a258b95c9f9af29d6927a85473fc6c85be2d129f159cf9a9d443fc9227da4b1d27a69edc2694d0cf1549ff6540573a0c4ad79128a93d2fa218e3af5130b2c40b3f6717ab956f8a35a3fb9521e1db2071b6dec8b206b3abdccae752415103134e92f8d7726c931ebab31ddaf9f3b2df966ada3b6f92e0b1a9e42dcdbdc99f76e153cff51b482c7fe4f743a1adedb5daebac0dbdcbf5c6db689eac15241b2ec3879c092468934c6c82d99b35076f16b85e8b91760180c91c516b5172441b6cb0ff8b883d7c98794c3051ac98aa75adc9e31b4d9e58c7a5282da04d449a5b095b7fdc1a633613cc7d0f82edda4d044bd10294eb65c637e3deb83906224b0920bf938bcefee12e3e7c79066bad331592492f3cc62f068b4e218e43d76df2d271138937a6299c0e56f4ccab4a893c3e3b420c4450aff40c32461f361aae34228e4c42e14981f7b3deb4d967a89e7c07704741fe40f8488d11b2ece4e5d9489a17b9b1bd3819076d060340e91b8491fbf6aa33f32ee11785a87d21dc211b29c22add37d18378d956f6a806d1efa8a5fffc5e661c28b5ba977c0b2e690a981a2a00566ccf93667d82d91622e0e02fb0682b9388bfb2ee1dd7d78c5df6d8b09aa5e8346d227fa1cdd6d75024a0311472620815dd2ff9db684a2ece0d3004cfbc9a65cf81b5f3841cd8131d39b275c14475fa21743c71bcd1586544c48dedda00e52d7903c961d007e40cc505924edc6d99ba2e5ca06a9abc90e1afd144a03df5823f569efb91acb872a290e46d77a1d136204077c558a239f06007d37794b0cb26bfd98543219f862b3a9c85d347a0830307e7ac0b25ce75b657df249177a306091c4a580a273bffaf6540e90049711b8ff307550d47a5a408bb07443dff4e58cf6ec044874e12f402f10fa789f1f8ee8c84cfd6386c343b2863b265aebf82c6719c54c2c0c50fcaaa7a3da19e80d82839692cbbc2d3cb5c64e2fef6bc2c763ae90badb9c39385377e59ce97aa91b7b912df659fac166343c28f73b7c0d28f44f00a0cb4fee7210084d07df5f01d5925f026a84a6775fb42c11d14c9e941b7755c3e1a5ff314877331a77cc2d9d468283c413a261672008a5c1883685f82170f20848324fd515274ab6f960ed4ba2e85746f3be8170cc8ecbe9d9ff11ad048a837e3b7571884c73108e5fe430fb0384e74319733ab57592ad37706b54615b05b0e8e10a3f7bd0d7fecade7e679dc330dbc0777d6085bdcf25527516a434d9fc2543930d9096fd87ee960246e893d4ebc1377a6be63c8bdbaaa76567bd600db94f65ea4c93e70be964b71e411b779adc0d531179986b1f8e7e8cb737c09d6668d91fb1e945c18d64b66df9dd15a79a8853bc5d4ea5f6964feb0ea05eb5c3745398e643bf08aa968c70631ebc9d70959c6d484a1bc8b11da0e0c2d2d8da4430fc4f6fd0ba4ce964032e2708c8708197cb19567bc7d4de5192be36c49e17d79134fcfa311fa2afe0545b32efa6c5ebb1166040b5950e8e5ba5e202171f214c614a6b12589ad75c2b100d7f4e8a05cdb8b5a177683a853ac2bc95d232c0151154873862103d4600dfe387fb78420cac81b8864fdd6945891d658a770122d0d7abee085ff3eec9b1d1797761de18dfb2a67b7e786fd60f2e2f831c4456c52732d6965ac2452f8f6a7b9d1c0fac75f2d8b5076ee5c5746307db42b077474350119df50a5cf138a4631ed92580dacc7559cee7ddc9997a567970be00a5a59bd438079449cd9c8cfd836e544169a48f31595cbfc5389b9da0dbb7ce4390ca8baba567ee9a7b3793c98848a48a8acecec7f62baa6d81f22b5cf8ae980f6a14f1bc7d387563d59f6c13516caa126f0cda0a247a380720df6a9ac1063b31c33c818521753502aa6ba0b2d9341f9ccf7dddf015284ea67b41995521a87d70b982939b3bf24b18010a7707031070d0075414482bdc46b122103c83b61c76efe45a2660f884bebb7b523cee100c14df189968c059e95c9f3673d5f877ebb8ce80993a5763f2b197d23c4ae9289fd69fa30d2cdb13f0def1fc959ff504dbab4c0ec5851fa3640c3e0a97b57f24b0713068b3b4492bb266ff3bbde5fe099e4dcff43fd1b1be5c81c2fdd7a4ac6504e4f9d27c77c94dc79547c8c3cb5c6bc8d220231c959f4d72392509d8b2762bd51321ba2e55b2d9230f65c1028628b7a81de3d0d41c073dfce20996f25fba3b4423259768786dc0579d7ef9b3b8ea22d3d4dc494f59541f1437e442ef8d1ac553bc17c477d3961b17c97c79998dd9eeafbcbf0c46a81216a4749da3b40025e29afb35e4f45d9fc74dfaa605eeb937abb322783bc0be40b4564e2931baa717e1a75f90093a8006ab4edc68d6d4f30fa61eefa35892a2b857c3bc22025435f320378aa87fccb8a50c80d2eea2b5ed87c434858078fac957d9d748a76dcdaa793a078cbbc4b33a22177d7ea4120cdbdcb963c15f9fda9af062543ee7547261035c50e54ae301225c3c38eddf95adc7b87809051f94c73dd0a2714f627f25539cf609877f95495dd5fba3a77fafaa280b338beb44451d640a022896b1eea6a8fc5f209c93806ee2fd6bbcc1a7c0abfe97494663d587fae9fcd2be73adfe31c5a7cc610a6ed8c4da4e37ff0bad22361e95d27d29368c4e953a1efd8abde6b46557244548e20f2c0b3c86427acd02335c5fb0ea2ee4572bbb9c7c50e186c4c8098e64f75db97022348f77018c87a1f35a96abf41aef58ad436b90b12bbf7ee049babca03c11602b7723b0359a9b53ddaa8efed4099bdb6123f30b2082a48bdaad82da06f9f665bb5cbf69a1528acda61940526f85bfc3b3003ea2fccc9047f27312e295d92dba99f13bb29d8874b4d974353839d5a55b306c5b4553c5c8de52428f25e3186b622f5c44abec1cd0def0788b44a584f49f9b8f695ec18b94cfdc9b3ffd0ca4cc9b1e6d8df0435ea35886bece713ebdca17d2e034e0c6975a06ef04b5a4bc80956f4e43e217b1b5b95de58fc816d0d14d5a2814692d799e91729b16975256a98382ecc480f284879eb8aed159e788a828a357c1f496d1cd547f96e22d3ec53d68fc184af22f887aa67d9feca19f044fd8f782e69c09d1b1cc7d5d342ed141e7b74b12c6f9551c469feff4982dfb13cc2ec771c2b4f29f192722bd036c10a4953993a8919bae8a168ede7d9fa48d403ee9d02d99a444ffb41f2f17c77fefeff597c79f2929db9ba0a381c36a192e2986227ad9952ac5c60661420634406b032620155ccea522506f0b303a8f684703da2288baa09021f1b9d4fdee8f9ae598a3be1d23efa0418e0c3ab674951d175795865b17436d199b9e33b2e39c294d443f9c4a37d93de69512b10d4e1e23ecf480666a5d3a68ba48c12d9ec97b75e18cb6b957bfe6d3bc93ccc5a486e7d3611aacfdeb9a2164377dc66883bd2003271277da440f60b5a31ab90362aa4d81ed301cadb5273380815904911a3af3266e3183e805bc331839e7297775632eb237bf6d0db97caff737a451e1512581cdd4e481a65867db86209dbcdf7f5848435acaa0461049cb46f1f0a6204ece2b4722d635b3f350269dd17024f9de4456139cace1b96a11f83469d8850ad1e2788ccee9a976a74bddb94dbf8a92df009082825874d7c0fe84d582fd3fb2436b83068734b0eea8d205e12f37df0a09bf8298a8c7e85c8b02eda79d003e5cb2a4e4f35dfb27aef8c4b501b0e1bf752a93c153da89c1012fc4e6cd49139421070aaaeda17f22adf41d178b55da7fcb4507d579c93ab6da9cec82425ee9ec7cad5039d390a5c725418bbfa37d9cc0f9243d96dff92b2ff0d4c5025055e9cbcf652822f72413595e07514e094d1f66c37c83147bfe55c407da86b7ca943463815b93308532d4f663a0ae7a19aa866a752c0082f96e6d67e787c7f170fb700a6b460ca097443f242174baf07c04a949eb5d28ae2a6f5c4e6b758172ded776975d2426c02dd06b3fe971c4cbe91c41a15ea6b0053e7a1a73aff56fcb979549841e53f4f611f5efe2a7b0ebb440ec7d7e1d67993b21b0f07fdfb2dd12e22fdbab64c42e1eec0e9590cdc960ebdc8f09bcbddfdc10b55eacacd9386a09697391d98b18c07e3c05375dffb080597f6742359a3d0cea588e9c581198ced260825222615aa82605ffdf47c75851eb4e3e572de957d4718f4dc3498b8d76b8e67af35eb19d261205373a1aab7b3c2440744f1744edf3db44b54a918b1c6fa5caace81f42c94e8fa88f2813f8178dffe65acb324c6a53fe2e591001273bccd09ce54d4c2a578f65eb2ea459050939d39f4c9d39cdb632858cd37ba1865a85cdb147619722ffb5cfe158d54c6087ff5115570df37f3f2f2b552dbfcde91aa9d55296b43b9a899ecece270127fbea1fc4c11d17453cbb93806557dd618ac475701931e92328fa2eadc29b36df1e8c5d5d6da21889e8d6e5a16349a46ba2a830a5da90f76bf48fd22f9072e1e521f51ae2188379feeb50fcff7451df4393e8022e3d85ae1b86503a58199a369797bf2e354fcaa0eba1d89bff709c83752ef11f48ae953668f16d899beef997cf7805c12ba02094442babba5275b2c59b4785d4a324167567e7900e4e60cc2b16024467392f33bdd94c0a46ead164cce708a3d919503342eae7d2ac60e5c7ac2bf36495ec16f8f43e3b01075bde5568601646e92f4ebc641ff8e09d63742fe9dbfedb090926790d46d8193381b528125085f1ed7938ac0cedf8425ff229b0ea5b411db77c2baa6865da6deabd12a341e6d81141e54522ed56eda149db5d17f31f3539fe1fb8b4adb6300962385ac5f3158042df6c51986359367c9a081085c2b41db33b47133a8e3d1c5360448771b70788ab5ec1ddc7817324761933c6f6fab7ad6fd12241957c7f402bc66d87e29e8f1901d03a09441a02dcd894832494443d23cdcf2543fc5120de1d2a3bbfc3615ac8573527c29247532c11e74d0bc70b003311c4660427df73781f22a866543f93aeb2d45e1df4fe80ee72d98a90103461cdcdd27d017821962884203f0b73e7bcf96ef7f934f9f4e439b79258db570f9ea5015d74666e28b2dfe36cf00e433aed0dc4ef4a6aa5186887384a72629e30a697875d9d0c94efea194049aed947d23105e7c5fe05e1376440878d2c55cb0047d376977e21b11599c4d4dc3df722aa3e0838e51d46c8da6d55f0b5bc25c4d780aeda40c1bb2298e12d8d19feb630ecca50aa25f304b6299035fcc244ccabccf8384c418edd09698e6c2ea083751d55ee749520f5741773f50bdc989febe1ead2923f21e0f1545b5d9c8d3ba624b48d401908ae72be37f02b20ed003a84dec2bef71977f6c979864950d04b438f4d8434d8a6a5b9859cbdd729946db8a01dbc3e46c9b509991ae693684f6ac42cbb1df1a98ef59510c244f33aabf251c4c58ee742ba427877315726912b5fea36570cc0347ec53842a7608fdb4a539caff88a061ca2560357fe6aac4e6fe19d4c781ca1ece1844bdb82b20e71394e02c976ab59dbfdc6d4cb001f3c67adc2773a29596692e0febe5ca8c5b01ed4b771a41a245ff4d7dbefbebc2fd5fcca3a44cfd3157aea2b8e5313be90768e9ebe11c05431085108d008548f11eec857d1f2e9237c48edeb8eda6a57eb389a2c717139307978031c3730f39cc56010f98ddc26ae0028da1b66f86a114dd5d9e9f4875e0afe844792db9be0644a03217a2707404b2ad0bf40a0c23b10e374e2f24bfc29ad13230a5392469a1b66644b7403e60485295dcfc0e1920cac0cd3572d65e048d00509bf6a76d900893207821c177adae42fad8a721680fbaf1b29fdfdf77083d90bc2a0dd6c75f25d5663719ab27290868b3166fa6c054f3421a47f23281f01a8cefba61ec4594fa31b227e57245efcd7db5350ac470a62152aa3ff6e6b631d99d0d2a994609ea1ff2d66549fc5316464cac5177f914c2c84eafc9c7431314f16806fa575b60a92eb52eaa3379793b712567fc59382c9761fb2e92ce7a86385bf93cdbb4e4a62cfe192197b0e6155695e9c363af63efe9d43ac286712b381a8c8f8df1332a87a74a8c16739a58be32577efec34b19c8e0c73e07381e012e5f9d363550224801a24bdc376cea30e70c5669abc78ce8b2a812f6a837161ad0964cc3a8bb216498954b7aae5d5922e174b7e938336f7450863a7adfd634525fc8e66b709d2d90e336e30a2ea6fe2491892634cbcc07918894dc0a497fa56534601be418d4a2bc486734d0cd7733decd97f2f4f0f5091717e015a51d2415a28e6e07dedd62874af289ce00f59a1ada12db45aeb62268e2854e6bcd6309ce969731af2cea0a872550fa148d9c3df26f4f53f9b84cbfea7d9d79b1f086f419443d4606f2f55af9b17907acb9f5ff061edccfe7bbebc842bc453505c7ba6051aed54edd5e94f7729f3210ae891908d3bac7510c16e3b992d070236eb69c1dbb635e6590168802b86ba5ba5e79c8766d2050069457709838913ec35a341e919046f7a6b196c1be5df58a0bc191d3a11e71d262c94766588f5032f1d395a4395639f2e62d0f5640907381b80d2487afdd56f752f134a9894da47a2ce739826e92ca0f43fc58ed2faf326db45e5102982c165f49340f78ac75c492a3c9b7c80c87244c468ce81ce7fb2197247eed621992bfa1c54618e3a1f66cdfae8e4e5c7fd5b2d4e6c9054083fa12ef2f832810210d566f39e916cacbee80874c789dab3ab950f35d3e97d2401359425a9b9fc519c05dc7bce9db1e2d01f4edda4a2eb3d325d63945a6ebe79e5ec9b86bbbc2a0aef2d9a4181b4bcd00c04042d16773ef7be4d9d55a3cb509646c8a97c2425813ad49ba1c4b825105853d484a95dda47a2c810b6d2795471ef2929149a86c5970a222fc2137306e7aa2f150c7e0d560a653869b0576384aa27aa45a58164a908209d7e1f41296611d1cb3963f122614872c5709c2e168bae6a418f776547f228fc54a48a0fa53c19b154c004cc841ce04a2f97c893a5f4e6b96309428c0e7fbad4f4bb745806e409cac87cf979c48445e26b4fe48af4e38f7fed7ea4d0a3f4abc9b936399057bd71d66b98a9d48256885eee34c4e5ddfb03b2dea203eb11f3120ddd05677378d822b45e5b5d2cd1bd73835efc061e38c870a1e3cbb5d2dde1ad0968ea515860d697f9f35d9e9419ca97ca9b00badf2b411b362de5328a7f17b3367c98d9a1866a8537feed3752b777699ecb50d5c40fcdcf8e44c32bb84024ec4557cba1738bd8d478671e149807deab4edeadb635c4470f37b514b118b44be90f8f5a5373bfaaf6aacd6e7b577a22ce152002dbf9558bdfed93b04360a8ea5f49a637c76b429078ec21d572468164ca1fd78cd32fd61807dd17e633314c14e11778599a6ab741eb6e4c6f28deb8b1b77fb26a592f8b26b6cea600276ac6c3ddcc1844007dfe0242ad589b75a2818a392162b27c6c5f7558046f401f468fc9b59d3415699d98858c9bd04a4e3b3dc9b841d9617a033e002299be19b0555f591247cecb707f20c20bdcc10b809be11750c53540e53efba2d304431f11a2c943bf70d98ce3138b2b2d75cd66f97f90f8dd8933f062f54843a4d4baceeecec49a1390b628181d360fc9375830abbdc918eacd4456843a3b863b43081a4ffd59892c1bad97c3e7f98bcf626f53f9390484acb92e1d25d71b45d7386504b1e336e7a13a6c6cf44bb83ec87f7362e638710cbadc2d0ae4c45c78c837d573e0cfab5b00760670568ed1ebe6c08d246da54003b5a910751956f223fa5ed9d4893c2be3501c84c80398cacea25ec2495a577c86b5952c54a6b58782c44f0c0e419e8146f75a3474c9c047bda855bb21944813a7e8c3204ab2202535512d0b22b732d1ccef37aef54d0dafc0dbc10d25f056ca8c793fb09d4c8dad8c185373f5c6926961466228c44c0c2edeccdd6800e1e27c390b3b56949b9d3a9bfc9167797c0ef4d9b6bbe2ccc93ccec04ec3b964027b1d23fc5c0724e40536fde436dadeb148e8efc8d84e8ec8e6d779c6ca6710e4984ed9a64c37eae9650f93af5cd88afc84a592ea977bcb19b1864a146e814e8c6a0d4e5fd9b6ccd74ec5512d9d76124e2d85ea1c5436f7b7e8bce5a0b0ad750864600647acb9d565d3167ef5b3b637c6fe458b1b61993893be4d64360363ce051580ce09d77d882038605ddab7554018ba5f4d7c51b4b571a21f7a64ac43daaa2108c7eae29e0b8682e0f906926f16c87a109f23c9f16ea862b397ae4a1e45b8a8c98bb1e0b092eb661e0e05d983f71cd8a95da496627b19ff72457074bc13b3bba69d19e9db1a018d233c692640970f7c6ee69462f61431fd70358f3b3ebc5a92e9455b824d6a2106c599e6d53c3790250a041f2e55a6f8e018f7e7ac3e3b0551ff03fa0db6fb8f62c2f90f3e425c4d9acebf9b51dd381c1ef7aeaad1e90dc54deb54e68f3749cf1203984fcd8b727cf3e640a886e843db3032cf6a7037ac2caf66cd711ab4b1e302e887f07a10bc10ecb96fe3bb205eb353370d5c5c74d76a8bddf3aa4a6c0db0c7a419f66f9cc173c85d1d42108231a492facfa7fd378f5607b240faa6ba905353e8a0b3db580a7cace0b1e669160f547f4b4bdc061e1ea51748d0a1150d16c299b25eb0f4e8b88a2b06276717f3874e6f6465cfdc6eeb06124fa6f7e925d2fa6f0375b9f8ec1912dbd842f49764771abf7979425d9163c431e9ef48056def6c27088ca6cfb6a9c267e676470322c7076caf5b65ce2d3ea8b2f612803c6012519bb082a8900052d7b0a95f135ae627e75a6ee774331783cf8a08a4f3980afbdc5d8d59d5448d38b2f4df8d7d6b26d6ec55eeb8bf0031f8a7c3118a764616190f4bee5a9ad856e156d71e768a83db2e4d790b3ad7c4cca4de2624734c2d2d7d1bd4469b4f9d36d679c325c95e4efee1968e980238eb7d5feead9d3b680591c3d9dd787a931a4f1d66be9b67e630432dbd4d98013070c2b060793df3dc85e8f444a6f51dc59604bd0bfc98fc5fd4b809dfc6301442bad30a8abd41b9abea57b75455934dc669bbb17e3d2807bab0435cfc6596be9fd1577dd5b24048b90c57fdef4c4062b999f7f5567247c531c69156ef2d7dbab69d1ab4e253dca98aa6ebba42166b72459fdcb352bcad84b81a18b004a15b1e2867b282945adc31bd7da2b0ceffc67dc6ee31c7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave"></span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算概论C</category>
        <category>例题</category>
      </categories>
      <tags>
        <tag>计算概论C(21 fall)</tag>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>必读：如何看加密文章</title>
    <url>/2021/11/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>当你点开一片文章时，如果发现长下面这样：</p>
<p><img src="/2021/11/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/image-20211111025338844.png" alt="image-20211111025338844"></p>
<p>注意，这并不是一篇没有内容的文章，只是内容被加密了。中间那个横线就是密码输入框，在此处输入密码并按回车键就可以解密查看了！（手机也是按虚拟键盘上的回车键）</p>
<p>如下：</p>
<p><img src="/2021/11/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/image-20211111025449872.png" alt="image-20211111025449872"></p>
]]></content>
      <categories>
        <category>计算概论C</category>
      </categories>
      <tags>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算概论C》常见问题汇总</title>
    <url>/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在当助教的几个学期里，发现很多同学都会问一些相似的问题，这些问题的原因和解决方法都是类似的，但是在答疑时可能就需要反复的讲很多遍，这是非常没有效率的一件事。为了解决这个问题，决定在此开一个常见问题汇总，将常见的一些问题记录下来，方便同学们查阅，减少相似问题的提问次数，提高效率。</p>
<p>同学们的常见问题大概可以分为以下四类：</p>
<ol>
<li>编程环境上的问题，包括 VS Code 的使用，电脑上的 python 环境等</li>
<li>代码的语法错误，即由于写的语法不对造成的 syntax error</li>
<li>代码的运行时错误，即在代码运行过程中因为各种各样的 error 导致的程序 crash，没有正常退出</li>
<li>代码的逻辑错误，即<strong>纯粹</strong>由于逻辑写的有问题导致的得不到一个正确的结果</li>
</ol>
<p>其中，第2类错误是应该同学们自己解决的，当你发现你的报错里面出现了<code>syntax error</code>（即语法错误）的字样时且你还不理解为什么的时候，你应该去看ppt和老师的示例，对比哪里出现了问题。</p>
<p>而第4类错误是一个纯粹的debug的过程，不太好作为<strong>常见问题</strong>来总结，之后可以找一些同学们的错误代码来写写一个debug过程的示例，也欢迎同学们投稿自己的错误代码。</p>
<p>综上，我们在这里主要总结第1类和第3类错误，其中又以第3类错误为重点，因为第1类错误往往在前两次上机课的时候就会现场解决掉，所以不作为重点。</p>
<p>关于第2类错误，我也会<strong>随缘</strong>更新点东西进去。</p>
<p>如果你觉得有什么应该在这里写一下而现在还没写的东西，也可以积极来找助教提建议，建议采纳后会在对应的条目前加一句“来自xx级x同学的提议”。</p>
<p>随缘更新中。</p>
<h1 id="0-一些基本的知识"><a href="#0-一些基本的知识" class="headerlink" title="0. 一些基本的知识"></a>0. 一些基本的知识</h1><h2 id="请务必学会查看错误提示"><a href="#请务必学会查看错误提示" class="headerlink" title="请务必学会查看错误提示"></a>请务必学会查看错误提示</h2><h3 id="一个语法错误的例子"><a href="#一个语法错误的例子" class="headerlink" title="一个语法错误的例子"></a>一个语法错误的例子</h3><p>相信不少同学都遇到过类似下面这样的报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> File &quot;...（这一长串是你的文件路径）\（这里是你的文件名）.py&quot;, line 5</span><br><span class="line">    for i in range(1,a+1)</span><br><span class="line">                        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>请注意，这个错误提示中给出了足够多的<strong>用于定位错误</strong>的信息。</p>
<p>第1行，写出了产生错误的文件和行号，有的时候你会看到报错提示中有多个<code>File ....</code>，这与调用栈有关，但是你不需要理解调用栈这个奇怪的词组是什么意思，你<strong>只需要看最后一个<code>File</code>出现的地方</strong>，这个地方一般是你自己写的代码，你看文件名就知道是不是你自己写的了（如果不是，且你看不懂，且本文档中没有写，且你自己也查不到什么资料，在群里问就完事了）。在这一行的末尾，标了一个<code>line 5</code>，意思是这个错误发生在前面这个文件的第5行，非常直观。</p>
<p>第2行，写出了产生错误的代码，就是上述文件中第5行的那一句代码。</p>
<p>第3行，是一个箭头，这个箭头你可以理解为<strong>运行到这里的时候发现了错误</strong>，一般来说实际造成错误的代码就在标记的这个地方<strong>附近</strong>（附近的意思就是可能在上面可能在下面也可能就在这里），在本例中，产生错误的位置就是标记的地方，错误原因是少了一个冒号。</p>
<p>第4行，是错误类型及简单的说明。一般来说都是<code>XxxxError:xxxxxxxx</code>的形式，冒号前面是错误名，冒号后面是关于错误的简单说明。在本例中，<code>SyntaxError</code>就说明了这个错误是一个语法错误，冒号后面的那句话就是“错误的语法”，非常好理解。<strong>如果有不认识的词，可以先查一下</strong>。</p>
<p>在理想的情况下，我会在本文中更新一些常见的<code>XxxError</code>的说明，前期内容比较少的时候大家也可以积极提建议，我会优先更新出现频率比较高的错误。</p>
<h3 id="又一个语法错误的例子"><a href="#又一个语法错误的例子" class="headerlink" title="又一个语法错误的例子"></a>又一个语法错误的例子</h3><p>请看如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">a = math.sqrt(<span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行此代码，报错提示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File &quot;xxx\text.py&quot;, line 3</span><br><span class="line">    print(&quot;test&quot;)</span><br><span class="line">    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>同样是一个语法错误，箭头位置指向了第三行的开头，但是第三行怎么看也不像有错误的样子，这时候应该怎么办？</p>
<p><strong>注意，实际错误的地方可能在箭头的前面</strong>，箭头只是代表到了这个位置时发现了错误，既然位置在第三行开头，那说明实际的错误可能在第二行结尾。仔细看第二行，你会发现少了一个括号（可以数一下），加上一个括号就OK了。</p>
<h3 id="一个运行时错误的例子"><a href="#一个运行时错误的例子" class="headerlink" title="一个运行时错误的例子"></a>一个运行时错误的例子</h3><p>下面是某位同学作业中的代码片段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        s += random.rand()</span><br><span class="line">    average = s/<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>运行这个片段，会得到如下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;...（这一长串是你的文件路径）\（这里是你的文件名）.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    s +&#x3D; random.rand()</span><br><span class="line">AttributeError: module &#39;random&#39; has no attribute &#39;rand&#39;</span><br></pre></td></tr></table></figure>

<p>可以发现，这样的错误和语法错误不太一样，例如第1行多了一个<code>Traceback</code>，顾名思义，就是你代码的历史轨迹（因为有的时候实际错误不是在你写的代码的那个地方发生的），这里可能会有若干个<code>File ....</code>，但是正如前面说的，你看最后一个就行。</p>
<p>第2行和之前看到的一样，只是最后出现了一个<code>in &lt;module&gt;</code>，这里指出了是在哪个模块中产生的错误，你大可不用管。</p>
<p>第3行写出了产生错误的那一行代码，也是一样的。然后你会发现这里没有了之前语法错误时的那个指示箭头，这是因为语法错误可以很容易的发现在哪一处出错，而运行时错误大多是你某一行的语句产生了错误，因此只写了这一行就够了。</p>
<p>第4行写出了错误类型，是<code>AttributeError</code>，后面给出了一句简短的描述。如果你不知道这是什么意思，<strong>那么你就可以先来看看这个文档（当然也可以直接上网搜）</strong></p>
<h2 id="请务必学会使用搜索引擎（以及学会查阅课件及课本）"><a href="#请务必学会使用搜索引擎（以及学会查阅课件及课本）" class="headerlink" title="请务必学会使用搜索引擎（以及学会查阅课件及课本）"></a>请务必学会使用搜索引擎（以及学会查阅课件及课本）</h2><p>举个简单的例子，请看以下代码（可能有些同学对这个代码还挺眼熟的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.random(<span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>运行以上代码，报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;xxx\text.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    print(random.random(1, 2))</span><br><span class="line">TypeError: random() takes no arguments (2 given)</span><br></pre></td></tr></table></figure>

<p>注意第4行的提示，说<code>random()</code>这个方法不接受参数（<code>argument</code>就是我们讲函数时常说的那个参数，更准确的说，指的是实参），后面的括号里说<code>(2 given)</code>意思就是你给了它两个参数，当然，你确实给了它两个参数。</p>
<p>出现这样的问题，往往说明你这个方法用错了，用错的原因<strong>大概率是老师讲了PPT及课本写了但是你忘了</strong>。这种时候请查阅PPT、课本或者先自己搜索。当然最方便的是自己搜索，搜索教程如下：</p>
<p>首先打开<a href="https://cn.bing.com/">必应搜索</a>如下：</p>
<p><img src="/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20211111112856612.png" alt="image-20211111112856612"></p>
<p>一般来说，如果你想查找某个函数或者模块的信息，可以直接输<code>python3 xxxx</code>，其中<code>xxxx</code>是你要查找的函数或者模块。在本例中，你是想知道<code>random</code>模块的<code>random()</code>方法怎么用，那么你可以搜索<code>python3 random.random()</code>，前面使用<code>python3</code>是因为可能会搜到一些<code>python 2.x</code>版本的资料，所以明确一下版本。搜索结果如下：</p>
<p><img src="/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20211111113144011.png" alt="image-20211111113144011"></p>
<p>其中第一个链接是菜鸟教程，这个网站是一个还不错的中文python教程网站（我刚开始速成python的时候就是去翻了一下这个），基本上常见方法都有讲解以及实例，简洁明了。例如第一个链接点进去如下：</p>
<p><img src="/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20211111113327191.png" alt="image-20211111113327191"></p>
<p>相信你一看就能看懂。</p>
<p>另外，可以看到搜索结果第二条有一个类似的，那里面是<code>python2</code>的教程，所以一定注意，搜索的时候显示的指明：<strong>我要搜<code>python3</code>!</strong></p>
<p><strong>请注意，推荐用搜索引擎并不是助教想偷懒，而是因为一般来说网上都会有非常详细的资料，正如这个例子中所示，有说明有实例，这比我给你说要来的详细很多，毕竟助教也不是行走的文档，我们在自己写代码的时候也时不时要去查一下某个东西怎么用。</strong></p>
<p>另外，英文好的同学更推荐直接<code>google</code>用用英文搜，例如想搜<code>turtle</code>这个库怎么用，可以直接搜<code>python turtle doc</code>。结果如下：</p>
<p><img src="/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20211111113720394.png" alt="image-20211111113720394"></p>
<p>基本马上就能搜到第一手的官方文档，图中第一个就是。有兴趣的同学可以去看看<a href="https://docs.python.org/3/library/turtle.html">这个链接</a>，里面详细介绍了<code>turtle</code>这个库里都有什么方法。</p>
<p>（我点进去看了一下发现也是有对应的中文文档的，在<a href="https://docs.python.org/zh-cn/3/library/turtle.html">这个链接</a>，可以看到讲的非常详细了）</p>
<h2 id="如果你遇到了奇怪的错误"><a href="#如果你遇到了奇怪的错误" class="headerlink" title="如果你遇到了奇怪的错误"></a>如果你遇到了奇怪的错误</h2><p>如果你运行代码，但是在<code>terminal</code>里没有看到与上述报错提示类似的输出，请先尝试重启<code>VS Code</code>，仍然不行的话请在群里提问。</p>
<p>有一个比较常见的错误，当你发现你的<code>terminal</code>里显示了三个箭头<code>&gt;&gt;&gt;</code>时，如下：</p>
<p><img src="/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20211111120400691.png" alt="image-20211111120400691"></p>
<p>这是因为你可能无意间启动了一个<code>python</code>解释器环境，在这个环境下你可以直接输入python代码并按回车，这里就会直接输出结果。此时你直接使用<code>F5</code>运行会报错，退出这个环境就好了，可以输入<code>exit()</code>加回车或者<code>ctrl + z</code>（按键盘）加回车来退出，可以自己试试。</p>
<h1 id="1-环境相关的错误"><a href="#1-环境相关的错误" class="headerlink" title="1. 环境相关的错误"></a>1. 环境相关的错误</h1><h1 id="2-语法错误"><a href="#2-语法错误" class="headerlink" title="2. 语法错误"></a>2. 语法错误</h1><h2 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a><code>SyntaxError</code></h2><p>请根据第0节的示例确定你的错误位置并检查你的代码。</p>
<h2 id="TabError"><a href="#TabError" class="headerlink" title="TabError"></a><code>TabError</code></h2><p>请看以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>是不是看起来没什么问题？但是当你运行时你可能会发现下面这个报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File &quot;xxx\text.py&quot;, line 3</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">                 ^</span><br><span class="line">TabError: inconsistent use of tabs and spaces in indentation</span><br></pre></td></tr></table></figure>

<p>阅读报错提示可知，错误原因是混用了<code>tab</code>和<code>space</code>，其中的<code>tab</code>指制表符，对应的转义字符为<code>\t</code>，<code>space</code>就是普通的空格。python中是允许使用制表符或者空格来进行缩进的，但是<strong>不能混用</strong>。一般来说，为了在各个地方阅读的代码都是一致的，强烈建议使用<strong>四个空格</strong>来缩进，如果你使用的是 VS code，那么在其默认设置中，你按一下<code>tab</code>键，实际上会打出四个空格（即<code>soft tab</code>），所以你不用管这个事情。一般这个问题常常出现在你从别的地方复制代码时（例如老师的某些示例代码）。</p>
<p>那么怎么分辨出是<code>tab</code>还是<code>space</code>呢？在 VS Code 中，你可以选中你的代码，如下：</p>
<p><img src="/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20211111125334189.png" alt="image-20211111125334189"></p>
<p>可以看到，同样是空白的部分，第2行显示的是四个点，第三行显示的是一个箭头，点表示的就是空格，箭头表示的是<code>tab</code>。</p>
<p><strong>如何改正</strong>：请统一使用四个空格缩进。</p>
<p><strong>拓展阅读</strong>：空格与制表符的区别、硬tab与软tab</p>
<p>（请自行在搜索引擎中使用提供的关键词搜索相关资料）</p>
<h1 id="3-运行时的各种错误"><a href="#3-运行时的各种错误" class="headerlink" title="3. 运行时的各种错误"></a>3. 运行时的各种错误</h1><h2 id="AttributeError"><a href="#AttributeError" class="headerlink" title="AttributeError"></a><code>AttributeError</code></h2><p>继续用在第0部分使用过的这个示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        s += random.rand()</span><br><span class="line">    average = s/<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>运行这个片段，会得到如下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;xxx\text.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    s +&#x3D; random.rand()</span><br><span class="line">AttributeError: module &#39;random&#39; has no attribute &#39;rand&#39;</span><br></pre></td></tr></table></figure>

<p><code>Arrtibute Error</code>，即属性错误，简单理解就是<strong>这个库里没有这个东西</strong>，这个东西<strong>可能是一个常量</strong>，例如<code>math.pi</code>，<strong>可能是一个函数</strong>，例如<code>random.random()</code>，<strong>可能是一个成员变量</strong>（如果课程中学了<code>class</code>就知道在说什么了）。</p>
<p>那么到底是什么东西没有呢，请看后面的说明。后面这句话说了模块<code>random</code>中没有<code>rand</code>这个属性，但是你代码中写了<code>random.rand()</code>，这就是错误的原因。</p>
<p><strong>如何改正</strong>：检查拼写错误，看看是不是拼错了，或者干脆就脑补出来一个名字写了上去。</p>
<h2 id="RecursionError"><a href="#RecursionError" class="headerlink" title="RecursionError"></a><code>RecursionError</code></h2><blockquote>
<p>RecursionError: maximum recursion depth exceeded while calling a Python object</p>
</blockquote>
<p>在同学们学到递归之后，可以遇到的错误种类又增加了！在开始示例之前，请牢记<code>recursion</code>这个词在计算机术语中就指的是递归。</p>
<p>我们已经知道，递归调用说白了就是自己调用自己（当然也可以是间接的自己调用自己，例如A调用B，B中又调用A）。在编写递归程序时最需要关注的一个问题就是：<strong>你这个程序能不能停下来</strong>。这是一个很简单的道理，如果一个函数在执行过程中调用了自己，下一次调用中又调用了自己……之后的每次执行都调用自己，子子孙孙无穷匮也，那这个程序显然是不能结束的，类似死循环。但是与死循环不同的是，在计算机中，每一次的调用是会产生额外开销的，例如需要更多的内存，所以有限的计算机资源是无法满足你无限的递归需求的。在<code>python</code>中，这种无限递归产生的最终结果就是报一个<code>RecursionError</code>错误。</p>
<p>我们可以很容易的复现这个错误，编写代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    f(n - <span class="number">1</span>)</span><br><span class="line">f(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>显然，因为这个代码中并不能使递归终结，所以就会无限调用下去直到报错。可以尝试运行这个代码，马上就可以收获错误。</p>
<p><strong>如何改正</strong>：检查你的递归是否能够终结，如果你认为你明明写了递归终结条件（即满足某某条件时就不再继续调用自己了而是直接返回）但还是报了这个错误，那大概率就是你的递归终结条件始终没有满足，你可以通过<code>print()</code>debug法来观察你的递归条件的变化，看看哪里出错了。</p>
<p>例如上述示例代码可以修改为如下形式，就可以正常运行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        f(n - <span class="number">1</span>)</span><br><span class="line">f(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>



<h1 id="4-一些debug思路示例"><a href="#4-一些debug思路示例" class="headerlink" title="4. 一些debug思路示例"></a>4. 一些debug思路示例</h1>]]></content>
      <categories>
        <category>计算概论C</category>
      </categories>
      <tags>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>改作业时发现的常见问题 (21 fall)</title>
    <url>/2021/11/11/%E6%94%B9%E4%BD%9C%E4%B8%9A%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2321f0550efe5034ee0dcc5835bb7ff88fd4c05c5b42a47fe27903eb51000da0">b1c8743748ae1f554aaae721c1205cc441f57087a8f982dede0aaaefeeadf341d0ac06337ce55ba1b31f855ed4e3a792dd1430f1b70811f4a478e7ca1605d41dc3f39864dcfda6a8b34c792ecb8b4e30b0e1c7c81e15d88f179ba6c8e339cc66ffc7b282b49998e284fd90eaea5ef58bd130b1de3d9809611f29d8c9d8dfe6c2d3b0f55a77e387c371a959bb487e4252e6d03d1b21139d5df96f540511450814e588a45aad1fe2688b813549c251ab01523e598ab2ed99020d715f1ce831df5c3477602723a723b7cbffee0579b94c9ba3b1a0c38af46a8b717b41f7f995640c49608e9f9d959b5c5c2e82f3d2ac04382006b33e26c4904415f552d3a9ec65bbb31096c79c99c7c9b89cfc702a33f261a608735b341332a2defb7d88499bdaadb24b39896391615b9b7085744b77d935dcf6be7850ee72004ea3490b9f750078c630bae2f5884a1efa4e3fe90f73ac85311471773a4e3fb25c6e0150baea061d4ce304beeab46a13f67245e0b16d1e93111f4cb4d93e590d41a2bad8bd4c3fa8a30660c0ca9e46aca136f3a08d9c218a951843db62bb69fce3c5b13d12c4a0483199468a8afce53ec371e123bbd3609b67e7973efbfe0fd662ed48f4b253adaa70fbf7a35388878521a4f939e6aaa837c2cde2efc0017ae97933f22f868d268549e67b47cca2ab9fac55611dd0d7ded340090961c7c697cd0b5cdd09d84d5f937f46fa31c24111be10224951406a071827bf4a722339dc832da88c75e895df850bf36b2163a41f4c7c15bdaed8fd84fbae741019f6fc6c7fca57f776aee083219bf2defea4ce8d4504b602185823ce62a9fbcaca920e48c07633e688e4a6b44109d42607978da7eb88ac3591be2fae168a25bf47d4a82bd17135d4996f981c60e679d37979250910998a6fdb723ac324bacd442e4ffb35bf78c031c0d26ec84954b6791bdb645857a6212b67798e168d7b4d84adf5f477b5e23290d60ee11ee442939fd7ee61dc87a83441e1ef188e37cf75bd16359beda44c994171992f58d19dbf33d5e3de35ddfcc9bd0582331daf8080d70703502d9d9006ff8a6515bc45f80af2d13b203f1fe3227ef6dee649d33e139cf57d052926e3a7b9619755e3383707f44416780c8bc2b9934ff96029b7ccd6f6e45e568703d6c97a5daf8297164d4867f6ea00b03c8022a5f2523df65b290eab61dd581081e3a80f926d4bfdd83855c6634744dbbc9c25149828b794315da8857c181d53dd8ea9911246048d1b45784ed51bda728b63a3bc74da15b70fab3946a1645047d69ecdf0e74e1a02366651fb4ae197686d5fd22af3a22ab7a9874814baa39252f50ba76a665bc1e44d6f4bb5299dcc3de45d9306471a15c8224e06446622eab9696397533c313cc4ffe2e8e65bbe036e608f4425bcc5f16f9968c1f7491563fe6e75781f0f7f556892f8b6d300e1fbc2fa96dd53997fb3f30d85aa0ac5e9e8a672a94648ec1b9c9809de96b43bf2af07d92437d8afa0ec11127d6d1c0dd0fa6b170ec36e63b1783694844416067ec2fac82c86be07c436823b0cc9d374075fb01c60b083697a818ff400b11f759857f647ccec74cc71c368de4479c43a7663c72155b262ddd43a057ef5daf7733dcc3da698877992d4b155c1902b67c1b636660ea23c960f4f55a4b7966ce0cb24b13c48f01a1e52a78f30af052a025938e505bef7de947e2ddbad81bfc499cbbd3ff905fd5d44ec7a2c405b9c95832d90a18495b6bfeffa8a080e73465d8a9af1aab452ed869f5ef9aeaae388fb88c40c65fe927752e3d62603409b088c0c08ec61084d6fb4a123bac41d0961abe07701ff7e49edcd8664abeaad7aabf6ba76c77dcd20368f805ce970c1961562a0f3d1bddaf884727f71d6793edceed66d40afa524b94b41320af6a62f98f6cece26311fa24145269d48d5071b674bce15cd49426f649f46ff44adbb6d78062d0ed6746266701e19d4090b2d4d71e4da22e6ec89e9e51e6b2f0006bdcf23a192cb55e58278a1ab5cccdf4c81a7a2e8f20d9c3d7d2343015d93b19e8cb386f8c1c41220dcabf6843b8387e31a866b4efd29ba50ecd4ad57b89c20e841323f4e3c2bd223d623650af63c6712c12f7f70b211c6c9df6c5f898d56a8c97e575f9ee2bc0045fe9dc49ddc8cc77bbcefd92de2babd30ceae944d2a953f0aa4394068f463185ec5c9a3848ed8c018b568def4fbbda5da9c90106e497316fcbf6d97e4a0908489bc2116e3c14c2eb3de342262a46c6cf6da32899452288fa5206d02cc3c19f503eed5614fde5b7b8fd6b1a15c73e23b7b8950f670087f73e6ec7b6ee2eb5259079cb8349899036cbbe5a070f6b34077503d503ec4ede419a6539c71768909899c68075ce1ebf66c776858dc814f72f9567d12d9ecdf4dcb7935e083294c9bdc91b0770633e9511ecbbc5b8aa6bc532b8f987e24ee5a6c5f594cd51a65faa43c60c813d55c11ef61086761309792d6f56caaefb01b70f61f0faf8bc9499a0e5d0675efdb976c21207e17871d0fd5b0f3b4cefd1e4b1a583c354e1963de33fd2d09bde685bd0c26f6f33510e708fda78aee56a9f50d6f8382192d0e3c57fa9a992d127adea584a2cb56debbef7c6cda2e5a468a69df2596919afc33daf2ea4d77d3ce2a1ba4b61fba09dcb91794ca9bf9c06b3641fc1b93a973d9e60839f8a3af08d1c7e718334f9177bffe763a16ed2013ad4ceb90e99263e93a7d11e2d8c2b9582abdc56528e48474680c2b2c2e10b3d9cda8671066abe651577c0278d77e4c2245f4948268a79da473537b6438c3b118c1e29b7cc565df03ebaa762201d9d1193e9d07a70d12ac20e7633569926ef3cd024309b832622ba975383ce57baf0d7210ccdfba7660f4e5575ce35a87c8abeb673e3813fc0878a396484159e99441d5747bbc149a301e780d3b3f8c70496555e4657d0f6e4523b155d96d3c2b0f79b9219edcb53f5f0958b62cdbd5e594cea2e96c1d3e5d18ae0c522b73eb233505ef89bb11b88306429b019b271e32ea48864e13d7be5e8119fc5ab7bb2bcf9730f19e4469ff0e3989b31da656201f52c108f9afa2a0b9087619fea2fbb1795ffa5c1d9af7226be15bd4a0825a5fbdebff082be388569ecbbf408d1c13e3a10477848748b73e155c6767c9adc19850b036780707abfddf50940098b5c7c6712344de05167502baf5deaa2eefc884a578622e96efb4d1c1e5095f26125370e02d6dd5031940dfb1406993dc65866badf92480d072ea4d5fb7b0007b9e6d7557926c40b154f8d90104b451906052c0f31e7919312fff65535ee2cfc98958c07d9f560d78d1547095a4ce04c3cf1319e01149e96a2ca59944a29e85c83f9709d57b41c758bc8baa6880193dee5b544f17f3138b6ca55fbf0b71d0d1a2c3ddf0eb9c934677a403aba502c9670f6637c936aae1729d31957f7c423fe7fd4577c60fbe8ad13d4feaaf3bcdc36f728a5fa39713b245526c3a7ef23febb72ee8a7925f8cdea4289dc6a0c0241bceac7b192058fbb2650a418f92835b3ddf3aafb12f7ad4ce4f6868bacb5b0d16fa530f4c6edaf597c1f7abab11b5efb607fd0745e488809e9ca62a9f02663f239164c71af62d8637c610dcf957a2dc6024410f968d787457d66cf14b2960948d4b96caf364035f86d15b50fc672bcd8348fde5f817ee44fa1fdf3eb0c55fa6f41fe1c418c81bf291a7ce4841dc01ac037fd80e31b36ace8e8141f9ca65a43131d97f72c39bafe3b80acbfea27e8c254104b8da17c8f8350dce6a0cc5dc7445862f86c4280c7560ea4538d935da1928fd7e672e24e488e880a8d971d7a23389c1cd56d6f15538b7d9880229bf54838c4708a6df6d8b599bcdfa5c845b82728db9e6266b5e39f0321201ccaa14c0c7d3a2db6d4aeecb077e1cf5cd163a9a50cb7a82bb635ac6c2508e3020af438c631c169a1d737a3d6fd8cc70355cbb8a877dcbd95c3efa9ebeeae5d81f4e1904e65f55077c17f2b5f76bb717ce4c71ca74749e63b1bb3ee0cfb5ebc6d37e9b92388e19a7ba7419e4cd0ce1da8852f91855be8859bbe1a06b437908aebbbd8197768c779cad5cc745e73185859aec5d79745e8fe8953ac03c79a67cc679c05834f59d9459f0e9e5241279f625400e240fb5331ea7ec5558c672162e41defe7e9adf33d982a8883cd2fd64591313010a706a5422c1dc4e566eaf1133728844f2fd9d572d4dc5480a8be3c7a94606a7fdc3527f30d6ffdeaf46e7c79d8ef5c7dcabb3cd6c1b2644d0caa0c692efbe583c1848bd5235f0488c3f97f8307321845754e1f184904dcaa9c7afd26c725d15618d1edcca38397e098c4699d4bf9d056f8bf97af3af838ac7501d5f76b7cf420c82ab9572b0dd0158be1dbfc950266f267263d3c976b3b6a468b6b90609f5b30ab36f098d13c862d657d8aaf7f3f0c5f4071fd6c2c36536d8b84276fa04a6a087028b5b16f23df189b47591b974ae4a91a3cf7feaf658099952b329779d60da6bf9bd7097890d6a8a4030248223ed5f7de4d27821d27763af334d81a5d68397eb04698f278d4fd31db89caf4857d0361ff07ec5b822ca7c3556f95eae7c9835b322699698a89580dbf2c85e1a83599b877cb86eed526e7e9202a594543b3b978ad9c557cd4b5eb593627bbeccd2ddf416f87b4150877933cf91ab247476b2fc86acde956b592698739bbdc8622e76bf0a79d56311b6e31addf3d2c2f2bf5d161d4fcb937b80fc45030fbf6621079aabd37e94185ec4bb49bcaa378f22cdc68cc45eeb08889ae47c73685ec8e564a9643008cd9568b532eb98e0bfad77805269d24d4d338a2651935f1878ceacb3eb90cafb483aceef7dd5cb5121307e44a474cdd13ffce3dd11a553888bd0e1278e58d9742fff3c2b38e0d2f072ae6ab55cea096dd8a8e2af404ffc63d9aaf316ef67fd2fa5d5b84318358c85afe929446067d2edc53c07accd21868f477670c0bffffbedc805e56bacc60cc773133f7c2648d0244a42ac9a43922e2bfcee865a178737fc9499a056ea139571b1ae48f9f90f7b988fcc6760f89eeb5c5e78e072b27edb4aa5a586809b550a64efad165da19595a7e8f46f6a0db28daaae2be8f3812db33bf85cc2c5f2fa76d3f89f01ba45af490a6d5bd71568404d47a368ccec3d57bf6e613e5a6d12d98d209eac893b4f1cfa0746394fd872c0d4c8a6d123b9d24a00cada651881edad5ee74d7b0d981254a7a8c81c6f9160d1b5d91d7ad7d08ba36531ff4824857389a33126a57d6dbf0114df289bee0974d6fd8ba2a1f5d62643a86a4e2563a76aeb9967b85bead3ab14c9cd14da8d645ba1c31f45f89348dcad38e9b17fd62b691fe5dfbe2984fa0b8f1a109e1cc1e697c534760c1bd369cb7490c58ddc7f35548492e0601382cf0f1d3d9c5936d7a2fea6e3bcffde68ff430482482dc135191384aad4858d90dbac8fdf31d7e67fcb08d2712f27635a29afa664f15c37bba7ea53cf719f31ce65b2547deb180b3cd2e6e8e9d6b952e5cfb67c2d708e13665d9bcc698861acd11ae4b99f23653e2bfd301e61eae8156077810645ca35b99cc4088edd7202a9a18d069458f2e26c88df7bc3d4287de6f2f28c29d25b9cda02700f95f2113f8824af09b5abf8a02fd02fa097bba967c42c4e93fbd174f10b81ac66f9072e2bc28f210bf864eb38dfd872f6069ef048e33f5c84db83eaaad13f4a30a08640a1aefbd87f191f126750561698ccde903be3ce9eb92d79155d304a3b25445756f9018c94a2015da3fa3fa57ce4c1ff95da7edb6175fc811a41dfe9821ab808388b932c206399ffb6a6a369779032d151ef746657388151ec18a139962d200e3766944906500da44548d7118e219fb15eb2bcaff2d7d8234a9ae7245d399902539e1ab3a60c2692f52964210f01c0cf9d42538e2ce5060a3f7ca1a080d4f28d5e8aae3c5d4982d69238587d3e5f71bfce4e6b8a9616a69c4fd7da2464592efed55d2632f57fda417d56c8750ec27067f3da821e50acda98529974c677ed28bbc0b646bf051d9b0571e635f32adea52d9bbdb8ff484f9879a5fa445e87cc4b24f6e467abd161e52c3240a15abf271735617fe635629a7a244c4a5839f181ea27593bcde1467d7ad9eb878079281a2b3ab5fd5f14d3890e599bc61591d1cbf656651ebcc19979d598d746b39cdb23f2b6888d2a80c98b63f4cf2da7a33d986ff38f9f0169e97139a29e0af3f515da88111fb86f82a087060fd5f78cf1299c10b6373ec612e84de912622d804c406b48a7e6cc68561f27f8e406f0cc04a07d1ab3a023813b9b8f43606032bbc645d5b3f2f3f4f9c6cca65ed4e8b73a5e5d50080fdcec8c915d4b7e47cbabf3bc187b488dd26d37edd4b07c1630ee72134c007ef876d3b387147a4ac9b7d367715349a3e338f863ba451dde2c4c6a87d73ecb7ffccf76592bb3d24e67d8a780bf362e678aa82032d73ac9907503cbc9eded3a26021614e59f690adff6ff8055fc2b1cecea1cf338506d86a06f922119634d06e5045c490b713d35db76ea6568564964fa5e7b8681707075ed4d7a30068cd4e8c31ffe69fb1b1936ada588c4d808159c3dc2270bf9d0a84977f53a8d7cc41383298f740b407cee71a2c7b2cc389ff38ac27f81739c266fd0131f73cedc353e14cabb0f5893ee5e2a730663f6620b0c3aea6e73ed1ca4a26cedd2408f9050a145342da4314fc565dd4686ebc60581631332de5ddd3c583f5f7df1e51c1b00c1417453b674b1bd80d63aa5441be5aac80bc5367472b0960d56d75a86d46c821e97f215ad386078b23f1b42dbffff126d9a0509447d436ee2856af6a1d348c65fc9cb3f5408e97213b49e571a1c04feb86ccbe1fd9fbb8071990b090fb8ec56637be90dd3c1155ec9006ffea72a21c9a0f926d7ccec521f18d82b4f977e06d8836f1ec7c1982f45558d26111407ca056b789e7fefd19ebd7eeb2c530b1e4c09e57bcd5ec243cd3d52f0cbe532c547a62a1ca07a98bfb21f6ca744b7659d67ebeb62ed7598057792b5a09b8880dbadc8a140f2fe790cd5215cb85fcedcd195d2a822a35fd60ed3ab75878aea81f7827265ec36d3c6ea5305746e0795b5daed1bc3bd3dd8e10e687a71c6f79cde72f18b4f0559d1ebb21763d5abdabaa64c2ac9a0e32b4cc806213d64f921a82fd1f9a4641b1e8a82329baf3402a498b3599340fc140dbf6e2fda14a446dc1b94dc4f251f641bc7dd34368ea8b377e78c7ce398a003b8b70c7a5e9df652bc4addec3adb73a2e03c6a225e6f036929a01f622be07c931e35cadf2fab6c71f1cd8d5008e06e61958241ed4efda0888a852964e6e7dc26e9a264acd7513f113a0b0cbfb9ab6310e48d0320a3c7ebaccd5dee0bd06bdf595721efd6a318491fba2ea905e651e0ddb47fe01604779588636a133f87689007dc905e2b067d1278097b29ebcadceb145e786c2ae119ac5996ef549a3d66a3f89af6ee54a71515a9b821a24db7b15dbf25313c893dd0b9518f5ded4611ccecc4f8711d70e6fd5afbd8eeb232a897ea6a297188d28046f5135c168fa407c9b8fad228201c8b77b2da67a6ec0ec2877a1aca5721a0d36bd8d6ac3b72b8fa89a4c8299e505b091d39cc84320446632a7c120612563bc8481d262b2be01da314d3ab3e0ab63c6eaf74e8ef3ae1ff52ca114cf9196281f14d55e142bebf05d22c9994b1906fcbfc08d4ea060d7897a3da5d19038a8ffc8d0228fc39680b8e561b74e9b72bff261901f44717b644c5267af739981d22d0f35a0ecd2c54574082f24a75245be6db39d94600041345327f9f161cfa1cc700ac2db82babb50e94189f1eed35a5dd22e479430c1ff264810f743149ed45a2aa368e78d9be17fc308991596ec68d8d6f4db122e3b0d7ed9e02051eb9360b1bf5cbc3c148760e7f4ab0b47f3e185e34bca7c2f6bc5685ff006a3aefdef9f22286756aa27cb255368b02e51a7bf4a514bed991ae08ef1352741ce9149ba94c8532509b559fe62d9421de82dbf3157c54e8673010db44a9c7f600091b1439c2ad548c4048d767e7aa1c176f36f2b7d6ccc056c22906aa7e13b04d7fdc598ccfc7afd0e00d68d3d458b09753081106cd504bbe1936739320a2829b6bbedc7c7d5f81f31f23cc2f6126c9bab10130b0cc5e4e0c091da0361650d62860a20cce4177e01fc796797070ff645a5f8edf7115e4e0ca54376fdf9464e8dc991d66201bd81635087b9c374cf6046c42075075cec83fa5ca1d22cf31a5b836c666903986753642aad3604a9395fa1afe632b98df30ce5c5d9314a205b66c61b979925f03221309fbd21da912a52901ae67dff59c0271d6cdd79978a6d9e577edc0997ea8a19902c897da1c35987e5478a70bf40c0f24c4054f04885e7ceb0feaddb7a5940eae3b040ed4b15c13b3b0b3295e93b9de8c3aed0b2108920c0019f7628b4b862b27e200f62449effa46b6180c934ec2de8a44b4c45f781c65285a54a00e42318573f35b5ceaf3ba558f3ca69fe2a25082ddf7c595f7959cb776db0b33bb2755321cb9f009ed327a01028549b66c2faeb107791323c1cdff439407287157fe89aa97786a4d7ee0d4d8882f2c1baeb324fd08c0a35cbe0ef699b5215ebcfc4e03e21c165a7fbbf979169103dae105290c0da34f6dd73bc9072dd5ab6fdf9ea51a06e0cd0eb5bd67292f929ccd61a227134935afd9a16fcdc29f43c71625e1e101</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave"></span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算概论C</category>
        <category>计算概论C(21 fall)</category>
      </categories>
      <tags>
        <tag>计算概论C(21 fall)</tag>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 1 滑动窗口</title>
    <url>/2021/04/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>本次实验要求在一个数据链路层的模拟实现环境下，用C语言实现三个数据链路层协议：1比特滑动窗口协议、回退N帧滑动窗口协议、选择性重传协议。</p>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>通过阅读实验指导书可以发现，回退N帧滑动窗口协议是最重要的一个，其他两个协议都可以看作在此基础上的一点小修改，所以本次实验中最重要的一点是实现回退N帧滑动窗口协议。<br>在回退N帧实验中，系统和我需要实现的函数的函数交互方式如下：</p>
<blockquote>
<p><strong>等停协议和回退N帧协议：</strong><br>当发送端需要发送帧时，会调用学生测试函数，并置参数<code>messageType</code>为<code>MSG_TYPE_SEND</code>，测试函数应该将该帧缓存，存入发送队列中。若发送窗口还未打开到规定限度，则打开一个窗口，并将调用<code>SendFRAMEPacket</code>函数将该帧发送。若发送窗口已开到限度，则直接返回，相当于直接进入等待状态。</p>
<p>当发送端收到接收端的<code>ACK</code> 后，会调用学生测试函数，并置参数<code>messageType</code>为<code>MSG_TYPE_RECEIVE</code>，测试函数应该检查<code>ACK</code>值后，将该<code>ACK</code> 对应的窗口关闭。由于关闭了窗口，等待发送的帧可以进入窗口并发送，因此，此时若发送队列中存在等待发送的帧应该将一个等待发送的帧发送并打开一个新的窗口。</p>
<p>发送每发送一个帧，系统都会为他创建一个定时器，当被成功<code>ACK</code> 后，定时器会被取消，若某个帧在定时器超时时间仍未被<code>ACK</code>，系统则会调用测试函数，并置参数<code>messageType</code> 为<code>MSG_TYPE_TIMEOUT</code>，告知测试函数某帧超时，测试函数应该将根据帧序号将该帧以及后面发送过的帧重新发送。</p>
</blockquote>
<p>可见，系统通过反复调用我实现的函数，通过<code>messageType</code>来标注是什么样的操作要求。因此我们可以考虑通过<code>switch</code>来区分开不同的操作，每个操作进行单独的实现。除此之外，在运行过程中，还有数据保存要求，所以我们需要全局变量或者静态变量来存储一些数据，考虑到每个函数功能的单独性，用静态变量实现会更优雅，在本次实验中选择这样实现。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><p>正如之前所述，我将以回退N帧数函数为基础完成整个实验，在此部分进行一些代码细节的说明。<br>首先，定义的一些常量以及结构如下：</p>
<ul>
<li><p>两个窗口大小的常量</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_STOP_WAIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_BACK_N_FRAME 4</span></span><br></pre></td></tr></table></figure></li>
<li><p>表示帧状态的枚举型</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    data,</span><br><span class="line">    ack,</span><br><span class="line">    nak</span><br><span class="line">&#125; frame_kind;</span><br></pre></td></tr></table></figure></li>
<li><p>系统中定义的<code>frame</code>结构</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame_head</span> &#123;</span></span><br><span class="line">    frame_kind kind;		<span class="comment">// 帧类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq;		<span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ack;		<span class="comment">// 确认号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">100</span>];<span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame</span> &#123;</span></span><br><span class="line">    frame_head head;		<span class="comment">//帧头</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;  	<span class="comment">//帧的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义的用于存储帧的<code>Buffer</code>结构。其中<code>pBuffer</code>和<code>pFrame</code>指针指向同一片地方只是生命的类型不同，主要是便于之后调用时不再手动强制类型转换。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer;	<span class="comment">// 向`SendFRAMEPacket`函数传的第一个参数</span></span><br><span class="line">    frame *pFrame; 			<span class="comment">// 存储的frame的指针</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize;			<span class="comment">// size，向`SendFRAMEPacket`函数传的第二个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Buffer</span>() &#123;</span><br><span class="line">        <span class="comment">// 分配一块储存frame的空间</span></span><br><span class="line">        pFrame = <span class="keyword">new</span> <span class="built_in">frame</span>();	</span><br><span class="line">        <span class="comment">// 将分配的地址指针赋值给pBuffer</span></span><br><span class="line">        pBuffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) pFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于储存frame的工具成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">char</span> *_pBuffer, <span class="keyword">int</span> _bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意不能是复制指针，而是需要把内容复制过来</span></span><br><span class="line">        (*pFrame) = *((frame *) _pBuffer);</span><br><span class="line">        bufferSize = _bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>一个用于通过指针获得<code>ACK</code>的宏函数</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后，回退N帧测试函数<code>stud_slide_window_back_n_frame</code>内定义的用于存储数据的静态变量如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_back_n_frame</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="comment">// switch body .......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中各变量的意义如下：</p>
<ul>
<li><code>lower</code>: 滑动窗口的下界</li>
<li><code>upper</code>: 滑动窗口上界的下一个</li>
<li><code>wait_queue</code>: 由于窗口打开到上限不能直接<code>send</code>的帧的等待队列</li>
<li><code>WINDOW_SIZE</code>: 在本函数中的窗口大小，每个函数中可能不一样</li>
<li><code>windows[WINDOW_SIZE]</code>: 用于存储各窗口发出的帧的数组，大小和窗口大小一样</li>
</ul>
<p>此外，需要注意的是，实际打开的窗口的<strong>窗口号</strong>下界为<code>lower % WINDOW_SIZE</code>，上界的下一个<strong>窗口号</strong>为<code>(upper + 1) % WINDOW_SIZE</code>。因为实际窗口号是在一定范围内轮流使用，例如<code>0,1,2,3,0,1,2,...</code>这样，但是如果将下界和上界直接这样表示有时会带来额外的麻烦，例如当窗口大小为1时，只存在一个窗口号<code>0</code>，此时<strong>上界的下一个窗口号</strong>也还是<code>0</code>，刚开始实现时就是因为这样，导致回退N帧测试函数不能直接修改<code>WINDOW_SIZE</code>来用在等停测试函数中。</p>
<p>之后便是<code>swtich</code>中各个功能的实现，实现细节如下：</p>
<ul>
<li><code>MSG_TYPE_SEND</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">	<span class="comment">// 保存帧的内容</span></span><br><span class="line">	Buffer buffer;</span><br><span class="line">	buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">	wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">	<span class="comment">// 发送等待序列中的帧</span></span><br><span class="line">    <span class="comment">// 当队列不为空且窗口大小小于最大大小时进行发送。</span></span><br><span class="line">	<span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">        <span class="comment">// 从队列头取出一个并发送</span></span><br><span class="line">		Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">		wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">        <span class="comment">// 将发送的帧储存在对应窗口中</span></span><br><span class="line">		windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">		upper++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><code>MSG_TYPE_RECEIVE</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">    <span class="comment">// 读取收到的ack</span></span><br><span class="line">	<span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">    <span class="comment">// 从目前的打开的窗口中寻找seq=ack的窗口</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">            <span class="comment">// 如果找到，说明i窗口以及之前的窗口已经被成功接受，则下界应当更新为i + 1</span></span><br><span class="line">			lower = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时如果能继续发送则继续发送，该部分发送函数的逻辑和`case MSG_TYPE_SEND`中的对应部分一模一样</span></span><br><span class="line">	<span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">		Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">		wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">		windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">		upper++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><code>MSG_TYPE_TIMEOUT</code>:  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">		Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">		<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上便是回退N帧协议的实现细节。在实现中要注意的几个点，从<code>pFrame</code>中读取数据时（在本次实验中要读取的为<code>seq</code>、<code>ack</code>、<code>kind</code>），要注意大小端的转换，直接用<code>ntohl()</code>函数即可。在这种实现中，实现等停协议只需要将<code>WINDOW_SIZE</code>设置成<code>WINDOW_SIZE_STOP_WAIT</code>（即为1）即可，此外<strong>不需要任何的修改</strong>。</li>
</ul>
<p>选择性重传函数中，取消了<code>MSG_TYPE_TIMEOUT</code>这种类型，只需要对<code>case MSG_TYPE_RECEIVE</code>做一些修改即可，修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">    <span class="comment">// 读取`kind`区分是`ack`还是`nak`</span></span><br><span class="line">	<span class="keyword">int</span> kind = <span class="built_in">ntohl</span>(((frame *) pBuffer)-&gt;head.kind);</span><br><span class="line">    <span class="comment">// 如果kind是`ack`，和之前的处理一模一样，此处略</span></span><br><span class="line">	<span class="keyword">if</span> (kind == ack) &#123;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果kind是`nak`，则将帧中的`ack`表示的帧号找出来重发</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (kind == nak) &#123;</span><br><span class="line">		<span class="keyword">int</span> nak = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历找到缓存的帧中seq等于读出的ack（在这里用变量nak表示）的帧</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123;</span><br><span class="line">				Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">				<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，该实验结束。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>不熟悉实验系统，实验系统对一些错误也不能很好的反馈。例如刚开始的时候，由于代码实现中将<code>Buffer</code>这个辅助结构当成一个<code>class</code>来使用，写了析构函数，并在析构函数中进行了<code>delete</code>操作，但是由于忽略了局部变量作用域的问题，导致了某些指针被重复释放，出了错误，但是在实验系统中并没有报错，只是单纯的卡住不动，最后因为过去的一点点经验想到了可能是指针相关的错误，最后才找到了这个问题。</li>
<li>还没找到很方便的debug方法，在做实验时还是通过最原始的输出log来寻找问题，实验系统中的单步调试功能也没太用习惯。</li>
<li>对大小端转换的问题还没有形成习惯，漏了好几次转换，运行出错了才发现没写。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>由于三个函数的代码重复性很高，而且前面已经给出了详解，因此在完整代码部分删去了注释。代码说明见前面<strong>实验细节</strong>部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysinclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SendFRAMEPacket</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_STOP_WAIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_BACK_N_FRAME 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    data,</span><br><span class="line">    ack,</span><br><span class="line">    nak</span><br><span class="line">&#125; frame_kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame_head</span> &#123;</span></span><br><span class="line">    frame_kind kind;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ack;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame</span> &#123;</span></span><br><span class="line">    frame_head head;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer;</span><br><span class="line">    frame *pFrame;</span><br><span class="line">    <span class="keyword">int</span> bufferSize;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Buffer</span>() &#123;</span><br><span class="line">        pFrame = <span class="keyword">new</span> <span class="built_in">frame</span>();</span><br><span class="line">        pBuffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) pFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">char</span> *_pBuffer, <span class="keyword">int</span> _bufferSize)</span> </span>&#123;</span><br><span class="line">        (*pFrame) = *((frame *) _pBuffer);</span><br><span class="line">        bufferSize = _bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 停等协议测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_stop_and_wait</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用static变量来持久化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_STOP_WAIT;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                    lower++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 回退n帧测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_back_n_frame</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用static变量来持久化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                    lower = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 选择性重传测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_choice_frame_resend</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> kind = <span class="built_in">ntohl</span>(((frame *) pBuffer)-&gt;head.kind);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kind == ack) &#123;</span><br><span class="line">                <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                        lower = i + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                    Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                    wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                    windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                    upper++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (kind == nak) &#123;</span><br><span class="line">                <span class="keyword">int</span> nak = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123;</span><br><span class="line">                        Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                        <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 4 TCP客户端</title>
    <url>/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-4-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>该次实验主要包含以下四部分</p>
<ol>
<li>设计TCB结构</li>
<li>处理TCP协议的包的接收（实现<code>stud_tcp_input()</code>函数）</li>
<li>封装TCP包（实现<code>stud_tcp_output()</code>函数）</li>
<li>实现<code>Socket</code>的几个接口函数</li>
</ol>
<p>需要注意的是，本次实验中只实现了一个客户端角色的TCP协议并使用等停模式。因此客户端的状态可以做以下简化，如实验指导书上所示</p>
<p><img src="/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-4-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF/lab4-1.png"></p>
<p><strong>然而这里的图画的又跟后面实验指导书上说的有自相矛盾的地方，具体的要求当然是自己去试试怎么样才对（？）</strong></p>
<p>所以本次实验的核心在于定义这些状态并实现这里的状态转换。</p>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>本次实验中，我们首先要定义一个TCP结构如下，我们并不考虑选项部分，所以可以认为<code>urgentPointer</code>之后都是数据段，我们只要原封不动的处理即可。</p>
<p>需要注意的是，在本次实验中，TCP结构统一用网络序表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;</span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;</span><br><span class="line">    <span class="keyword">uint32_t</span> seqNum;</span><br><span class="line">    <span class="keyword">uint32_t</span> ackNum;</span><br><span class="line">    <span class="keyword">uint8_t</span> headLen;</span><br><span class="line">    <span class="keyword">uint8_t</span> flags;</span><br><span class="line">    <span class="keyword">uint16_t</span> windowSize;</span><br><span class="line">    <span class="keyword">uint16_t</span> checkSum;</span><br><span class="line">    <span class="keyword">uint16_t</span> urgentPointer;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debugPrint</span><span class="params">()</span></span>&#123; <span class="comment">/* debug用，这里略 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们设计的TCB结构如下。在本次实验中，我们TCB中的数据以本地序表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;             <span class="comment">// 套接字描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> srcAddr;       <span class="comment">// 源地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;       <span class="comment">// 源端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dstAddr;       <span class="comment">// 目的地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;       <span class="comment">// 目的端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> seq;           <span class="comment">// seq</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ack;           <span class="comment">// ack</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ackExpect; <span class="comment">// 应该收到的ack</span></span><br><span class="line">    TCPStatus status;       <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">char</span> *data;             <span class="comment">// 数据段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>TCPStatus</code>是一个枚举类，用于表示各种状态，如下，与实验指导书上给出的状态示例相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TCPStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CLOSED,</span><br><span class="line">    SYN_SENT,</span><br><span class="line">    ESTABLISHED,</span><br><span class="line">    FIN_WAIT1,</span><br><span class="line">    FIN_WAIT2,</span><br><span class="line">    TIME_WAIT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作为客户端，需要处理当前连接的状态，我们可以在客户端的本地使用一个全局变量来存储状态，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCB *currentTCB;</span><br></pre></td></tr></table></figure>

<p>该变量记录了当前的连接信息，每次操作时会查找这里的状态。</p>
<p>另外，由于客户端可能会发起多个连接，拥有多个套接字连接符，因此我们还需要一个机构存储多个连接信息，本次实验中我们使用<code>std::vector</code>来完成，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TCB *&gt; TCBTable;</span><br></pre></td></tr></table></figure>

<p>另外，在实现各个函数时一定要<strong>非常注意</strong>字节序的问题。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><h4 id="实现用于计算check-sum的工具函数"><a href="#实现用于计算check-sum的工具函数" class="headerlink" title="实现用于计算check sum的工具函数"></a>实现用于计算<code>check sum</code>的工具函数</h4><p>该函数主要用于计算<code>checkSum</code>，在本次实验中，我们采用所有数据均为网络序的方法来计算<code>checkSum</code>，在实现时要注意。</p>
<ul>
<li><p>首先，给出函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getCheckSum</span><span class="params">(<span class="keyword">char</span> *pBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">short</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>pBuffer</code>传来的是一个<strong>网络序</strong>的tcp包，<code>len</code>是这个包的<strong>总长度</strong>（包括头部），<code>srcAddr</code>和<code>dstAddr</code>是<strong>本地序</strong>的源地址和目标地址，用于计算伪头信息。</p>
</li>
<li><p>计算伪头部分</p>
<p>这里需要注意的是，由于<code>srcAddr</code>，<code>dstAddr</code>，<code>len</code>都是本地序，因此这里要做一次转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪头部分</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr_n = htonl(srcAddr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr_n = htonl(dstAddr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> len_n = htons(len);</span><br><span class="line">checkSum += (srcAddr_n &gt;&gt; <span class="number">16</span>) + (srcAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 源地址</span></span><br><span class="line">checkSum += (dstAddr_n &gt;&gt; <span class="number">16</span>) + (dstAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 目标地址</span></span><br><span class="line">checkSum += (TCP_PROTOCOL_NUM &lt;&lt; <span class="number">8</span>);                  <span class="comment">// TCP协议号</span></span><br><span class="line">checkSum += len_n;    </span><br></pre></td></tr></table></figure></li>
<li><p>计算TCP部分如下，由于<code>pBuffer</code>是一整个结构，而且本身就是网络序，因此我们可以直接转成一个16位整数的数组来操作，会很方便。需要注意跳过原来结构中的<code>checkSum</code>部分，该部分对应<strong>第8个16位整数</strong>。当TCP的数据部分是奇数字节时，我们需要在末尾补一个全0字节，因此需要特判奇数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> *TCPBuffer = (<span class="keyword">uint16_t</span> *)pBuffer;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">8</span>)</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     checkSum += TCPBuffer[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 注意长度的奇偶，要特判奇数</span></span><br><span class="line"> <span class="keyword">if</span> (len % <span class="number">2</span>)</span><br><span class="line">     checkSum += ((<span class="keyword">uint16_t</span>)(pBuffer[len_h]) &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>最后，我们需要处理高位，将高16位加到低16位上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除高位</span></span><br><span class="line"><span class="keyword">while</span> (checkSum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    checkSum = (checkSum &amp; <span class="number">0xffff</span>) + (checkSum &gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>最后的结果应该是现在计算出的值的取反，返回即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (~checkSum) &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实现stud-tcp-input"><a href="#实现stud-tcp-input" class="headerlink" title="实现stud_tcp_input"></a>实现<code>stud_tcp_input</code></h4><p><strong>注意！！！！系统调用该函数的时候传进来的地址是网络序！</strong>（但是调用系统提供的一些接口函数时却需要传本地序，果然很奇怪啊）。</p>
<ul>
<li><p>首先，将传入的<code>pBuffer</code>转换成一个<code>TCP</code>指针，便于之后操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCP *tcp = (TCP *)pBuffer;</span><br></pre></td></tr></table></figure></li>
<li><p>首先，检查<code>checksum</code></p>
<p>这里调用我们刚才的那个函数即可</p>
<p><strong>然而，实际上并不会有这个东西出错的时候，而且实验指导书上也没说出错时应该怎么处理，所以这个不写也没问题（在该系统上）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (getCheckSum(pBuffer, len, ntohl(srcAddr), ntohl(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略了一些debug显示</span></span><br><span class="line">    <span class="comment">// 实验指导书上没定义这个错误？</span></span><br><span class="line">    <span class="comment">// tcp_DiscardPkt(pBuffer, checksum_error);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后，检查<code>ack</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查ack</span><br><span class="line">uint32_t ackNum &#x3D; ntohl(tcp-&gt;ackNum);</span><br><span class="line">uint32_t seqNum &#x3D; ntohl(tcp-&gt;seqNum);</span><br><span class="line">if (ackNum !&#x3D; currentTCB-&gt;ackExpect)</span><br><span class="line">&#123;</span><br><span class="line">    tcp_DiscardPkt(pBuffer, STUD_TCP_TEST_SEQNO_ERROR);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后，是最核心的状态转化的一步，如下：</p>
<ul>
<li><p>当前状态为<code>SYN_SENT</code>，接收到的<code>flag</code>为<code>PACKET_TYPE_SYN_ACK</code>，状态转换到<code>ESTABLISHED</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;status = ESTABLISHED;</span><br><span class="line">    currentTCB-&gt;seq = ackNum;</span><br><span class="line">    currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前状态为<code>ESTABLISHED</code>，继续进行通信</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;seq = ackNum;</span><br><span class="line">    currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH);</span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前状态为<code>FIN_WAIT1</code>，接收到的<code>flag</code>为<code>PACKET_TYPE_ACK</code>，状态转化到<code>FIN_WAIT2</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK) &#123;</span><br><span class="line">    currentTCB-&gt;status = FIN_WAIT2;</span><br><span class="line">    currentTCB-&gt;seq = ackNum;</span><br><span class="line">    currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前状态为<code>FIN_WAIT2</code>，接收到的<code>flag</code>为<code>PACKET_TYPE_FIN_ACK</code>，状态转换到<code>TIME_WAIT</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;status = TIME_WAIT;</span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实现stud-tcp-output"><a href="#实现stud-tcp-output" class="headerlink" title="实现stud_tcp_output"></a>实现<code>stud_tcp_output</code></h4><p><strong>在我们自己实现自己调用的该函数中，参数里的IP地址均为本地序（主要是一开始我以为<code>input</code>那个函数中也是这样）</strong></p>
<p><strong>另外一个需要注意的是，在第一部分的测试中，由于该部分会认为没有实现<code>socket</code>接口，所以不会调用相应的函数，也不会有创建<code>TCB</code>这个过程，所以在调用这个函数时会出错（空指针），因此我们需要在这里加一个<code>surrentPCB</code>的初始化。</strong></p>
<ul>
<li><p>初始化<code>currentTCB</code>（只针对第一部分的测试）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">    currentTCB-&gt;status = CLOSED;</span><br><span class="line">    currentTCB-&gt;ack = gAckNum;</span><br><span class="line">    currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">    currentTCB-&gt;srcAddr = srcAddr;</span><br><span class="line">    currentTCB-&gt;dstAddr = dstAddr;</span><br><span class="line">    currentTCB-&gt;srcPort = srcPort;</span><br><span class="line">    currentTCB-&gt;dstPort = dstPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个新的<code>tcp</code>结构，并且将<code>pData</code>中的数据复制过去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line"><span class="built_in">memcpy</span>(tcp-&gt;data, pData, len);</span><br></pre></td></tr></table></figure></li>
<li><p>构建<code>TCP</code>头，<strong>一定要注意使用网络序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造TCP头</span></span><br><span class="line">tcp-&gt;srcPort = htons(srcPort);</span><br><span class="line">tcp-&gt;dstPort = htons(dstPort);</span><br><span class="line">tcp-&gt;seqNum = htonl(currentTCB-&gt;seq);</span><br><span class="line">tcp-&gt;ackNum = htonl(currentTCB-&gt;ack);</span><br><span class="line"><span class="comment">// 注意低四位为空，头长度为5 * 4字节</span></span><br><span class="line"><span class="comment">// 二进制格式0x10010000</span></span><br><span class="line">tcp-&gt;headLen = <span class="number">0x50</span>;</span><br><span class="line">tcp-&gt;flags = flag;</span><br><span class="line"><span class="comment">// 注意这里也要进行一次字节序转换！</span></span><br><span class="line">tcp-&gt;windowSize = htons(<span class="number">1</span>);</span><br><span class="line">tcp-&gt;urgentPointer = <span class="number">0</span>;</span><br><span class="line">tcp-&gt;checkSum = <span class="number">0</span>; <span class="comment">// 预清零checkSum</span></span><br><span class="line"><span class="comment">// 这里要加上一个头长度！！！！！</span></span><br><span class="line">tcp-&gt;checkSum = getCheckSum((<span class="keyword">char</span> *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后，同样是进行状态转换的判断</p>
<ul>
<li><p>从<code>CLOSE</code>状态转换到<code>SYN_SENT</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN)</span><br><span class="line">    currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从<code>ESTABLISHED</code>状态转换到<code>FIN_WAIT1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;status = FIN_WAIT1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>之后，我们需要根据本次的发送来计算下次应当受到的<code>ack</code>值，以便于之后的校验，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    DebugPrint(<span class="string">&quot;---&gt; Status: %d\n&quot;</span>, currentTCB-&gt;status);</span><br><span class="line">    currentTCB-&gt;ackExpect = currentTCB-&gt;seq + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后，调用系统提供的函数进行发送</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcp_sendIpPkt((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)tcp, <span class="number">20</span> + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, <span class="number">60</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，该函数实现完毕。</p>
<h4 id="实现stud-tcp-socket"><a href="#实现stud-tcp-socket" class="headerlink" title="实现stud_tcp_socket"></a>实现<code>stud_tcp_socket</code></h4><p>该函数并不建立连接，只是分配一个套接字标识符。在<code>Linux</code>中，返回的其实就是一个文件描述符，而<code>Linux</code>中文件描述符的<code>0,1,2</code>已经被占用，因此我们这里从<code>3</code>开始分配（虽然没什么差）。实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DebugPrint(<span class="string">&quot;---&gt; stud_tcp_socket():\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果TCB表为空，插入三个NULL</span></span><br><span class="line">    <span class="comment">// socket的返回值应该是一个文件描述符</span></span><br><span class="line">    <span class="comment">// Linux中，文件描述符的0,1,2分别为std_in std_out std_err</span></span><br><span class="line">    <span class="comment">// 所以我们返回的值从3开始</span></span><br><span class="line">    <span class="comment">// 另外，我们希望能根据sockfd直接定位TCB，因此这样实现</span></span><br><span class="line">    <span class="keyword">if</span> (TCBTable.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TCBTable.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.push_back(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">    currentTCB-&gt;ack = gAckNum;</span><br><span class="line">    currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">    currentTCB-&gt;srcPort = gSrcPort++;</span><br><span class="line">    currentTCB-&gt;sockfd = TCBTable.size();</span><br><span class="line">    currentTCB-&gt;status = CLOSED;</span><br><span class="line"></span><br><span class="line">    TCBTable.push_back(currentTCB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentTCB-&gt;sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-connect"><a href="#实现stud-tcp-connect" class="headerlink" title="实现stud_tcp_connect"></a>实现<code>stud_tcp_connect</code></h4><p>需要注意这个函数参数中的<code>sockaddr_in</code>结构是一个用来存套接字中的IP地址信息的结构，内部一定是大端存储IP地址，因此需要注意字节序转换。</p>
<p>在连接时，需要发送一个包，并且在连接时设置<code>currentTCB</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr_in *addr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">	<span class="comment">// 注意这里的字节序转换</span></span><br><span class="line">    currentTCB-&gt;dstPort = ntohs(addr-&gt;sin_port);</span><br><span class="line">    currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">    currentTCB-&gt;srcAddr = getIpv4Address();</span><br><span class="line">    currentTCB-&gt;dstAddr = ntohl(addr-&gt;sin_addr.s_addr);</span><br><span class="line">	<span class="comment">// 发送</span></span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_SYN,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="comment">// 等待对方发送的包</span></span><br><span class="line">    TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">    <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收到服务端的包之后调用`stud_tcp_input`处理</span></span><br><span class="line">    <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-send"><a href="#实现stud-tcp-send" class="headerlink" title="实现stud_tcp_send"></a>实现<code>stud_tcp_send</code></h4><p>由于我们之前已经实现好了<code>stud_tcp_output</code>和<code>stud_tcp_input</code>，因此这里我们直接调用即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">	<span class="comment">// 当前必须为可以发消息的状态</span></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB-&gt;data = (<span class="keyword">char</span> *)pData;</span><br><span class="line">        stud_tcp_output((<span class="keyword">char</span> *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="comment">// 等待对方回复</span></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用stud_tcp_input处理</span></span><br><span class="line">        <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-recv"><a href="#实现stud-tcp-recv" class="headerlink" title="实现stud_tcp_recv"></a>实现<code>stud_tcp_recv</code></h4><p>在该函数中，等待一个对方发来的包并进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 等待对方发来的包</span></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(pData, tcp-&gt;data, len);</span><br><span class="line">        <span class="comment">// 调用stud_tcp_input处理</span></span><br><span class="line">        <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-close"><a href="#实现stud-tcp-close" class="headerlink" title="实现stud_tcp_close"></a>实现<code>stud_tcp_close</code></h4><p>在本函数中，要注意关闭连接时的四次握手，需要注意我们的顺序问题。</p>
<p>首先，应当调用<code> stud_tcp_output</code>发送一个<code>flag</code>为<code>PACKET_TYPE_FIN_ACK</code>的请求，之后对方会先发来一个<code>PACKET_TYPE_ACK</code>的包，接收到之后会进入<code>FIN_WAIT2</code>状态，然后需要继续等待对方发送的包，收到<code>PACKET_TYPE_FIN_ACK</code>才正式关闭，因此这里应该等待两次。实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">	<span class="comment">// 在ESTABLISHED状态才能结束</span></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_FIN_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">		<span class="comment">// 等待ACK</span></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 等待FIN_ACK</span></span><br><span class="line">        tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，各实验函数编写完成，并且在系统上测试通过。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>实验指导书上很多比较细节的地方都没说到，例如函数输入参数的字节序问题，在之前的<code>ipv4</code>实验中，参数中的<code>ip</code>地址是本地序，这次要求的<code>stud_tcp_input</code>的参数就成了网络序，但是提供的接口函数<code>tcp_sendIpPkt</code>还是本地序，我之前在宿舍自己写的时候觉得这两个地方要么都网络序要么都本地序，因为之前也是这样，但是去了之后因为这个问题头疼了半天。</li>
<li>实验指导书上有一些矛盾的地方，给出的一些函数（例如<code>tcp_DiscardPkt</code>）其实一直没用到，有些迷惑。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码再次给出（包括了用于debug的语句等）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* THIS FILE IS FOR TCP TEST</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct sockaddr_in &#123;</span></span><br><span class="line"><span class="comment">        short   sin_family;</span></span><br><span class="line"><span class="comment">        u_short sin_port;</span></span><br><span class="line"><span class="comment">        struct  in_addr sin_addr;</span></span><br><span class="line"><span class="comment">        char    sin_zero[8];</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysInclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DebugPrint(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DebugPrint(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// ?</span></span><br><span class="line"><span class="keyword">int</span> gSrcPort = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> gDstPort = <span class="number">2006</span>;</span><br><span class="line"><span class="keyword">int</span> gSeqNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> gAckNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">tcp_DiscardPkt</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">tcp_sendReport</span><span class="params">(<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">tcp_sendIpPkt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, UINT16 len, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr, UINT8 ttl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">waitIpPacket</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getServerIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP的头占20个字节</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TCP_HEADER_LENGTH = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// TCP协议号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TCP_PROTOCOL_NUM = <span class="number">0x6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP结构</span></span><br><span class="line"><span class="comment">// 永远用网络序！！</span></span><br><span class="line"><span class="comment">// 永远用网络序！！</span></span><br><span class="line"><span class="comment">// 永远用网络序！！</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;</span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;</span><br><span class="line">    <span class="keyword">uint32_t</span> seqNum;</span><br><span class="line">    <span class="keyword">uint32_t</span> ackNum;</span><br><span class="line">    <span class="keyword">uint8_t</span> headLen;</span><br><span class="line">    <span class="keyword">uint8_t</span> flags;</span><br><span class="line">    <span class="keyword">uint16_t</span> windowSize;</span><br><span class="line">    <span class="keyword">uint16_t</span> checkSum;</span><br><span class="line">    <span class="keyword">uint16_t</span> urgentPointer;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debugPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========== tcp struct info ===========\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;srcPort = %d\n&quot;</span>, <span class="built_in">ntohs</span>(srcPort));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dstPort = %d\n&quot;</span>, <span class="built_in">ntohs</span>(dstPort));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;seqNum = %d\n&quot;</span>, <span class="built_in">ntohl</span>(seqNum));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ackNum = %d\n&quot;</span>, <span class="built_in">ntohl</span>(ackNum));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;headLen = %d\n&quot;</span>, ((headLen &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flags = %d\n&quot;</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;windowSize = %d\n&quot;</span>, <span class="built_in">ntohl</span>(windowSize)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;checkSum = %d\n&quot;</span>, <span class="built_in">ntohl</span>(checkSum));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;urgentPointer = %d\n&quot;</span>, <span class="built_in">ntohl</span>(urgentPointer));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TCPStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CLOSED,</span><br><span class="line">    SYN_SENT,</span><br><span class="line">    ESTABLISHED,</span><br><span class="line">    FIN_WAIT1,</span><br><span class="line">    FIN_WAIT2,</span><br><span class="line">    TIME_WAIT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输控制快</span></span><br><span class="line"><span class="comment">// 这是保存在本机的结构，永远用主机序！！！</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;             <span class="comment">// 套接字描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> srcAddr;       <span class="comment">// 源地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;       <span class="comment">// 源端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dstAddr;       <span class="comment">// 目的地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;       <span class="comment">// 目的端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> seq;           <span class="comment">// seq</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ack;           <span class="comment">// ack</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ackExpect; <span class="comment">// 应该收到的ack</span></span><br><span class="line">    TCPStatus status;       <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">char</span> *data;             <span class="comment">// 数据段</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;TCB *&gt; TCBTable;</span><br><span class="line">TCB *currentTCB;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">IpAddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c1;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c2;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c3;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c4;</span><br><span class="line">    &#125; ip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAddr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">IpAddr</span> <span class="title">ip</span>;</span></span><br><span class="line">    ip.num = addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, ip.ip.c4, ip.ip.c3, ip.ip.c2, ip.ip.c1);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约定传来的pBuffer是网络序</span></span><br><span class="line"><span class="comment">// 其他几个应该都是主机序</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getCheckSum</span><span class="params">(<span class="keyword">char</span> *pBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">short</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In getCheckNum():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; srcAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n---&gt; dstAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(dstAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> checkSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 伪头部分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr_n = <span class="built_in">htonl</span>(srcAddr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr_n = <span class="built_in">htonl</span>(dstAddr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> len_n = <span class="built_in">htons</span>(len);</span><br><span class="line">    checkSum += (srcAddr_n &gt;&gt; <span class="number">16</span>) + (srcAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 源地址</span></span><br><span class="line">    checkSum += (dstAddr_n &gt;&gt; <span class="number">16</span>) + (dstAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 目标地址</span></span><br><span class="line">    checkSum += (TCP_PROTOCOL_NUM &lt;&lt; <span class="number">8</span>);                  <span class="comment">// TCP协议号</span></span><br><span class="line">    checkSum += len_n;                                    <span class="comment">// TCP长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> *TCPBuffer = (<span class="keyword">uint16_t</span> *)pBuffer;</span><br><span class="line">    <span class="comment">// 计算主机序下的len</span></span><br><span class="line">    <span class="comment">// 遍历计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        checkSum += TCPBuffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意长度的奇偶，要特判奇数</span></span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span>)</span><br><span class="line">        checkSum += ((<span class="keyword">uint16_t</span>)(pBuffer[len_h]) &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除高位</span></span><br><span class="line">    <span class="keyword">while</span> (checkSum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">        checkSum = (checkSum &amp; <span class="number">0xffff</span>) + (checkSum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Return from getCheckNum(), return value checkSum=%d (hex is %x):\n&quot;</span>, (~checkSum) &amp; <span class="number">0xffff</span>, (~checkSum) &amp; <span class="number">0xffff</span>);</span><br><span class="line">    <span class="comment">// 返回取反的值</span></span><br><span class="line">    <span class="keyword">return</span> (~checkSum) &amp; <span class="number">0xffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传来的是网络序！</span></span><br><span class="line"><span class="comment">// 注意这里的srcAddr和dstAddr也是网络序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_input</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; len is %d:\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; srcAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n---&gt; dstAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(dstAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    TCP *tcp = (TCP *)pBuffer;</span><br><span class="line">    <span class="comment">// 检查CheckSum</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getCheckSum</span>(pBuffer, len, <span class="built_in">ntohl</span>(srcAddr), <span class="built_in">ntohl</span>(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; check sum error\n&quot;</span>);</span><br><span class="line">        tcp-&gt;<span class="built_in">debugPrint</span>();</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; your ans: %d\n&quot;</span>, <span class="built_in">getCheckSum</span>(pBuffer, len, <span class="built_in">ntohs</span>(srcAddr), <span class="built_in">ntohs</span>(dstAddr)));</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; correct ans: %d\n&quot;</span>, tcp-&gt;checkSum);</span><br><span class="line">        <span class="comment">// 实验指导书上没定义这个错误？</span></span><br><span class="line">        <span class="comment">// tcp_DiscardPkt(pBuffer, checksum_error);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查ack</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ackNum = <span class="built_in">ntohl</span>(tcp-&gt;ackNum);</span><br><span class="line">    <span class="keyword">uint32_t</span> seqNum = <span class="built_in">ntohl</span>(tcp-&gt;seqNum);</span><br><span class="line">    <span class="keyword">if</span> (ackNum != currentTCB-&gt;ackExpect)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Error!!! ackNum != currentTCB-&gt;ackExpect\n&quot;</span>);</span><br><span class="line">        <span class="built_in">tcp_DiscardPkt</span>(pBuffer, STUD_TCP_TEST_SEQNO_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: SYN_SENT to ESTABLISHED\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = ESTABLISHED;</span><br><span class="line">        currentTCB-&gt;seq = ackNum;</span><br><span class="line">        currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Transfer data at Status ESTABLISHED\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;seq = ackNum;</span><br><span class="line">        currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH);</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: FIN_WAIT1 to FIN_WAIT2\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = FIN_WAIT2;</span><br><span class="line">        currentTCB-&gt;seq = ackNum;</span><br><span class="line">        currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: FIN_WAIT2 to TIME_WAIT\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = TIME_WAIT;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约定传来的是网络序！（指pData）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_tcp_output</span><span class="params">(<span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> flag, <span class="keyword">unsigned</span> <span class="keyword">short</span> srcPort, <span class="keyword">unsigned</span> <span class="keyword">short</span> dstPort, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; stud_tcp_output():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; srcAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n---&gt; dstAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">        currentTCB-&gt;status = CLOSED;</span><br><span class="line">        currentTCB-&gt;ack = gAckNum;</span><br><span class="line">        currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">        currentTCB-&gt;srcAddr = srcAddr;</span><br><span class="line">        currentTCB-&gt;dstAddr = dstAddr;</span><br><span class="line">        currentTCB-&gt;srcPort = srcPort;</span><br><span class="line">        currentTCB-&gt;dstPort = dstPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">    <span class="built_in">memcpy</span>(tcp-&gt;data, pData, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造TCP头</span></span><br><span class="line">    tcp-&gt;srcPort = <span class="built_in">htons</span>(srcPort);</span><br><span class="line">    tcp-&gt;dstPort = <span class="built_in">htons</span>(dstPort);</span><br><span class="line">    tcp-&gt;seqNum = <span class="built_in">htonl</span>(currentTCB-&gt;seq);</span><br><span class="line">    tcp-&gt;ackNum = <span class="built_in">htonl</span>(currentTCB-&gt;ack);</span><br><span class="line">    <span class="comment">// 注意低四位为空，头长度为5 * 4字节</span></span><br><span class="line">    <span class="comment">// 二进制格式0x10010000</span></span><br><span class="line">    tcp-&gt;headLen = <span class="number">0x50</span>;</span><br><span class="line">    tcp-&gt;flags = flag;</span><br><span class="line">    <span class="comment">// 注意这里也要进行一次字节序转换！</span></span><br><span class="line">    tcp-&gt;windowSize = <span class="built_in">htons</span>(<span class="number">1</span>);</span><br><span class="line">    tcp-&gt;urgentPointer = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;checkSum = <span class="number">0</span>; <span class="comment">// 预清零checkSum</span></span><br><span class="line">    <span class="comment">// 这里要加上一个长度！！！！！</span></span><br><span class="line">    tcp-&gt;checkSum = <span class="built_in">getCheckSum</span>((<span class="keyword">char</span> *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: CLOSED to SYN_SENT\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: ESTABLISHED to FIN_WAIT1\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = FIN_WAIT1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status: %d\n&quot;</span>, currentTCB-&gt;status);</span><br><span class="line">        currentTCB-&gt;ackExpect = currentTCB-&gt;seq + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tcp_sendIpPkt</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)tcp, <span class="number">20</span> + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, <span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; stud_tcp_socket():\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果TCB表为空，插入三个NULL</span></span><br><span class="line">    <span class="comment">// socket的返回值应该是一个文件描述符</span></span><br><span class="line">    <span class="comment">// Linux中，文件描述符的0,1,2分别为std_in std_out std_err</span></span><br><span class="line">    <span class="comment">// 所以我们返回的值从3开始</span></span><br><span class="line">    <span class="comment">// 另外，我们希望能根据sockfd直接定位TCB，因此这样实现</span></span><br><span class="line">    <span class="keyword">if</span> (TCBTable.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TCBTable.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">    currentTCB-&gt;ack = gAckNum;</span><br><span class="line">    currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">    currentTCB-&gt;srcPort = gSrcPort++;</span><br><span class="line">    currentTCB-&gt;sockfd = TCBTable.<span class="built_in">size</span>();</span><br><span class="line">    currentTCB-&gt;status = CLOSED;</span><br><span class="line"></span><br><span class="line">    TCBTable.<span class="built_in">push_back</span>(currentTCB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentTCB-&gt;sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct sockaddr_in &#123;</span></span><br><span class="line"><span class="comment">        short   sin_family;</span></span><br><span class="line"><span class="comment">        u_short sin_port;</span></span><br><span class="line"><span class="comment">        struct  in_addr sin_addr;</span></span><br><span class="line"><span class="comment">        char    sin_zero[8];</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct in_addr &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    in_addr_t s_addr;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr_in *addr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; stud_tcp_connect():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    currentTCB-&gt;dstPort = <span class="built_in">ntohs</span>(addr-&gt;sin_port);</span><br><span class="line">    currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">    currentTCB-&gt;srcAddr = <span class="built_in">getIpv4Address</span>();</span><br><span class="line">    currentTCB-&gt;dstAddr = <span class="built_in">ntohl</span>(addr-&gt;sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_SYN,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line"></span><br><span class="line">    TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB-&gt;data = (<span class="keyword">char</span> *)pData;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>((<span class="keyword">char</span> *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line"></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(pData, tcp-&gt;data, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_FIN_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line"></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line"></span><br><span class="line">        tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>专题：简谈python中的排序</title>
    <url>/2021/11/17/%E4%B8%93%E9%A2%98%EF%BC%9A%E7%AE%80%E8%B0%88python%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>排序问题在这门课中一直是一个小难点，虽然<code>python</code>提供了用来排序的方法，但是很多同学可能一时半会想不太明白这个问题，于是便有了这篇文章。另外，大家在做OJ上的作业题的时候，也可能遇到一些稍微复杂一点的排序问题，类似下面这样：</p>
<blockquote>
<p>有一些人，已知他们的身高和年龄，请将他们按照以下规则排序：</p>
<ol>
<li>身高从高到低排序</li>
<li>相同身高的人中，年龄大的在前面</li>
</ol>
</blockquote>
<p>对于这样的问题，可能有的同学一时不知道该怎么简洁的编写代码实现。</p>
<p>课程中提到排序的时候用的是<code>sorted</code>函数，也经常与<code>lambda</code>表达式配合使用。为了方便大家更好的理解这些问题，我将分为三个部分来介绍：</p>
<ol>
<li>基于比较的排序及实现</li>
<li><code>python</code>中的<code>sorted</code>方法</li>
<li><code>python</code>中的<code>lambda</code>表达式及简单应用</li>
</ol>
<p>由于<code>lambda</code>表达式部分的内容相对独立一些，且<strong>在使用<code>sorted</code>方法时并不是必须要使用<code>lambda</code>表达式，一定不要有什么奇怪的误解</strong>，所以<code>lambda</code>表达式的部分我会单开一个文章来介绍。</p>
<h1 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h1><p>考虑这样一个问题，当我给你一列数字，你该如何将他们按照一定的顺序（例如从大到小）进行排序？这当然是一个简单的问题，<strong>因为对于任意两个数，你知道如何比较它们的大小</strong>，那么显然，如果有一个数比其他的数都大，你可以把它放在第一个，然后从剩下的数中再找一个最大的，放在第二个……就排好了顺序！这就是一个直观的基于比较的排序的方法。</p>
<p>当然，对大家来说，与其理解基于比较的排序这个概念，不如来思考一下有没有<strong>不基于比较的排序</strong>，有兴趣的同学可以了解一下<strong>桶排序</strong>这个方法，是一个挺有意思的想法，这里我们就不细说了。</p>
<h2 id="选择排序——一个直观的排序算法"><a href="#选择排序——一个直观的排序算法" class="headerlink" title="选择排序——一个直观的排序算法"></a>选择排序——一个直观的排序算法</h2><p>在上一节中，我们举了下面这个简单的例子：</p>
<blockquote>
<p>如果有一个数比其他的数都大，你可以把它放在第一个，然后从剩下的数中再找一个最大的，放在第二个……就排好了顺序。</p>
</blockquote>
<p>我们来看一下这个算法的操作过程，例子如下：</p>
<blockquote>
<p>原始数列：1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3</p>
<p>每一步操作，我们都从没有排序过的数列中找到一个最大的数放到第一个，那么排序的每一步操作后的结果如下，竖线之前的是已经排序的数列，竖线之后的是还未排序的数列</p>
<p>step 1: 9 | 1, 4, 1, 5, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3</p>
<p>step 2: 9, 9 | 1, 4, 1, 5, 2, 6, 5, 3, 5, 8, 7, 9, 3</p>
<p>step 3: 9, 9, 9 | 1, 4, 1, 5, 2, 6, 5, 3, 5, 8, 7, 3</p>
<p>step 4: 9, 9, 9, 8 | 1, 4, 1, 5, 2, 6, 5, 3, 5, 7, 3</p>
<p>step 5: 9, 9, 9, 8, 7 | 1, 4, 1, 5, 2, 6, 5, 3, 5, 3</p>
<p>……</p>
<p>step 15: 9, 9, 9, 8, 7, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1</p>
</blockquote>
<p>这个过程应该十分好理解，也非常直观，这个排序算法就叫选择排序，是一个经典的排序算法。我们将这个过程写成python中的函数的形式如下（可以尝试先不看代码，自己按照上面的思路实现一个出来）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">data: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="comment"># 当数列长度为n时，我们应该选择n - 1次</span></span><br><span class="line">    <span class="comment"># 第 1 次从 n 个数中选一个最大的</span></span><br><span class="line">    <span class="comment"># 第 2 次从 n - 1 个数中选一个最大的</span></span><br><span class="line">    <span class="comment"># 第 k 次从 n + 1 - k 个数中选一个最大的</span></span><br><span class="line">    <span class="comment"># 第 n - 1 次从 2 个数中选一个最大的</span></span><br><span class="line">    <span class="comment"># 第 n 次开始时，只剩下一个数，不需要再选择了</span></span><br><span class="line">    <span class="comment"># 所以选择的过程一共有 n - 1次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 第 1 次选择时，从下标 0 到下标 n - 1中选一个最大的，放到下标 0 处</span></span><br><span class="line">        <span class="comment"># 第 2 次选择时，从下标 1 到下标 n - 1中选一个最大的，放到下标 1 处</span></span><br><span class="line">        <span class="comment"># 第 k 次选择时，从下标 k - 1 到下标 n - 1中选一个最大的，放到下标 k - 1 处</span></span><br><span class="line">        <span class="comment"># 注意，如果要将选出来的下标 j 对应的数字放到下标 i，只需要交换这两个位置的数即可</span></span><br><span class="line"></span><br><span class="line">        max_idx = i  <span class="comment"># 当前最大值对应的下标，循环时不断更改</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(data)):  <span class="comment"># 注意这里的range范围！</span></span><br><span class="line">            <span class="keyword">if</span> data[j] &gt; data[max_idx]:</span><br><span class="line">                max_idx = j</span><br><span class="line">        <span class="comment"># 找到最大值位置后，交换</span></span><br><span class="line">        data[i], data[max_idx] = data[max_idx], data[i]</span><br><span class="line">    <span class="comment"># 返回排序好的列表</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>然后就可以进行这样的测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">origin_list = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(selection_sort(origin_list))</span><br><span class="line"><span class="comment"># 输出为：[9, 9, 9, 8, 7, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]</span></span><br></pre></td></tr></table></figure>

<p>可见，确实正确的进行了排序。</p>
<p><strong>（下面的内容仅作了解）</strong></p>
<p><strong>注意</strong>，在这个排序算法的实现中（以及各种基于比较的算法的实现中），有一个重要的细节问题。请注意上面代码的第17行，这个<code>if</code>条件的含义是，如果发现了一个数，比当前找的的最大值还大，就更新当前找到的最大值的位置。那么可以思考这个问题，如果把<code>&gt;</code>换成<code>&gt;=</code>，会影响排序的结果吗？答案显然是不会的。但是使用<code>&gt;</code>和使用<code>&gt;=</code>就完全一样吗？<strong>并不是！</strong>这里涉及到一个<strong>排序的稳定性</strong>的问题，简而言之，指的是对于值相等的那些数，排序之后，这些数的顺序是否与之前一致，若一致，我们就称这个排序是稳定的，否则是不稳定的。</p>
<p>举个简单的例子，有四个人A、B、C、D，身高分别为<code>1.5m</code>、<code>1.6m</code>、<code>1.5m</code>、<code>1.7m</code>。</p>
<p>最开始的顺序为<code>A, B, C, D</code>，按照身高从小到大排序可以得到两种结果：</p>
<ol>
<li><code>A, C, B, D</code></li>
<li><code>C, A, B, D</code></li>
</ol>
<p>其中第一种结果就是一个稳定排序，因为A和C身高相同，原先A在C前面，排序后A仍然在C前面。第二种结果就是不稳定的，因为A和C的相对顺序改变了。</p>
<h2 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h2><p>如果问基于比较的排序的最重要的一点是什么，那当然是<strong>如何比较</strong>。</p>
<p>我们再看一下刚才的算法（去掉了注释，是不是看起来还是挺简洁的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">data: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        max_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> data[j] &gt; data[max_idx]:</span><br><span class="line">                max_idx = j</span><br><span class="line">        data[i], data[max_idx] = data[max_idx], data[i]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>在这个算法中，哪一行函数起到了<strong>比较</strong>的作用？应当是第5行中的<code>data[j] &gt; data[max_idx]</code>，其他部分都是与比较无关的。对于排序数字这个问题，显然比较方法是简单的，但是如果遇到一些复杂的条件该如何解决呢？</p>
<p>例如下面这个问题：</p>
<blockquote>
<p>有一些人，已知他们的身高和年龄，请将他们按照以下规则排序：</p>
<ol>
<li>身高从高到低排序</li>
<li>相同身高的人中，年龄大的在前面</li>
<li>（可选）若身高和年龄相同，则两人排序前和排序后的相对位置不应改变，即排序应当是稳定的</li>
</ol>
</blockquote>
<p>当然，如果让你手动按照这个规则排序，这当然是简单的，因为<strong>这个规则明确告诉你了应该如何比较</strong>，只要你知道怎么比较，后面就都不是问题。但是如何写代码呢？</p>
<p>我们可以将上面的代码改写一些，<strong>将比较的过程抽象成一个函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_greater</span>(<span class="params">x, y</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort_v2</span>(<span class="params">data: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        max_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> is_greater(data[j], data[max_idx]):</span><br><span class="line">                max_idx = j</span><br><span class="line">        data[i], data[max_idx] = data[max_idx], data[i]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>其中函数<code>is_greater(x, y)</code>的含义为：如果<code>x &gt; y</code>，则返回<code>True</code>，否则返回<code>False</code>，当然，在对数字进行排序时，这样的抽象似乎多此一举，但是现在想想，按照这个写法，能不能解决上面那个”身高/年龄排序问题“呢？</p>
<p>答案是显然的。</p>
<p>现在假设我们用元组来表示一个人，例如<code>(&quot;Alice&quot;, 170, 20)</code>表示这个人名字是<code>Alice</code>，身高为170，年龄为20。</p>
<p>首先我们<strong>编写比较函数</strong>，请注意，<strong>比较函数的参数类型取决于你自己定义的数据表示方法</strong>，现在我们知道一个数据是一个三元元组，那么你的函数的参数也应该是一个三元元组，直接给出编写好的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_greater_v2</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 注意x和y都是三元元组</span></span><br><span class="line">    <span class="comment"># 下标 0 为名字，在本例中用不到</span></span><br><span class="line">    <span class="comment"># 下标 1 为身高</span></span><br><span class="line">    <span class="comment"># 下标 2 为年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果x的身高比y大，则“x大于y”</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="number">1</span>] &gt; y[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 如果x y身高相同，但是x年龄大，则“x大于y”</span></span><br><span class="line">    <span class="keyword">elif</span> x[<span class="number">1</span>] == y[<span class="number">1</span>] <span class="keyword">and</span> x[<span class="number">2</span>] &gt; y[<span class="number">2</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 其他情况都是“x不大于y”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>当然，你熟练了之后可以直接写成下面这个简洁的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_greater_v3</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x[<span class="number">1</span>] &gt; y[<span class="number">1</span>]) <span class="keyword">or</span> (x[<span class="number">1</span>] == y[<span class="number">1</span>] <span class="keyword">and</span> x[<span class="number">2</span>] &gt; y[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>接下来我们可以进行测试了，这时候我们会注意到一个问题，我们之前写的<code>selection_sort</code>函数中用的比较函数是固定的，但是我们现在应该能意识到一个问题，<strong>给出不同的比较函数，比较逻辑本身不会变动，换句话说，我们可以认为比较函数本身也可以作为一个参数</strong>，因此我们可以将<code>selection_sort</code>写成下面这个形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort_v3</span>(<span class="params">data: <span class="built_in">list</span>, is_greater</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        max_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> is_greater(data[j], data[max_idx]):</span><br><span class="line">                max_idx = j</span><br><span class="line">        data[i], data[max_idx] = data[max_idx], data[i]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>请注意，在这个函数中，<code>is_greater</code>这个参数本身就是一个函数，在第5行我们调用了这个传入的函数。这种<strong>以函数作为参数的函数称为高阶函数</strong>。</p>
<p>用下面这个例子测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_greater_v3</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x[<span class="number">1</span>] &gt; y[<span class="number">1</span>]) <span class="keyword">or</span> (x[<span class="number">1</span>] == y[<span class="number">1</span>] <span class="keyword">and</span> x[<span class="number">2</span>] &gt; y[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort_v3</span>(<span class="params">data: <span class="built_in">list</span>, is_greater</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        max_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> is_greater(data[j], data[max_idx]):</span><br><span class="line">                max_idx = j</span><br><span class="line">        data[i], data[max_idx] = data[max_idx], data[i]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">origin_list_2 = [(<span class="string">&quot;Alice&quot;</span>, <span class="number">170</span>, <span class="number">20</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="number">176</span>, <span class="number">21</span>), (<span class="string">&quot;Carol&quot;</span>, <span class="number">170</span>, <span class="number">20</span>),</span><br><span class="line">                 (<span class="string">&quot;Dave&quot;</span>, <span class="number">180</span>, <span class="number">23</span>), (<span class="string">&quot;Eve&quot;</span>, <span class="number">176</span>, <span class="number">19</span>), (<span class="string">&quot;Francis&quot;</span>, <span class="number">165</span>, <span class="number">25</span>)]</span><br><span class="line"><span class="built_in">print</span>(selection_sort_v3(origin_list_2, is_greater_v3))</span><br></pre></td></tr></table></figure>

<p>得到输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&#x27;Dave&#x27;</span>, <span class="number">180</span>, <span class="number">23</span>), (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">176</span>, <span class="number">21</span>), (<span class="string">&#x27;Eve&#x27;</span>, <span class="number">176</span>, <span class="number">19</span>), </span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">170</span>, <span class="number">20</span>), (<span class="string">&#x27;Carol&#x27;</span>, <span class="number">170</span>, <span class="number">20</span>), (<span class="string">&#x27;Francis&#x27;</span>, <span class="number">165</span>, <span class="number">25</span>)]</span><br></pre></td></tr></table></figure>

<p>可见，确实按照我们的要求进行了排序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在基于比较的排序中，关键是<strong>定义清楚一个需要排序的数据是什么样的格式</strong>以及<strong>这种格式的数据应当如何比较，可以函数的形式给出</strong>。</p>
<p>排序过程本身涉及到算法的设计，我们大可不用在意这一点，本文中提到的选择排序其实是一个效率十分低的排序方法，在数据量较大时会非常慢，只是为了让大家有一个直观的理解。在理解了<strong>定义比较函数</strong>这个操作之后我们再去看怎么将<code>python</code>中提供的<code>sorted</code>方法与这种思想进行结合。</p>
<h1 id="python中的sorted方法"><a href="#python中的sorted方法" class="headerlink" title="python中的sorted方法"></a>python中的<code>sorted</code>方法</h1><h2 id="方法的参数含义"><a href="#方法的参数含义" class="headerlink" title="方法的参数含义"></a>方法的参数含义</h2><p>sorted 语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)  </span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>iterable</code> ：可迭代对象，例如<code>list</code>。</li>
<li><code>key</code> ：关键词函数，指定用哪个值来进行排序，是一个只接受一个参数的函数，接受的参数值是上述可迭代对象中的元素，返回一个值。具体的解释看本节中的第三部分。</li>
<li><code>reverse</code>：排序规则，<code>reverse = True </code>降序 ，<code>reverse = False</code>升序（默认）。</li>
</ul>
<h2 id="使用sorted-比较函数"><a href="#使用sorted-比较函数" class="headerlink" title="使用sorted + 比较函数"></a>使用<code>sorted</code> + 比较函数</h2><h3 id="cmp-to-key函数"><a href="#cmp-to-key函数" class="headerlink" title="cmp_to_key函数"></a><code>cmp_to_key</code>函数</h3><p>从上述的<code>sorted</code>的参数含义可以看出，在<code>python3</code>的<code>sorted</code>方法中，似乎并没有地方让你填写比较函数。（而在<code>python2</code>中是有的，请同学们查资料的时候一定注意区分）。所以在<code>python3</code>中我们需要使用一个特殊函数<code>cmp_to_key</code>来使用我们之前讲的比较函数。该函数需要<code>import</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br></pre></td></tr></table></figure>

<p>之后你就可以使用<code>cmp_to_key</code>这个函数了。</p>
<p>当然，你也可以换种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br></pre></td></tr></table></figure>

<p>然后使用<code>functools.cmp_to_key</code></p>
<p><strong>你现在应当能理解两种方法的区别，如果不能，你应该复习了！</strong></p>
<p><code>cmp_to_key</code>这个函数，顾名思义，就是将你定义的比较函数转换成<code>sorted()</code>方法需要的<code>key</code>函数。你不用管这是如何实现的，只需要知道这个在干什么就行了。</p>
<h3 id="使用cmp-to-key的比较函数的定义"><a href="#使用cmp-to-key的比较函数的定义" class="headerlink" title="使用cmp_to_key的比较函数的定义"></a>使用<code>cmp_to_key</code>的比较函数的定义</h3><p>之前我们讲比较函数的时候，用了一种比较直观的定义，即定义<code>is_greater</code>来表示一个元素是否大于另一个元素，这样的比较函数只能用来表示是否大于，即“A大于B”或“A不大于B”，而不能表示“等于”或者“小于”关系。</p>
<p>为了解决这个问题，我们可以用其他的方式来定义比较函数。在使用<code>cmp_to_key</code>，我们应当按照如下规则定义比较函数：</p>
<blockquote>
<p>接受两个参数A和B</p>
<ul>
<li>A大于B返回正数</li>
<li>A等于B返回0</li>
<li>A小于B返回负数</li>
</ul>
</blockquote>
<p>对于本文中提到的”身高/年龄排序问题”，可以如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_greater_v4</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 注意x和y都是三元元组</span></span><br><span class="line">    <span class="comment"># 下标 0 为名字，在本例中用不到</span></span><br><span class="line">    <span class="comment"># 下标 1 为身高</span></span><br><span class="line">    <span class="comment"># 下标 2 为年龄</span></span><br><span class="line">	<span class="comment"># “大于”时返回1</span></span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">1</span>] &gt; y[<span class="number">1</span>]) <span class="keyword">or</span> (x[<span class="number">1</span>] == y[<span class="number">1</span>] <span class="keyword">and</span> x[<span class="number">2</span>] &gt; y[<span class="number">2</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># “等于”时返回0</span></span><br><span class="line">    <span class="keyword">elif</span> x[<span class="number">1</span>] == y[<span class="number">1</span>] <span class="keyword">and</span> x[<span class="number">2</span>] == y[<span class="number">2</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 其他情况（即小于）下返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>定义了以上的比较函数之后，就可以配合<code>cmp_to_key</code>来使用<code>sorted</code>方法了。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">origin_list_2 = [(<span class="string">&quot;Alice&quot;</span>, <span class="number">170</span>, <span class="number">20</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="number">176</span>, <span class="number">21</span>), (<span class="string">&quot;Carol&quot;</span>, <span class="number">170</span>, <span class="number">20</span>),</span><br><span class="line">                 (<span class="string">&quot;Dave&quot;</span>, <span class="number">180</span>, <span class="number">23</span>), (<span class="string">&quot;Eve&quot;</span>, <span class="number">176</span>, <span class="number">19</span>), (<span class="string">&quot;Francis&quot;</span>, <span class="number">165</span>, <span class="number">25</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(origin_list_2, key=cmp_to_key(is_greater_v4)))</span><br></pre></td></tr></table></figure>

<p>输出如下，由于<code>sorted</code>方法默认是从小到大，你可以看到这个顺序和我们之前算出来的相反：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&#x27;Francis&#x27;</span>, <span class="number">165</span>, <span class="number">25</span>), (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">170</span>, <span class="number">20</span>), (<span class="string">&#x27;Carol&#x27;</span>, <span class="number">170</span>, <span class="number">20</span>), </span><br><span class="line"> (<span class="string">&#x27;Eve&#x27;</span>, <span class="number">176</span>, <span class="number">19</span>), (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">176</span>, <span class="number">21</span>), (<span class="string">&#x27;Dave&#x27;</span>, <span class="number">180</span>, <span class="number">23</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="使用sorted-key参数"><a href="#使用sorted-key参数" class="headerlink" title="使用sorted + key参数"></a>使用<code>sorted</code> + <code>key</code>参数</h2><h3 id="key是什么？从哪儿来的？"><a href="#key是什么？从哪儿来的？" class="headerlink" title="key是什么？从哪儿来的？"></a><code>key</code>是什么？从哪儿来的？</h3><p>在之前的部分中，我们一直在说比较函数<code>cmp</code>本质就是去定义两个东西应该怎么比较，但是在所有的场景下我们都需要<strong>完全手动定义</strong>两个数据怎么比较吗？有没有更简洁一些的方法呢？</p>
<p>例如，对于下面的”身高/年龄”数据进行排序，如果我们要求只按照身高排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&quot;Alice&quot;</span>, <span class="number">170</span>, <span class="number">20</span>), (<span class="string">&quot;Bob&quot;</span>, <span class="number">176</span>, <span class="number">21</span>), (<span class="string">&quot;Carol&quot;</span>, <span class="number">170</span>, <span class="number">20</span>),</span><br><span class="line">(<span class="string">&quot;Dave&quot;</span>, <span class="number">180</span>, <span class="number">23</span>), (<span class="string">&quot;Eve&quot;</span>, <span class="number">176</span>, <span class="number">19</span>), (<span class="string">&quot;Francis&quot;</span>, <span class="number">165</span>, <span class="number">25</span>)]</span><br></pre></td></tr></table></figure>

<p>按照之前的比较函数的想法，我们可以定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_greater</span>(<span class="params">x, y</span>):</span></span><br><span class="line">	<span class="keyword">return</span> x[<span class="number">1</span>] &gt; y[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>但是仔细想一下，这个比较函数似乎没什么意义，<strong>你好像是在教电脑如何比较两个整数谁更大</strong>。</p>
<blockquote>
<p>电脑：瞧谁不起，我自己不会比？</p>
</blockquote>
<p>在这种条件下，你会发现问题的关键不在于怎么去比较两个数据，而在于<strong>应该用两个数据的哪部分信息去比</strong>，这个用于比较的部分信息就是<code>key</code>。</p>
<h3 id="使用key函数的简单比较"><a href="#使用key函数的简单比较" class="headerlink" title="使用key函数的简单比较"></a>使用<code>key</code>函数的简单比较</h3><p>为了表示这部分信息，我们就应该定义一个关键词函数（这个函数就是<code>sorted</code>方法需要接受的参数），这个函数的作用就是<strong>将原始的数据转换成用于比较的数据</strong>。例如原始数据为一个三元组，我们只需要用其中第二个元素来进行比较，就可以写一个这样的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个参数<code>x</code>，这个参数的样子类似<code>(&quot;Dave&quot;, 180, 23)</code>，返回值为<code>x[1]</code>，即元组中的第二个元素，这个元素就是用来比较的东西。然后将这个函数传给<code>sorted</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(origin_list_2, key=key_func))</span><br><span class="line"><span class="comment"># 输出为：[(&#x27;Francis&#x27;, 165, 25), (&#x27;Alice&#x27;, 170, 20), (&#x27;Carol&#x27;, 170, 20), </span></span><br><span class="line"><span class="comment">#        (&#x27;Bob&#x27;, 176, 21), (&#x27;Eve&#x27;, 176, 19), (&#x27;Dave&#x27;, 180, 23)]</span></span><br></pre></td></tr></table></figure>

<p>可以看到就按照身高排好序了，并且由于我们没有对年龄排序，可以发现”Bob”和”Eve”并没有按照年龄从大到小排序。</p>
<p>当然，如果需要输出身高从大到小排序后的结果，可以怎么做呢？最直观的方法当然是设置参数<code>reverse=True</code>，但是能不能直接在<code>key_func</code>上做文章呢？</p>
<p>请看如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_func_v2</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> -x[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(origin_list_2, key=key_func_v2))</span><br><span class="line"><span class="comment"># 输出为：[(&#x27;Dave&#x27;, 180, 23), (&#x27;Bob&#x27;, 176, 21), (&#x27;Eve&#x27;, 176, 19), (&#x27;Alice&#x27;, 170, 20), </span></span><br><span class="line"><span class="comment">#        (&#x27;Carol&#x27;, 170, 20), (&#x27;Francis&#x27;, 165, 25)]</span></span><br></pre></td></tr></table></figure>

<p>可以发现，我们略微调整一下<code>key</code>函数，就可以将身高从大到小排序了。如何实现的呢？</p>
<p>首先，我们知道，<code>sorted()</code>方法默认是按照<strong>升序</strong>排列，而<code>key</code>函数指定了用什么样的值进行排序，在代码的第二行我们返回了<code>-x[1]</code>，即身高的相反数，那么第3行的效果就是将身高的相反数按照升序排列……不就是将身高按照降序排列嘛！</p>
<h3 id="使用key函数进行多条件比较"><a href="#使用key函数进行多条件比较" class="headerlink" title="使用key函数进行多条件比较"></a>使用<code>key</code>函数进行多条件比较</h3><p>下面回到我们一开始的问题：</p>
<blockquote>
<p>有一些人，已知他们的身高和年龄，请将他们按照以下规则排序：</p>
<ol>
<li>身高从高到低排序</li>
<li>相同身高的人中，年龄大的在前面</li>
</ol>
</blockquote>
<p>之前我们对这个问题的解法是，定义一个比较函数进行比较，那么能不能使用定义<code>key</code>函数的方法进行比较呢？答案是肯定的！</p>
<p>类似这样的”先比较x，如果相等再比较y，如果相等再比较z……”的问题，本质上其实是一个字典序排序问题（可以自行了解一下）。我们只需要将<code>key_func</code>的返回值作一点修改就行了。例如，我们需要先按照身高排序，身高大的优先，然后再按照年龄排序，年龄大的优先，那么就可以定义如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_func_v3</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x[<span class="number">1</span>], x[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>可见，我们此时返回的是一个元组，<strong>返回的元组的意义是，先比较元组的第一个元素，如果第一个元素相等，则再比较第二个元素，以此类推……你想要多少个都行</strong>。这里我们返回的元组是<code>(x[1], x[2])</code>，根据我们定义的数据的含义，元组的第一项就是身高，第二项就是年龄，当你这样去定义一个<code>key</code>函数的时候，就表示你需要先按照身高从大到小排序，再按照年龄从大到小排序。测试如下（<strong>再强调一遍，默认是升序，你现在应该能理解为什么输出是这样的</strong>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(origin_list_2, key=key_func_v3))</span><br><span class="line"><span class="comment"># 输出为：[(&#x27;Francis&#x27;, 165, 25), (&#x27;Alice&#x27;, 170, 20), (&#x27;Carol&#x27;, 170, 20), </span></span><br><span class="line"><span class="comment">#        (&#x27;Eve&#x27;, 176, 19), (&#x27;Bob&#x27;, 176, 21), (&#x27;Dave&#x27;, 180, 23)]</span></span><br></pre></td></tr></table></figure>

<p>那么问题来了，如果我们希望身高<strong>从大到小</strong>排序，身高相同时年龄<strong>从小到大</strong>排序怎么办？</p>
<p>结合一下上两个例子，不难写出如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_func_v4</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x[<span class="number">1</span>], -x[<span class="number">2</span>]) <span class="comment"># 注意这里第二个元素加了一个负号</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(origin_list_2, key=key_func_v4))</span><br><span class="line"><span class="comment"># 输出为：[(&#x27;Francis&#x27;, 165, 25), (&#x27;Alice&#x27;, 170, 20), (&#x27;Carol&#x27;, 170, 20), </span></span><br><span class="line"><span class="comment">#        (&#x27;Bob&#x27;, 176, 21), (&#x27;Eve&#x27;, 176, 19), (&#x27;Dave&#x27;, 180, 23)]</span></span><br></pre></td></tr></table></figure>

<p>仔细看这个代码，你应该逐渐理解一切.jpg。</p>
<p>思考：下面这个<code>key</code>函数是在用什么标准排序呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_func_v4</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h1 id="对字典元素进行“排序”"><a href="#对字典元素进行“排序”" class="headerlink" title="对字典元素进行“排序”"></a>对字典元素进行“排序”</h1><p>对字典元素排序的问题是一个必须要掌握的问题，我们用老师的示例再来看一遍这个问题。</p>
<p>有一个字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;zhang&quot;</span>:<span class="number">18</span>, <span class="string">&quot;li&quot;</span>:<span class="number">19</span>, <span class="string">&quot;wang&quot;</span>:<span class="number">20</span>, <span class="string">&quot;zhao&quot;</span>:<span class="number">17</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在想对这个字典排序按照年龄大小进行排序（请注意一个问题，字典本身是无序的，说是字典排序，其实就是把字典元素转成列表后进行排序），应该怎么做呢？</p>
<p>首先，字典本身不是<code>iterable</code> ，我们需要先将字典元素提取为列表，即使用<code>d.items()</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(d.items())</span><br><span class="line"><span class="comment"># dict_items([(&#x27;zhang&#x27;, 18), (&#x27;li&#x27;, 19), (&#x27;wang&#x27;, 20), (&#x27;zhao&#x27;, 17)])</span></span><br></pre></td></tr></table></figure>

<p>注意，从输出结果可以看出，这其实并不是一个列表，而是一个<code>dict_items</code>对象，但是这个对象是<code>iterable</code>的，可以用来遍历，所以可以用来排序。且从这个形式可以看出，其实和列表是类似的，可以不用在意那些细节了。</p>
<p>观察结果可知，这个列表是一个二元元组的列表，元组的第一个元素是字典中的<code>key</code>，第二个元素为字典中的<code>value</code>（权当复习了）。如果要按照第二个元素排序，则只需要写一个用来提取第二个元素的<code>key_func</code>即可，使用函数（而不是<code>lambda</code>表达式）的写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(d.items(), key=key_func, reverse=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 输出为：[(&#x27;wang&#x27;, 20), (&#x27;li&#x27;, 19), (&#x27;zhang&#x27;, 18), (&#x27;zhao&#x27;, 17)]</span></span><br></pre></td></tr></table></figure>

<p>当然，可以使用<code>lambda</code>表达式直接写成如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>], reverse=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 输出为：[(&#x27;wang&#x27;, 20), (&#x27;li&#x27;, 19), (&#x27;zhang&#x27;, 18), (&#x27;zhao&#x27;, 17)]</span></span><br></pre></td></tr></table></figure>

<p>其中<code>lambda item:item[1]</code>和以函数的形式写出的<code>key_func</code>效果作用和效果都是相同的。</p>
]]></content>
      <categories>
        <category>计算概论C</category>
      </categories>
      <tags>
        <tag>计算概论C</tag>
        <tag>计算概论C专题</tag>
      </tags>
  </entry>
</search>
