<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《操作系统》xv6阅读报告之进程模型</title>
    <url>/2021/04/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本次XV6源码阅读主要关注XV6中的进程模型的实现，包括XV6中的PCB（进程控制块）结构、进程常用方法的实现、系统对进程的调度等。与该功能实现有关的<strong>主要</strong>代码文件以及该文件的主要内容如下表格所示。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>proc.h</code></td>
<td>主要声明了三个<code>struct</code>:<code>cpu</code>,<code>context</code>,<code>proc</code>，分别是内核中的CPU、上下文以及我们重点关注的PCB信息，除此之外还定义了一个枚举型，定义了xv6中进程的可能状态</td>
</tr>
<tr>
<td><code>proc.c</code></td>
<td>声明了进程表的数据结构<code>ptable</code>以及与进程有关的核心函数，在本次报告中会对这些函数详细解读</td>
</tr>
<tr>
<td><code>vm.c</code></td>
<td>实现了一些与虚拟内存有关的函数，其中与进程有关的部分包括为内核和用户分配内存，切换到当前进程页面的<code>switchuvm()</code>，切换到内核页面的<code>switchkvm()</code>，以及用于拷贝父进程空间到子进程空间的<code>copyuvm()</code>等</td>
</tr>
<tr>
<td><code>swtch.S</code></td>
<td>用汇编实现的一个用于切换上下文的函数</td>
</tr>
<tr>
<td><code>kalloc.c</code></td>
<td>主要实现了用于分配和释放物理内存的<code>kalloc()</code>以及<code>kfree()</code></td>
</tr>
</tbody></table>
<p>除此之外，还有定义了一些数据结构的其他头文件，这里不特别列出，在用到的时候会说明。在本次报告中，我们主要关注进程相关的内容，即<code>proc.h</code>和<code>proc.c</code>这两个文件中的内容。</p>
<h2 id="核心代码解读"><a href="#核心代码解读" class="headerlink" title="核心代码解读"></a>核心代码解读</h2><h3 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a><code>proc.h</code></h3><p>在<code>proc.h</code>中，定义了以下数据：</p>
<ol>
<li><p><code>struct cpu</code>：这是CPU在呢何种的表示，在这个结构体中，会有一个指向<code>struct proc</code>的指针，用于表示当前正在执行的进程。此外还声明了一个<code>cpus</code>数组，用于支持多核处理器。</p>
</li>
<li><p><code>struct context</code>，表示上下文信息的一个结构体，如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>struct proc</code>，这是XV6中的进程控制块（PCB），如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;</span><br><span class="line">  <span class="keyword">char</span> *kstack;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *chan;</span><br><span class="line">  <span class="keyword">int</span> killed;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中各个数据项的详细意义如下：</p>
<table>
<thead>
<tr>
<th>数据</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>uint sz</code></td>
<td>进程内存空间的大小，单位为byte</td>
</tr>
<tr>
<td><code>pde_t* pgdir</code></td>
<td>指向进程的page table</td>
</tr>
<tr>
<td><code>char *kstack</code></td>
<td>指向内核栈的底部</td>
</tr>
<tr>
<td><code>enum procstate state</code></td>
<td>表示内核当前的状态，其中<code>enum procstate</code>是一个枚举结构，该枚举结构的定义为<code> enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</code>除了未使用（UNUSED）状态之外，进程共有五种状态。</td>
</tr>
<tr>
<td><code>volatile int pid</code></td>
<td>进程的id</td>
</tr>
<tr>
<td><code>struct proc *parent</code></td>
<td>指向父进程结构</td>
</tr>
<tr>
<td><code>struct trapframe *tf</code></td>
<td>指向一个中断帧（<code>trapframe</code>），这个结构体定义在<code>x86.h</code>这个文件中。当进程中断时，这个变量指向进程对应的中断帧。</td>
</tr>
<tr>
<td><code>struct context *context</code></td>
<td>切换进程时需要保存的上下文信息，其中<code>context</code>结构体已经在之前介绍过。</td>
</tr>
<tr>
<td><code>void *chan</code></td>
<td>这是一个与睡眠&amp;唤醒有关的数据，如果<code>chan</code>不为空，说明当前进程在<code>chan</code>上休眠，其中<code>chan</code>指的是一个等待队列（wait channel），在xv6中通过调用<code>sleep(chan)</code>来让进程在一个<code>chan</code>上休眠，用<code>wakeup(chan)</code>唤醒一个<code>chan</code>上的进程。</td>
</tr>
<tr>
<td><code>int killed</code></td>
<td>当<code>killed</code>不为0时，说明这个进程被杀死</td>
</tr>
<tr>
<td><code>struct file *ofile[NOFILE]</code></td>
<td>打开的文件，其中<code>struct file</code>是一个与文件有关的结构，这里暂且不详细说明。</td>
</tr>
<tr>
<td><code>struct inode *cwd</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td><code>char name[16]</code></td>
<td>进程的名称，debug用</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a><code>proc.c</code></h3><ol>
<li>在<code>proc.c</code>中，首先定义了一个重要的数据结构<code>ptable</code>，在xv6中，所有的进程信息都储存在这个结构中，这个结构体如下所示： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line">&#125; ptable;</span><br></pre></td></tr></table></figure>
 其中<code>spinloc lock</code>是一个互斥锁。<code>NPROC</code>为xv6中进程数量的上限，定义在<code>param.h</code>中，在xv6，进程的上限数为64。</li>
<li><code>allocproc()</code>函数，该函数的主要功能为在<code>ptable</code>中寻找一个空位，如果找到空位，则创建一个新的进程，并返回指向该进程的一个指针。<br> 该函数的声明为<code>static struct proc* allocproc(void)</code>。<br> 首先，函数遍历<code>ptable</code>中的<code>proc</code>数组，如果找到了一个空位置，则继续之后的工作，如果遍历全部之后还没有找到则直接返回0（NULL指针），代码如下所示。其中涉及到了<code>acquire()</code>和<code>release()</code>这两个与锁有关的函数，不是我们这一节的重点，暂时忽略。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* part 1 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">char</span> *sp;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED)</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">  <span class="built_in">release</span>(&amp;ptable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 在运行<code>goto found</code>之后，<code>p</code>即为一个状态为<code>UNUSED</code>的<code>proc</code>位置，将这个进程设置为<code>EMBRYO</code>状态，并且分配一个<code>pid</code>。其中<code>pid</code>由全局变量<code>nextpid</code>来分配，每分配一个新的<code>pid</code>，<code>nextpid</code>进行一次自增操作。该部分代码如下。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* part 2 */</span></span><br><span class="line">found:</span><br><span class="line">  p-&gt;state = EMBRYO;</span><br><span class="line">  p-&gt;pid = nextpid++;</span><br><span class="line">  <span class="built_in">release</span>(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 之后，需要为内核栈分配空间，需要调用定义在<code>kalloc.c</code>中的<code>kalloc()</code>函数，如果分配失败，该进程并不能顺利创建，则将进程的状态重新设置为<code>UNUSED</code>并返回空指针。代码如下。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>*</span></span><br><span class="line"><span class="class"><span class="title">allocproc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* part 3 */</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;kstack = <span class="built_in">kalloc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    p-&gt;state = UNUSED;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 之后，要对内核栈的其他部分进行建立，最终结构如下图所示（代码略）<br> <img src="/2021/04/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/f1-3.png" alt="figure1-3"><br> 在<code>allocproc()</code>中的最后一步为<code>p-&gt;context-&gt;eip = (uint)forkret</code>，使得新进程首先运行在<code>forkret</code>这个函数中，该函数中判断了是否为第一个创建的线程，之后就没有做别的事情，直接返回，返回后会进入<code>trapret</code>函数，<code>trapret</code>为从中断中返回的函数，该函数定义在<code>trapasm.S</code>中，用于恢复用户寄存器，恢复后使用<code>iret</code>从中断中返回。</li>
<li><code>userinit()</code>函数，用于创建第一个进程。在xv6中，<code>main()</code>函数初始化了一些设备和子系统后，会调用该函数创建第一个进程。在该函数中，首先调用<code>allocproc()</code>在分配一个进程并进行初始化，之后调用<code>setupkvm()</code>创建一个映射内核区的页表，这个函数设计虚拟内存相关知识，这里不详细说明。最终得到如下结构：<br> <img src="/2021/04/15/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/f1-1.png" alt="figure1-1"><br> 之后，<code>userinit()</code>函数将<code>trapframe</code>设为初始的用户模式状态，该部分代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; <span class="number">3</span>) | DPL_USER;</span><br><span class="line">  p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; <span class="number">3</span>) | DPL_USER;</span><br><span class="line">  p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;</span><br><span class="line">  p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;</span><br><span class="line">  p-&gt;tf-&gt;eflags = FL_IF;</span><br><span class="line">  p-&gt;tf-&gt;esp = PGSIZE;</span><br><span class="line">  p-&gt;tf-&gt;eip = <span class="number">0</span>; <span class="comment">// beginning of initcode.S</span></span><br></pre></td></tr></table></figure>
这里我们主要关注最后一行代码，将<code>trapframe</code>的<code>eip</code>设为了0，这是初始化代码<code>initcode.S</code>的入口<br> 最后，设置进程状态为<code>RUNNABLE</code>，正式开始工作。</li>
<li><code>fork()</code>函数。除了第一个进程之外，其他的进程都是由父进程调用<code>fork()</code>创建的，实现过程如下。<br> 首先，分配一个进程。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line"><span class="keyword">if</span> ((np = <span class="built_in">allocproc</span>()) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
 之后复制父进程的地址空间，如果失败（返回值不为0）则回收进程空间并返回一个错误。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((np-&gt;pgdir = <span class="built_in">copyuvm</span>(proc-&gt;pgdir, proc-&gt;sz)) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">kfree</span>(np-&gt;kstack);</span><br><span class="line">    np-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    np-&gt;state = UNUSED;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 如果成功，则复制以下信息</span></span><br><span class="line">np-&gt;sz = proc-&gt;sz;</span><br><span class="line">np-&gt;parent = proc;</span><br><span class="line">*np-&gt;tf = *proc-&gt;tf;</span><br></pre></td></tr></table></figure>
 之后，设置<code>np-&gt;tf-&gt;eax = 0</code>，当子进程从中断返回时，会返回0。<br> 然后子进程继承父进程打开的文件、当前工作目录以及父进程的名字。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;ofile[i])</span><br><span class="line">    np-&gt;ofile[i] = <span class="built_in">filedup</span>(proc-&gt;ofile[i]);</span><br><span class="line">np-&gt;cwd = <span class="built_in">idup</span>(proc-&gt;cwd);</span><br><span class="line">	</span><br><span class="line">pid = np-&gt;pid;</span><br><span class="line">np-&gt;state = RUNNABLE;</span><br><span class="line"><span class="built_in">safestrcpy</span>(np-&gt;name, proc-&gt;name, <span class="built_in"><span class="keyword">sizeof</span></span>(proc-&gt;name));</span><br></pre></td></tr></table></figure>
 最后，在父进程中返回<code>pid</code>，其中<code>pid</code>由<code>pid = np-&gt;pid</code>得到，是子进程的<code>pid</code>。</li>
<li><code>exit()</code>函数，退出当前进程，退出的进程会变为<code>ZOMBIE</code>状态直到它的父进程调用<code>wait()</code>来发现它已经退出。实现过程如下。<br> 首先关闭所有的文件，之后调用<code>wakeup1()</code>来唤醒父进程（这里会先加锁所以父进程并不会马上唤醒）。如果当前进程有子进程，则需要设置子进程的父进程变为<code>initproc</code>。最后，将当前进程的状态设置为<code>ZOMBIE</code>。</li>
<li><code>wait()</code>函数，等待一个子进程退出，返回子进程的<code>pid</code>，如果没有子进程则返回-1。实现流程如下。（代码略）<br> 遍历<code>ptable</code>中的<code>proc</code>数组，查找是否有子进程，如果有子进程则会将一个<code>havekids</code>标记为1，如果循环了一遍后<code>havekids</code>还是0，则直接返回-1。如果有子进程但是子进程未退出，则会调用<code>sleep()</code>来等待子进程唤醒。在发现处于<code>ZOMBIE</code>状态的子进程之后会释放子进程空间的使用，将这个进程块的状态设置为<code>UNUSED</code>，最后返回子进程的<code>pid</code>。</li>
<li><code>scheduler()</code>函数，该函数会被每个CPU都调用，该函数会遍历进程表，找到一个状态为<code>RUNNABLE</code>的进程来执行，如果没找到则会把当前CPU的<code>proc</code>（表示当前CPU正在执行的进程）设为空指针。其核心代码如下 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;state != RUNNABLE)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  proc = p;</span><br><span class="line">  <span class="built_in">switchuvm</span>(p);</span><br><span class="line">  p-&gt;state = RUNNING;</span><br><span class="line">  <span class="built_in">swtch</span>(&amp;cpu-&gt;scheduler, proc-&gt;context);</span><br><span class="line">  <span class="built_in">switchkvm</span>();</span><br><span class="line">  proc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 当找到一个处于<code>RUNNABLE</code>状态的进程后，会调用三个重要的函数<code>switchuvm()</code>,<code>swtch()</code>以及<code>switchkvm()</code>。其中<code>switchuvm()</code>会根据<code>proc</code>结构中的<code>pgdir</code>来找到当前进程需要使用的页表，并进行切换。<code>swtch</code>是一个使用汇编编写的函数，在<code>swtch.S</code>中编写，用于保存当前进程的上下文，然后返回到要切换的进程的上下文（<code>cpu-&gt;scheduler</code>）中。<code>switchkvm()</code>用于切换到内核页表。 在xv6中的实现里，这个调度函数采用了最简单的实现方法：直接遍历进程数组寻找，在真实的操作系统中往往会采用更复杂的调度算法来获得更好的体验。</li>
</ol>
<h2 id="总结及收获"><a href="#总结及收获" class="headerlink" title="总结及收获"></a>总结及收获</h2><p>略</p>
]]></content>
      <categories>
        <category>课程作业</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>《操作系统》xv6阅读报告之进程调度</title>
    <url>/2021/04/14/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8Bxv6%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本次XV6源码阅读，主要是在上次阅读<strong>进程模型</strong>的基础上，进一步研究xv6中在进程<strong>调度</strong>方面的细节。主要需要阅读的代码文件和上次类似，有以下这些：<br>| 文件名     | 主要功能                                                     |<br>| ———- | ———————————————————— |<br>| <code>proc.h</code>   | 主要声明了三个<code>struct</code>:<code>cpu</code>,<code>context</code>,<code>proc</code>，分别是内核中的CPU、上下文以及我们重点关注的PCB信息，除此之外还定义了一个枚举型，定义了xv6中进程的可能状态 |<br>| <code>proc.c</code>   | 声明了进程表的数据结构<code>ptable</code>以及与进程有关的核心函数，在本次报告中会对这些函数详细解读 |<br>| <code>vm.c</code>     | 实现了一些与虚拟内存有关的函数，其中与进程有关的部分包括为内核和用户分配内存，切换到当前进程页面的<code>switchuvm()</code>，切换到内核页面的<code>switchkvm()</code>，以及用于拷贝父进程空间到子进程空间的<code>copyuvm()</code>等 |<br>| <code>swtch.S</code>  | 用汇编实现的一个用于切换上下文的函数                         |<br>| <code>kalloc.c</code> | 主要实现了用于分配和释放物理内存的<code>kalloc()</code>以及<code>kfree()</code>    |<br>除此之外，还有定义了一些数据结构的其他头文件，这里不特别列出，在用到的时候会说明。在本次报告中，我们主要关注进程相关的内容，即<code>proc.h</code>和<code>proc.c</code>这两个文件中的内容。</p>
<h2 id="核心代码解读"><a href="#核心代码解读" class="headerlink" title="核心代码解读"></a>核心代码解读</h2><h3 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a><code>proc.h</code></h3><p>该部分说明直接复用上次阅读报告，因为定义的结构体之后要用到。<br>在<code>proc.h</code>中，定义了以下数据：</p>
<ol>
<li><p><code>struct cpu</code>：这是CPU在呢何种的表示，在这个结构体中，会有一个指向<code>struct proc</code>的指针，用于表示当前正在执行的进程。此外还声明了一个<code>cpus</code>数组，用于支持多核处理器。</p>
</li>
<li><p><code>struct context</code>，表示上下文信息的一个结构体，如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>struct proc</code>，这是XV6中的进程控制块（PCB），如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;</span><br><span class="line">  <span class="keyword">char</span> *kstack;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *chan;</span><br><span class="line">  <span class="keyword">int</span> killed;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中各个数据项的详细意义如下：</p>
<table>
<thead>
<tr>
<th>数据</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>uint sz</code></td>
<td>进程内存空间的大小，单位为byte</td>
</tr>
<tr>
<td><code>pde_t* pgdir</code></td>
<td>指向进程的page table</td>
</tr>
<tr>
<td><code>char *kstack</code></td>
<td>指向内核栈的底部</td>
</tr>
<tr>
<td><code>enum procstate state</code></td>
<td>表示内核当前的状态，其中<code>enum procstate</code>是一个枚举结构，该枚举结构的定义为<code> enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</code>除了未使用（UNUSED）状态之外，进程共有五种状态。</td>
</tr>
<tr>
<td><code>volatile int pid</code></td>
<td>进程的id</td>
</tr>
<tr>
<td><code>struct proc *parent</code></td>
<td>指向父进程结构</td>
</tr>
<tr>
<td><code>struct trapframe *tf</code></td>
<td>指向一个中断帧（<code>trapframe</code>），这个结构体定义在<code>x86.h</code>这个文件中。当进程中断时，这个变量指向进程对应的中断帧。</td>
</tr>
<tr>
<td><code>struct context *context</code></td>
<td>切换进程时需要保存的上下文信息，其中<code>context</code>结构体已经在之前介绍过。</td>
</tr>
<tr>
<td><code>void *chan</code></td>
<td>这是一个与睡眠&amp;唤醒有关的数据，如果<code>chan</code>不为空，说明当前进程在<code>chan</code>上休眠，其中<code>chan</code>指的是一个等待队列（wait channel），在xv6中通过调用<code>sleep(chan)</code>来让进程在一个<code>chan</code>上休眠，用<code>wakeup(chan)</code>唤醒一个<code>chan</code>上的进程。</td>
</tr>
<tr>
<td><code>int killed</code></td>
<td>当<code>killed</code>不为0时，说明这个进程被杀死</td>
</tr>
<tr>
<td><code>struct file *ofile[NOFILE]</code></td>
<td>打开的文件，其中<code>struct file</code>是一个与文件有关的结构，这里暂且不详细说明。</td>
</tr>
<tr>
<td><code>struct inode *cwd</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td><code>char name[16]</code></td>
<td>进程的名称，debug用</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a><code>proc.c</code></h3><ul>
<li><code>scheduler()</code>函数<br>  在<code>proc.c</code>中，实现了一个跟进程调度有关的函数<code>scheduler()</code>，该函数不接受参数也没有返回值，作用为遍历进程表，找到一个状态为<code>RUNNABLE</code>的进程来执行。代码如下：      <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (p-&gt;state != RUNNABLE)</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	  proc = p;</span><br><span class="line">	  switchuvm(p);</span><br><span class="line">	  p-&gt;state = RUNNING;</span><br><span class="line">	  swtch(&amp;cpu-&gt;scheduler, proc-&gt;context);</span><br><span class="line">	  switchkvm();</span><br><span class="line">	  proc = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
  其中<code>ptable.proc</code>是一个储存着所有<code>proc</code>结构体的数组，该函数从数组的第一个元素开始进行遍历（在实际的工作中其实是从前一次切换的位置开始遍历，这个我们之后说明），当找到一个状态为<code>RUNNABLE</code>的进程之后，会调用三个重要的函数<code>switchuvm()</code>,<code>swtch()</code>以及<code>switchkvm()</code>。其中<code>switchuvm()</code>会根据<code>proc</code>结构中的<code>pgdir</code>来找到当前进程需要使用的页表，并进行切换。<code>swtch</code>是一个使用汇编编写的函数，在<code>swtch.S</code>中编写，用于保存当前进程的上下文，然后返回到要切换的进程的上下文（<code>cpu-&gt;scheduler</code>）中。<code>switchkvm()</code>用于切换到内核页表。由代码可见，在xv6的实现里，这个调度函数采用了最简单的实现方法：通过遍历储存着所有进程<code>proc</code>结构的数组来寻找下一个可以开始工作的进程。<br>  在上次报告中，对该部分的解读到此为止，这次我们继续探寻一些细节。</li>
<li><code>yield()</code>函数<br>  <code>yield()</code>函数代码如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;ptable.lock); <span class="comment">//DOC: yieldlock</span></span><br><span class="line">  proc-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  可见其中的逻辑很简单，主要就是将当前进程的状态设置为<code>RUNNABLE</code>，然后再调用<code>sched()</code>函数</li>
<li><code>sched()</code>函数  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> intena;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!holding(&amp;ptable.lock))</span><br><span class="line">    panic(<span class="string">&quot;sched ptable.lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cpu-&gt;ncli != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (readeflags() &amp; FL_IF)</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">  intena = cpu-&gt;intena;</span><br><span class="line">  swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</span><br><span class="line">  cpu-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在该函数中，最重要的一句为<code>swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</code>即进行上下文切换的语句，关于这里的工作逻辑，在我们分析完下面的代码后进行说明。</li>
</ul>
<h3 id="swtch-S"><a href="#swtch-S" class="headerlink" title="swtch.S"></a><code>swtch.S</code></h3><p>在这个汇编文件中，实现了一个由汇编写的函数<code>swtch</code>，它是在进程调度时用于保存上下文的核心内容，代码如下</p>
<ul>
<li><code>swtch()</code>函数  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  movl 4(%esp), %eax</span><br><span class="line">  movl 8(%esp), %edx</span><br><span class="line"></span><br><span class="line">  # Save old callee-save registers</span><br><span class="line">  pushl %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  pushl %esi</span><br><span class="line">  pushl %edi</span><br><span class="line"></span><br><span class="line">  # Switch stacks</span><br><span class="line">  movl %esp, (%eax)</span><br><span class="line">  movl %edx, %esp</span><br><span class="line"></span><br><span class="line">  # Load new callee-save registers</span><br><span class="line">  popl %edi</span><br><span class="line">  popl %esi</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
  代码的注释中指出，<code>swtch</code>函数接受两个参数:<code>void swtch(struct context **old, struct context *new);</code>，注意两个参数的类型不一样，前一个参数是一个指向<code>context</code>结构指针的指针。<br>  首先3,4两行代码取出了传给<code>swtch</code>的两个参数，其中<code>%eax</code>为<code>old</code>，<code>%edx</code>为<code>new</code>。<br>  7,8,9,10四行则按顺序保存四个寄存器，在保存之前，<code>%esp</code>中存储的内容为返回地址，之后按顺序压入<code>ebp</code>,<code>ebx</code>,<code>esi</code>,<code>edi</code>。操作完成后栈中结构如下：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地址高位</span><br><span class="line">	返回地址</span><br><span class="line">	ebp</span><br><span class="line">	ebx</span><br><span class="line">	esi</span><br><span class="line">	edi # 现在的栈顶</span><br><span class="line">地址地位</span><br></pre></td></tr></table></figure>
  可以发现这个结构对应的正是一个<code>context</code>结构，所以此时的<code>%esp</code>可以看作是一个指向一个<code>context</code>结构的指针。之后第13行，将这个指针保存在第一个参数指向的地方（第一个参数是一个指向<code>context</code>指针的指针），这里的实现相对我们做过的Nachos来说不太一样，所以后面会给出整理后的具体调度流程。  之后，第14行将用第二个参数替换栈顶，然后在17-20行恢复寄存器数据，此时的返回地址是要切换到的线程的返回地址，返回后另一个线程直接开始工作。</li>
</ul>
<h3 id="调度逻辑总结"><a href="#调度逻辑总结" class="headerlink" title="调度逻辑总结"></a>调度逻辑总结</h3><p>由于xv6是一个支持多核心的操作系统，在xv6中，每个核心都会有自己的一套上下文以及调度器。在上一部分的代码实现中可以看到，<code>swtch</code>函数的一个参数为<code>cpu-&gt;scheduler</code>。这是<code>struct cpu</code>中的一个成员变量，类型为<code>context *</code>，事实上，它指向的是调度器的上下文。</p>
<p>在xv6工作时，每个CPU会启动一个调度器，在<code>main()</code>函数中调用，调度器的完整代码如下所示：</p>
<ul>
<li><code>scheduler()</code>完整代码  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里是我们之前解读过的核心代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可见，这个调度器是不会返回的，一直在循环。代码在调度器中运行时，其实是<code>main()</code>函数的上下文，可以认为是主进程的上下文中（之后称为调度器上下文），然后从这里切换到其他的进程。所以在<code>scheduler()</code>中调用<code>swtch</code>函数时第一个参数为<code>&amp;cpu-&gt;scheduler</code>，将当前调度器进程的上下文保存在<code>cpu-&gt;scheduler</code>中，然后切换到目标进程的上下文中。</p>
<p>在当前工作的进程<code>yield()</code>时调用了<code>sched()</code>函数，而在这个函数中，我们可以看到调用<code>swtch</code>的函数为<code>swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);</code>实际上当一个进程<code>yield()</code>之后，是先回到调度器进程中，之后再由调度器进程负责找到下一个进程再切换一次，实际上是两次切换，切换到目标进程的工作是由调度器进程完成的。</p>
<h2 id="总结及收获"><a href="#总结及收获" class="headerlink" title="总结及收获"></a>总结及收获</h2><p>懂得都懂</p>
]]></content>
      <categories>
        <category>课程作业</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 2 ipv4分组收发</title>
    <url>/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-2-ipv4%E5%88%86%E7%BB%84%E6%94%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>根据计算机网络实验系统所提供的上下层接口函数和协议中分组收发的主要流程，独立设计实现一个简单的IPv4分组收发模块。要求实现的主要功能包括：</p>
<ol>
<li>IPv4分组的基本接收处理；</li>
<li>IPv4分组的封装发送。</li>
</ol>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>在本次实验中，最重要的部分是理解IPv4的头部结构，应当使用合适的方法对头部信息进行读取、校验、写入等操作。在实验指导书中给出的头部信息结构如下：</p>
<p><img src="/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-2-ipv4%E5%88%86%E7%BB%84%E6%94%B6%E5%8F%91/lab2-1.png" alt="lab2-1"></p>
<p>在接收时，使用合适的方法读取并验证头部信息，写入时用合适的方法写入正确的值，就是我们本次实验需要完成的内容。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><h4 id="IPv4分组的基本接收处理"><a href="#IPv4分组的基本接收处理" class="headerlink" title="IPv4分组的基本接收处理"></a>IPv4分组的基本接收处理</h4><p>正如之前所述，本次实验的关键在于读取头部信息，首先我们对头部信息进行读取，代码如下：</p>
<ul>
<li><p>读取头部信息</p>
<p>在本次实验中，只需读取下列我们感兴趣的信息即可。需要注意的是在读取超过1个字节的值时需要将网络序转换为本地序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取头部信息</span></span><br><span class="line"><span class="keyword">int</span> version = pBuffer[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> headLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>; <span class="comment">//0b00001111</span></span><br><span class="line"><span class="keyword">int</span> timeToLive = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> headCheckSum = ntohs(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line"><span class="keyword">int</span> dstAddr = ntohl(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>判断<code>timeToLive</code>值是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TTL值出错</span></span><br><span class="line"><span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_TTL_ERROR);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断IP版本号是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IP版本号错</span></span><br><span class="line"><span class="keyword">if</span> (version != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_VERSION_ERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断头部长度是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部长度错</span></span><br><span class="line"><span class="keyword">if</span> (headLength &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_HEADLEN_ERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验<code>checksum</code>，直接把头部的长度按照规则相加，和应该为<code>0xffff</code></p>
<p>  这里要注意的细节是，由于我们用<code>unsigned short</code>进行计算，而<code>checksum</code>的规则要求如果相加大于<code>0xffff</code>，需要把高16位的值加到低16位上，因此，每次相加前我们需要判断相加是否大于<code>0xffff</code>，需要采用判断<code>0xffff - sum</code>和<code>temp</code>的关系来实现来避免溢出，如代码的11行所示。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验checksum</span></span><br><span class="line"><span class="comment">// sum为计算的和</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// temp用于辅助计算</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每16字节为一组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">    temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">    <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果和不为0xffff，说明出错</span></span><br><span class="line"><span class="keyword">if</span> (sum != <span class="number">0xffff</span>) &#123;</span><br><span class="line">    <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果经过上面的操作都没有返回，说明该分组没有问题，可以接受，如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成功接受</span></span><br><span class="line">ip_SendtoUp(pBuffer, length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="IPv4分组的封装发送"><a href="#IPv4分组的封装发送" class="headerlink" title="IPv4分组的封装发送"></a>IPv4分组的封装发送</h4><p>该部分主要需要实现对头部信息的写入。流程如下：</p>
<ul>
<li><p>首先，需要创建一个完整的分组结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配空间，头需要20字节，内容字节数为len</span></span><br><span class="line"><span class="keyword">char</span> *IPBuffer = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>((<span class="number">20</span> + len) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="comment">// 将数据初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(IPBuffer, <span class="number">0</span>, len + <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>填充<code>Version</code>和<code>IHL</code>，内容为<code>0b10001001=0x45</code>，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IPBuffer[<span class="number">0</span>] = <span class="number">0x45</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>计算分组长度，转换成网络序后填写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//分组总长度，需要转换成网络序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> totalLength = htons(len + <span class="number">20</span>); </span><br><span class="line"><span class="comment">// 填写total_length信息</span></span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">2</span>, &amp;totalLength, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>填写<code>timeToLive</code>和<code>protocol</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IPBuffer[<span class="number">8</span>] = timeToLive;        <span class="comment">//timeToLive</span></span><br><span class="line">IPBuffer[<span class="number">9</span>] = protocol;   <span class="comment">//协议</span></span><br></pre></td></tr></table></figure></li>
<li><p>填写源地址和目标地址，注意转换成网络序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> src = htonl(srcAddr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dst = htonl(dstAddr);</span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">12</span>, &amp;src, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">16</span>, &amp;dst, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>计算<code>checksum</code>，由于我们在刚开始就使用<code>memset</code>将所有位初始化为了<code>0</code>，因此我们在这里可以用和第一个实验一模一样的代码来计算<code>checksum</code>，放置<code>checksum</code>的字节现在值为0，并不会影响计算，之后，用<code>0xffff</code>减去我们计算的结果就是应该填充的<code>checksum</code>。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算sum</span></span><br><span class="line"><span class="comment">// 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码为求和，以下为填充。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="number">0</span>;</span><br><span class="line">headCheckSum = htons(<span class="number">0xffff</span> - sum);</span><br><span class="line"><span class="comment">// 填充checksum值</span></span><br><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>最后，将携带的信息填充并发送即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(IPBuffer + <span class="number">20</span>, pBuffer, len);</span><br><span class="line">ip_SendtoLower(IPBuffer, len + <span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，实验代码结束，在测试平台上测试通过。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>本次实验较为顺利，没遇到太多的疑难问题。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码即为将实验细节部分的代码拼凑而成，但还是在这里给出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysInclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ip_DiscardPkt</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ip_SendtoLower</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ip_SendtoUp</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部一共有20个字节，以字节为单位结构如下:</span></span><br><span class="line"><span class="comment">// pBuffer[0] 高4位为Version 低4位为IHL</span></span><br><span class="line"><span class="comment">// pBuffer[1] 高6位为TypeOfService</span></span><br><span class="line"><span class="comment">// pBuffer[2]-pBuffer[3] Total Length</span></span><br><span class="line"><span class="comment">// pBuffer[4]-pBuffer[5] Identification</span></span><br><span class="line"><span class="comment">// pBuffer[6]的第6位第7位分别为MF和DF</span></span><br><span class="line"><span class="comment">// pBuffer[6]的前5位+pBuffer[7] 为Fragment offset</span></span><br><span class="line"><span class="comment">// pBuffer[8] : time to live</span></span><br><span class="line"><span class="comment">// pBuffer[9]: Protocol</span></span><br><span class="line"><span class="comment">// pBuffer[10]-pBuffer[11] Header checksum</span></span><br><span class="line"><span class="comment">// pBuffer[12]-pBuffer[15] source address </span></span><br><span class="line"><span class="comment">// pBuffer[16]-pBuffer[19] destination address</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_ip_recv</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取头部信息</span></span><br><span class="line">    <span class="keyword">int</span> version = pBuffer[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> headLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>; <span class="comment">//0b00001111</span></span><br><span class="line">    <span class="keyword">int</span> timeToLive = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> headCheckSum = <span class="built_in">ntohs</span>(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">int</span> dstAddr = <span class="built_in">ntohl</span>(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TTL值出错</span></span><br><span class="line">    <span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_TTL_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IP版本号错</span></span><br><span class="line">    <span class="keyword">if</span> (version != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_VERSION_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头部长度错</span></span><br><span class="line">    <span class="keyword">if</span> (headLength &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_HEADLEN_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目的地址错</span></span><br><span class="line">    <span class="keyword">if</span> (dstAddr != <span class="built_in">getIpv4Address</span>() &amp;&amp; dstAddr != <span class="number">0xffff</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_DESTINATION_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验checksum</span></span><br><span class="line">    <span class="comment">// sum为计算的和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// temp用于辅助计算</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每16字节为一组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">        temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) pBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">        <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">0xffff</span>) &#123;</span><br><span class="line">        <span class="built_in">ip_DiscardPkt</span>(pBuffer, STUD_IP_TEST_CHECKSUM_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功接受</span></span><br><span class="line">    <span class="built_in">ip_SendtoUp</span>(pBuffer, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_ip_Upsend</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr, byte protocol, byte timeToLive)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配空间，头需要20字节，内容字节数为len</span></span><br><span class="line">    <span class="keyword">char</span> *IPBuffer = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>((<span class="number">20</span> + len) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memset</span>(IPBuffer, <span class="number">0</span>, len + <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// pBuffer[0] 高4位为Version 低4位为IHL</span></span><br><span class="line">    <span class="comment">// 0b10001001</span></span><br><span class="line">    IPBuffer[<span class="number">0</span>] = <span class="number">0x45</span>;</span><br><span class="line">    <span class="comment">//分组总长度，需要转换成网络序</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> totalLength = <span class="built_in">htons</span>(len + <span class="number">20</span>); </span><br><span class="line">    <span class="comment">// 填写total_length信息</span></span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">2</span>, &amp;totalLength, <span class="number">2</span>);</span><br><span class="line">    IPBuffer[<span class="number">8</span>] = timeToLive;        <span class="comment">//timeToLive</span></span><br><span class="line">    IPBuffer[<span class="number">9</span>] = protocol;   <span class="comment">//协议</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> src = <span class="built_in">htonl</span>(srcAddr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dst = <span class="built_in">htonl</span>(dstAddr);</span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">12</span>, &amp;src, <span class="number">4</span>);   <span class="comment">//源与目的IP地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">16</span>, &amp;dst, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算checksum</span></span><br><span class="line">    <span class="comment">// 此时原本的header checksum部分为0，因为已经memset过了，所以直接加就可以</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) IPBuffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="number">0</span>;</span><br><span class="line">    headCheckSum = <span class="built_in">htons</span>(<span class="number">0xffff</span> - sum);</span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(IPBuffer + <span class="number">20</span>, pBuffer, len);</span><br><span class="line">    <span class="built_in">ip_SendtoLower</span>(IPBuffer, len + <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 3 ipv4路由</title>
    <url>/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-3-ipv4%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>在前面IPv4分组收发实验的基础上，增加分组转发功能。具体来说，对于每一个到达本机的IPv4分组，根据其目的IPv4地址决定分组的处理行为，对该分组进行如下的几类操作：</p>
<ol>
<li>向上层协议上交目的地址为本机地址的分组；</li>
<li>根据路由查找结果，丢弃查不到路由的分组；</li>
<li> 根据路由查找结果，向相应接口转发不是本机接收的分组。</li>
</ol>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>在本次实验中，我们首先需要定义一个路由表结构，并且实现一个增加路由的函数。在实验指导书中给出了一种路由结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stud_route_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dest;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> masklen;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop;</span><br><span class="line">&#125; stud_route_msg;</span><br></pre></td></tr></table></figure>

<p>其中，<code>masklen</code>应当指子网掩码中从左往右数的1的个数而不是子网掩码的内容，这一点需要注意。因此，我们的路由表也仿照这样的结构设计即可。需要注意的是，由上层传来的路由表的数据是网络序，为了方便我们转换成本地序处理。</p>
<p>在接受分组时，首先应该查看目的地址是否为本机，然后查看该分组是否已经失效（例如<code>TTL</code>值小于等于0），然后在路由表中查找，查找不到则丢弃。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><h4 id="路由表的设计"><a href="#路由表的设计" class="headerlink" title="路由表的设计"></a>路由表的设计</h4><p>路由表设计如下，和实验系统中的设计一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RouteInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dest;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> masklen;   <span class="comment">// 子网掩码的长度（1的个数）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop;</span><br><span class="line">    RouteInfo(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dest = d, masklen = m, nexthop = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;RouteInfo&gt; routeTable;   <span class="comment">//路由表</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化路由表函数"><a href="#初始化路由表函数" class="headerlink" title="初始化路由表函数"></a>初始化路由表函数</h4><p>初始化时清空路由表即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化路由表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_Route_Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    routeTable.clear();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加一条新的路由信息"><a href="#增加一条新的路由信息" class="headerlink" title="增加一条新的路由信息"></a>增加一条新的路由信息</h4><p>注意需要将网络序转换为本地序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加路由</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_route_add</span><span class="params">(stud_route_msg *proute)</span> </span>&#123;</span><br><span class="line">    <span class="function">RouteInfo <span class="title">t</span><span class="params">(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop))</span></span>;</span><br><span class="line">    routeTable.push_back(t);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系统处理收到的IP分组的函数"><a href="#系统处理收到的IP分组的函数" class="headerlink" title="系统处理收到的IP分组的函数"></a>系统处理收到的IP分组的函数</h4><ul>
<li><p>首先，读取我们感兴趣的头部信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部长度</span></span><br><span class="line">  <span class="keyword">int</span> headerLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>;</span><br><span class="line">  <span class="comment">// timeToLive</span></span><br><span class="line">  <span class="keyword">int</span> timeToLive = (<span class="keyword">int</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line">  <span class="comment">// 头部校验和</span></span><br><span class="line">  <span class="keyword">int</span> IHL = ntohs(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line">  <span class="comment">// 目的IP地址</span></span><br><span class="line">  <span class="keyword">int</span> dstAddr = ntohl(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>判断<code>timeToLive</code>值是否出错</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断timeToLive</span></span><br><span class="line"><span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">     <span class="built_in">fwd_DiscardPkt</span>(pBuffer,STUD_FORWARD_TEST_TTLERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历路由表进行查找</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历路由表</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;RouteInfo&gt;::iterator it = routeTable.<span class="built_in">begin</span>(); it != routeTable.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">// 计算子网掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subnetMask = <span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - it-&gt;masklen);</span><br><span class="line">    <span class="comment">// 查找路由表</span></span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了应该更新新的head信息</span></span><br><span class="line">        <span class="comment">// 构造新的ipv4头部内容</span></span><br><span class="line">        <span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, pBuffer, length);</span><br><span class="line">        <span class="comment">// timeToLive-1</span></span><br><span class="line">        buffer[<span class="number">8</span>]--;</span><br><span class="line">        <span class="comment">// 清空checksum，便于之后求和计算</span></span><br><span class="line">        buffer[<span class="number">10</span>] = buffer[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算校验和</span></span><br><span class="line">        <span class="comment">// sum为计算的和</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// temp用于辅助计算</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每16字节为一组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">            temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">            <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算并填充checkNum</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="built_in">htons</span>(<span class="number">0xffff</span> - sum);</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 发送信息  </span></span><br><span class="line">        <span class="built_in">fwd_SendtoLower</span>(buffer, length, it-&gt;nexthop);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果遍历之后还没返回，说明没找到路由信息，丢弃。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有路由器</span></span><br><span class="line"><span class="built_in">fwd_DiscardPkt</span>(pBuffer, STUD_FORWARD_TEST_NOROUTE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，实验代码结束，在测试平台上测试通过。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>本次实验较为顺利，没遇到太多的疑难问题。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码在这里给出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysInclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="comment">// system support</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fwd_LocalRcv</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fwd_SendtoLower</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length, <span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fwd_DiscardPkt</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RouteInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dest;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> masklen;   <span class="comment">// 子网掩码的长度（1的个数）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nexthop;</span><br><span class="line">    <span class="built_in">RouteInfo</span>(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dest = d, masklen = m, nexthop = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;RouteInfo&gt; routeTable;   <span class="comment">//路由表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化路由表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_Route_Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    routeTable.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加路由</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_route_add</span><span class="params">(stud_route_msg *proute)</span> </span>&#123;</span><br><span class="line">    <span class="function">RouteInfo <span class="title">t</span><span class="params">(ntohl(proute-&gt;dest), proute-&gt;masklen, ntohl(proute-&gt;nexthop))</span></span>;</span><br><span class="line">    routeTable.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_fwd_deal</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头部长度</span></span><br><span class="line">    <span class="keyword">int</span> headerLength = pBuffer[<span class="number">0</span>] &amp; <span class="number">0xf</span>;</span><br><span class="line">    <span class="comment">// timeToLive</span></span><br><span class="line">    <span class="keyword">int</span> timeToLive = (<span class="keyword">int</span>) pBuffer[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 头部校验和</span></span><br><span class="line">    <span class="keyword">int</span> Head_Checksum = <span class="built_in">ntohs</span>(*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (pBuffer + <span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 目的IP地址</span></span><br><span class="line">    <span class="keyword">int</span> dstAddr = <span class="built_in">ntohl</span>(*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (pBuffer + <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果本机地址等于目的IP地址， 接收</span></span><br><span class="line">    <span class="keyword">if</span> (dstAddr == <span class="built_in">getIpv4Address</span>()) &#123;</span><br><span class="line">        <span class="built_in">fwd_LocalRcv</span>(pBuffer, length);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断timeToLive</span></span><br><span class="line">    <span class="keyword">if</span> (timeToLive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误</span></span><br><span class="line">        <span class="built_in">fwd_DiscardPkt</span>(pBuffer, STUD_FORWARD_TEST_TTLERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历路由表</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;RouteInfo&gt;::iterator it = routeTable.<span class="built_in">begin</span>(); it != routeTable.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="comment">// 计算子网掩码</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> subnetMask = <span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - it-&gt;masklen);</span><br><span class="line">        <span class="comment">// 查找路由表</span></span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;dest &amp; subnetMask) == (dstAddr &amp; subnetMask)) &#123;</span><br><span class="line">            <span class="comment">// 构造新的ipv4头部内容</span></span><br><span class="line">            <span class="keyword">char</span> *buffer = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">            <span class="built_in">memcpy</span>(buffer, pBuffer, length);</span><br><span class="line">            <span class="comment">// timeToLive-1</span></span><br><span class="line">            buffer[<span class="number">8</span>]--;</span><br><span class="line">            <span class="comment">// 清空checksum</span></span><br><span class="line">            buffer[<span class="number">10</span>] = buffer[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算校验和</span></span><br><span class="line">            <span class="comment">// sum为计算的和</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// temp用于辅助计算</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每16字节为一组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headLength * <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 注意字节序，前8位为高位，后8位为低位</span></span><br><span class="line">                temp = (((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + ((<span class="keyword">unsigned</span> <span class="keyword">char</span>) buffer[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 如果相加之后进1，将进的1位加上</span></span><br><span class="line">                <span class="number">0xffff</span> - sum &lt; temp ? sum = sum + temp + <span class="number">1</span> : sum = sum + temp;</span><br><span class="line">                <span class="comment">// if (0xffff - sum &lt; temp)</span></span><br><span class="line">                <span class="comment">//     sum = sum + temp + 1;</span></span><br><span class="line">                <span class="comment">// else</span></span><br><span class="line">                <span class="comment">//     sum = sum + temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> headCheckSum = <span class="built_in">htons</span>(<span class="number">0xffff</span> - sum);</span><br><span class="line">            <span class="built_in">memcpy</span>(buffer + <span class="number">10</span>, &amp;headCheckSum, <span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">fwd_SendtoLower</span>(buffer, length, it-&gt;nexthop);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有路由器</span></span><br><span class="line">    <span class="built_in">fwd_DiscardPkt</span>(pBuffer, STUD_FORWARD_TEST_NOROUTE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ上的注意事项汇总 (21 fall)</title>
    <url>/2021/11/11/OJ%E4%B8%8A%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2338faec55ce5337de4b4546f7fc00cc8673da2398c92e85560159d9955b3d55">b1c8743748ae1f554aaae721c1205cc441f57087a8f982dede0aaaefeeadf341b7deec18777f3bb689e10fbb54111938a7d32a5ff85e36eea0e2ce5a775425afd9e0ba3be51a27ddb954a3072159c9d218994316e6e2c81ac986919257a8275f18c4248cc598e16064f9c0b56b324e7d3563e74015c7334fe351ba42945ed1bd9cf1397503d034a0b231ddf22da3377506ecc88e853b0310bd5fc83f0c0abda459f1ef95f54f7c7f3c505a022d5b3135e0fbca85e93ce1cffee444168a6765a444723a31ba103ea2e25666f8dd6f1e0eec7ed424ec6363d38d1bf1355d2506d85db248fee3c82b2183a823180409ef356bdea0f8935e3df5a156720fe69db65c161ff66a84a63ef4373b96396c8150d03b3f6e11bb0bf67eda358657020ab69541353be7a35c450559f5e45ec0c557f11fea913c1930546011d6d9335f19827bd1d542779da8d31900083d72f293ca95203e1273573dcb120e3ecb8dad3ef64fbc85d028c055c7d74045e0a19d34a80efcec0b456015cf6c06b9c1df126f833b3bae3bc1ca78968663b7850d6d3a1a423497398cc3ca5d97072f86f627b112810f4aba8a284881e30f769ff397580919f2872c6565f2d4a69170869b0af5246b9a6101b3d40337efb18501256ebe4d61e113f221ac0a7ff56807cd3e7145fb020fd6e22215cc3f04c2c5dcb7b3a2398431358e707af7502a6960dc4c917ad9e911e01926b8d58a5f80693f2fd4ebbeca0e32a0506a74eb89ba8df4c6a6c49085d13a8b784d18e0f5d54c44eff1bf3e6a62b1a2687daaee63cc7017676b902372cb1c8d602491a966ff794f2631c6a2c960b538c850c9f818a2f2cd3786b861d92be6ddbf91c5f8b07db994d83f4e4245261a1bfc6ed27e23a3e0987d56c116d48fa63c8419ad99559971f446182295d9c005ec0fca9f0be1c6798521af3b6c93a2831f6abce781f709d28345a4c574f711976a2c20c9cb1084cf118331452ce167832c5dfce38191e506087fe1e076c011b0a923a0136e0d6eed7ef61ffc2341f9b9d99d0b772746b27b2dcc1fbd6c9b06718e7f038023337ffb279c15c28ab7b90c7453e5102fb655bfd0dfaf393e2f037d4c3e3a5804ed848576a49519a1d71f1463b274da5a3746c85a5cb893179653e803578258806133643e2d9cb90043c4d1df33846f14d65401f5ae0d0e7c9a5001530fb8a80b2cf5832ea3de05faf08890db9325bff83e1861b79cd307167a182ce0401ec5e96fcb778b1febf529d8f009dd7e0967a0c14c729521e36a713abeb69f9c362b9b80620a4217be3ab357351f9e24dbbc680622d477808bd6535ec303b5bee1a0ab1a4141dc92794e0119fcbf94f8ebd37ae016880020ebd2cb238c559ea9a09f1d6a203a29e49724cedef43da759bc1b7cf09df1dca2c4888b8e0ed1fa95d6561f7635598ae9dad3521a5c9c038a9fa649d8ee51eab12320e7c781a3648a930c0d7278671a5eb74f0ef7bc21428d8dac54a2aee41ad02a62f5c657b709e5a88bedc95bdae919fc56739ffcb9ac8f1d51a212faab107a1022b329a0e29e7f89a1bde610e92a28a79f299c8815ff6ac389acd6dd6c3047f8b674503922500d51e3b865a578e3042096477e610e9fda448991e8b6a07dab5a9bc13efbf32a7ee0c39adc57c9e62a5134539423d588b0e6dceaea856fe5a63953e17fe81d2e0b933131c9477ced25991e36fea7818be794b6fe42136031d1da6893e6e90f0d5ab3836cb6695a3545b97f2fad9d8a68981bf9753db0b7bc37accacc46d9aa6f3df2eed55ef2f92aa7eabaa5a359e14531180bd94b51dadc8a83be42be09d29113d3b2073ac9a9d50ca09276d832aaad84681b0a5e94a6057e6e6f2805203609defaa567fe778911ac6b6ac71ce50e482cf9d05088ca3fc627ce6c1b9acd804805a36294d79029304153d55c1e519ffb43703bd73474538fa8dec19e8971beeb7395027a07b9b0997649d143d0f7ea6c2fc3fa7d6ca1354704b2d19f0882a6f5c7944a6270f11948926f2cd2a025a066c91602cb53d1d5d4ddd5e6332497499223c5de6802e24e733abaa3b4f324cf700a5d8fdb9f7d73c986e81035d9a11a2e887970b4706e679125f206d845f6b4769254164ac91ee17560903844c51231833df92e8e95d092cde2dcd6c3f57160495f747cd4502fc8c49b6307bb0ebbde566fbce5ba6478fb2c76652fbdc113a22b23409a4f7060ec150aa5bd2d019a04ad2f1a74439c686beb5ea292fb00e56abb87656c498794b45c124040b268fb74b7b63c4f2850d8e0bb53d93dd7646eef37cb4c144de0f8d3cb4c0dad05d8f9d34a8332a386455aeea854495ca50060842023cf7296a0bde4f4a07107140018f582a2b7d2160fd0e536f5f5d596c6b1ba24764fc71792caccf485699b1acd515b7e64d9e50d2db20ba224acb39b5c5fb49e92c585664b776c4ecb2c2fe758110fa4d86946b30181e5a578f177d8c26fc8d3c181327a8cbf9aaa12dd1a771484ec7e5cd16770d935ebe2c57df9fc9cb7269ed6187848839097f5923006c5cf926c45c8fb05d9ca877747b0b5b4a812921ce307896dc596513eec38bcfb02be070ce7706b1e166e88f874e391cb43d3ad9b89f3be3abade2e14f7a27f3c04e2dc570df4f7a0dafaa419c8cbb8b1641299dc98a44a613c1d80c6036893ed30684d51aefa3d71efa9c4f4508f1aa51a66f3e88e15ca0c3129184335a626408c33f7fbe7fb8194496f9d4caaf57b0815490fe2ec1dcac35748f066d84ee0c1ac5eff1534cbd3497013d454b73df34922e9adf751d2c46544f6920d86ff2b33284930ec839ea95bc2152658ec2012a3d4c99fabbdefc0242bc9902414fa32ac04243c4f5dbadb510e252c904533b2604eae1b5f58c05f5e7459a33de2b4d5b4e8c25c03dee921d2bd9930e19a437ca1ae009d2a09bceef21132840145de08fef1a931e2cc16fed91333398c6cdeb3bbc4058ebde8c36b03f2e61dd353e5d0e0b0889b220f615d312a94b03128b0408c92ca5f25ae2fca0230686c8d03abb1beece41e6a9325cf99548d1f1e756755fdc3efc8c785d0232b04714061e391ebb357ee3d8407a5c0a252906496e041f93b1b1adc15fe0e4a0b29ea2722baf2775f8c59dc5f463daaf3133cf75f8750dbfc64c331c5e043d67aeb20a369d73cc58b6d3cd73d6c2aa4ef2b7f9cc7d2f8c7df973b9953110790ab4ba06e4ca2030eb4e6cc5412b7a5a716dab891568c077e6bb56df979f2c694f1d0575b4e9b9048ea79272f6b70de114a8d7331308b040b598090d6f1fc6ba5276c95934e8017319149f5af28ad61bea0caa01fa8066a0ba797cf10ed71fd62c381b15c92508538eeb7c93fa9ae2d1f2a272efa0a4ce9ef80cd40980cd030510b086e32e8cb8e08e49b06b9589163ce1fa4f327edb7947aa8d732aecaebf6dde8dd871eb07539ad0c299982e42ae99f69bb1ecb5e7d44e3705f98fd079c3537edbc4fa15aafb88ee4dcf03430754f089aba9969edd89a6c2fc0a41032877569404e50abe3d5106434bef79fa6936aa999e0d1531050c7970a24b40439eb3a6e4455d177ff3376e5412838c4f6f42c4282c0168aacd746c67f8c8a2c2ae0aed2eb01f88d83e5007fae2c827bdbad493d134a51b11e7cb475359ffe5e2f579b7a0a1debebb063d6762b7fbd7a6ef08db0a7e94fcef61ad45c1b55fb4a5d804ffa95028325c583fd63f98f4ecbdbecf0a3fdc87b7861d888900ab3bd962843c7650c73ad53afd98eeefc5368edfd9c380a1e8c105eeba5d10b1fb5c4999c75c7e5a39c1349a8873303e9fe048f8d5e5ac2af533fad9ad773968d3262d9ee5b3ad69986a08bc2a4d387d603d708cead0774a2a8ca8f6c946b6ba9c97e8a1c511050fb092f792f5ee8e8a06e4a38fa8722cef0c2b131f9c063a11404dd1257a370c7f26de29e063ad77dd54a42cd56ca8fe941a82ff1aaf27dae10b7655efc75207185c6e7a504dfc1b9f1d8cf47a3510ceefeed213db0004569b7c0b9d83e21569569143089965189ba6f259b546aba5ae0aa347b1c988192b8ea47a4d1db02f57dc6a3a8858dc671a364b8a7119f2b2b7bcb3e1d452f72fef3ce2cd3bb3311c534808e2565e2ef318a4a0bc5dd75ac9bbd3e5342b69a46903589ad7ec4985c0adce0efb2b29fdbbe16387afd7dfb99b833e324db26af782ae3f64f07f65612356776035476a820a6adf483cbb4dc349b64816d484f97f1dfeeba6d952b2833a56dc135fa3b652b01f362f0f2ee0a6531c10333d7c3bc9c1a135ce169e9f274d5562182d3c0b31ac6590578e3598cd5d459f4ca7fcbf60f524f4df43910f244278000874fb0e2314de18f81429934a211395a113e8c8496c8acaf1e915619a56d73b9036aba342abe82fc3a9207f0b06f3f91af527f09c1c8cd0b27c4599d6eb73e84b22767dd47b7a5fb6f154d20b8ef2da9d61e0e6573524d3167082a51a1c0564c81edaa40e2c7d090b15ab8271d39578c5580c071708b9bba5a01a4deab2f5d65ff3d0463a23392a413ba6223f04d78c1a0a7767b0424b2feba548b4a1843030659020bf85433ca02b06bdcc9a982848e639f96b134753312f77b0e2ebd3d2e39245e1f819d60ce24f78db1a9397d9fb387492955f029af0519f531c1b001ee240d0bbb3fc796fcf3c92f7176867b6885b522af39b6fa8a905bf7d82109107b21ae4f9fc2b00dea7d6d49253caf56d32f7ecdaafb6d976db0d34b0d28d96d2a46f1f4ceba065cd5850e7687454bcedbd3ff7d20ad190f7f1af0b2ff0108ace64f27a100d2c71778f814a55506b0ed476ca54d6be661ffc23c4645babbce618462e2a9160fd37e1c57687d489a8b9ec2960b92da848e2e9117c24aae2225215e801c8f6f41f2cafdd6a5b72061a2171ac9a9776d3c3e7748f5bff2253d030e1f28b132abac1682c6d8d544b6b11957f67a9bdd705c593e6df7ae808a9db60f6147cba1968167b1e0bb85b05e772e430b837f2f9d37da42e59d75a1368ce38e93e8f6954d6b6dd15ddd31a328943691b4d9bb96557dfa2dba6146086bc63bfd97adba447c63ba643635e2964e3058e96923c36686ccc4db2493fed6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave"></span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算概论C</category>
        <category>计算概论C(21 fall)</category>
      </categories>
      <tags>
        <tag>计算概论C(21 fall)</tag>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算概论C》上机作业要求 (21 fall)</title>
    <url>/2021/11/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%A6%82%E8%AE%BAC%E3%80%8B%E4%B8%8A%E6%9C%BA%E4%BD%9C%E4%B8%9A%E8%A6%81%E6%B1%82-2021-11-11/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6f5a59f2c9f2307e404a42eb70700727138d5f1bacaaed42d807d74e51cc6c25">b1c8743748ae1f554aaae721c1205cc441f57087a8f982dede0aaaefeeadf341a182aeacf2928d7272a20afd7f0b09cf73cd6ee1ee950a2f651a4751fbfdc6eaf916b4255be299d50eb2ba0ab8710aeddc6566e998c2aafede15e08057faf8b5366dbe103e3cb7edb58c3ec099f2391c16d0b7c863dc672f3108da96343563da8ee4984c9ff2b1d1e9fcdf5c1beaddb7a3976accaf1c0f091af5aa306ac612d9dc8aa11d6a62b7ad79e6a84d634f34e7e22c7a66df9112596f503dbc07786ab2b2bf4077662c28dfb8dfbbaad2a2c76ed729ac95281344b6f469ed3769e4bdce893c30d43c6739eb9083a44b5e021e396ce23ef543c9c41835135570b1d2fe6be8d03782313e254ad580c872a8d47ca7af65029dd7af3edd7900f2119f1a7a8b7793e7e0a2e0ccce62fbd67dc7b6f3c80579a0a27ab78adee7c349844ad9bc4c71902231485f67a2241e4f207cb2c5fea97d05010173c763b0831f41138e9406b448b92b7b44a7a36d43e2393673f78d9632f6d43d6ef2d877c617aec8b79d726a0ce6267b9357d3254397472c0d9a4b9c3c0e20f435b8f1ae5683046d54fb53f9bbfc7d4133e3126f1b6662aa1e062f77678a6c1b84a2c7d1cf448bbde5e8c9af2acb131da5c6292f2db135ff028ca03738a58e5875884d04f2e53bb9dcb3569dccef19d370da52a5fc18a11378632b0000ee82e8debd17cc2e53dd76d77bd631b02ccb6edb9b833ecfa226aab681c7a56466a104120ecd5b36ef9420a737ca295230b301c1f8ae1b5b8f226aea07cd00d7585643fe1bff00df55e6d76d111ce3bf5a6db0af8f642ad10900243c2d71c224a9a2fa591e84a6ac7f060c9a1fe99ccf902c9936e1501f2eb2fbb7446b08abf1fe637ec5738edc3d7d93ed3fcc2f094fc37705ea3df91c91f370547c65ff1693c89416a5b087ef6eca606da5a69748f8794cad690349cc482bc258c10c36239be8a7b9ac590925b94dc6982c27aeaae818b5031e6ed065d91747d2aa3020868568c15948e905c74ed0bc4625bbf92cbc8aceddd3c7922c09a012ad95d00ef062caa0d93314cf4421531d821865fade4eb3da4f0dc0ab3e256b986404820e0df6f4980662ba295dc7beec2f066094ca5faa287586640312e438393f9f4d39b406eaa20b6810965b902e4cced5edc5fdd69e1a121b9df587cc94e55ea6bbb59a4c853a073f06ac0ab32ecd9dac9e709acfae784ce0e0d00064f4fe9893542e584804e8e4d871a83b91df4a786ad97e54d7f6237843b9c497e9089cc72b7dd516bfa7988f10974283a0fc24e1614c1ffb1add2649eb2c4b5e82b505f12412520170e08d3222dc8706d4a92308ac1f896da0901451227003fd04163f392ee13af96e56bbba8d20891912ed512cf226414664ec46eb06ac1a79248abd5c6c5526c40e19d457067de5f790139efa401e4228e827725b508f2cb38775cc232144a237b76188ac1509861e7304e93d2785899665a91b9f8e7a2cd7f4386dc1d8524a1f4a64a47806cfc326d1f498b140d5f049fafa3ce62e71d045b58aa1dea24be984cdee08494f660984475eadea5d23874eb3c8552bd72422379042789202d41d1d69d89ab0dc9cddc230941720109cfb687426e389aa4cb43464d9fcd955663027ac80f76a31415173f97e6474951679468a409c1dd89be69abe74db06b4c37883e4c141d6d5d99c1d5a8b3c4b114038f4477fb2673082a4b6f48e30dad900e450c3ecf562f5ad41fde6366a8f4d1d727b7c4f13ad45cccfa37719349c0ad1eb69c0e6a2c5a6ba20f3344bb61768aa5735612780f7dfda3af9ee829e7aa5a6936339e0e07879fef1cce55748e8fca4ce66271292ff19e2091d6a23ebae15aab79e277ebe65676f99309cf1f62d8d818ffc5a1b8991162cb49a96d4b0de3763ff21707c849975cebc7f4fbb45ca579cf3b29a3dafaf22369f3674265365721b60892fa296ee166e3e6e25b854d9c11238acb5e609d7f0788ce322cee74f37011fa03083fb909d914d317816a06a9f6d93ba86c1ca83b7129765a5640c9bc841885bbe653ee1e36ec9c4eed516fa39820d15139429daadb5d1b37230d4f1d5febd58cf6b850979a91ea4f60e75735b87f8b85a68d6a3aa0e2af157fbf1f5c3323ef04ffb7b0e4566ff5d1cfaf58b9e7b68b65cfe163156f864fc2f25fcd85acf611affd5b0b5aad24cf3a8c42d85d991c9819f89d5a300ee59f3b0c9c4ec6269d10ef547b87f6ba8ba9392be24dfdfbbb150c268676ebd4997a1585b3f354172df88ed3c517144aad64ae0aa33522cc60863c9dfae12ff5a7a219e4a2433e7f1b0ba7e6b404af2a1e74c20c112dbb340faafa9fc33ae31982169d369bea832f7a546bb37516c3e3d179aba3d1a096edf60e6d2412b47fd85ae926d71686f69c98e3a11005490b6f9b48aa4d8d4c227b6ceee6c0890a0743e337707797322e42232d23bf68d223454804457a209b98462010d215d6769a9695d777156285013032d1ab264d2a6cb9b31958d044a0edabe0aceaef7de8e7521f78c55864ff3bc3aa905ac2dd919e157b57de7ee7fa9533be6b701e89d359e66aa12a07d1d1ac6152972e8cbd29415e9966eab13edd857cdb012b4f7fbaede7bad92b69a2d420211fadaf378531c2812cfa809f69c963fb7879e856e27be0ab9989c116e13aee5bfdd3bdca30ef47c77e5e669328c30badeb1f316afbf21e8449eaaaae5ed8e5070559a3aabfc4e88e9e9b4f89f4ed177d5a18ed5761636687555094e1a8884b8b7954c4586099dcacc22891d0ec73b55a7eb147654abb95d86524e7efe977a0de12f4c5983b99b811f9c1d8ae605584df195740374a72bbb7d5be090109941fdf3dfe95e8e4c8ff702f68432882d18347f969e2ceaea89825ecb4e15ad50571f2730ede232a67d84f5dac96016a0d2482994327e5220e87fe954bbbefdfef4a7d5eea88627b96801e7249be6c8b04f5a92c10a2dc9d357eb8be7cd8930fcfe6e6c45bf4b78f9aa0edbc3440924e284b6cc0d6188891d7e90c1411df25236a902267fa5f85cbd27b1cd1a8f06705cdf907e4df816a2744e0a086362b3ce689394ea986be6c73840036268f862bc698ebf05b815e6bac75a3fc08fe40b521dccd59d98a3e1dbf871d417f8701af0266f62ad52d32e9db642386873cf38fcadae1f83de4a235d1fc1dbe03bb686b8df67c5c3d8a1c9c3ef7b8f44df2049213e760df1d14e344f27725433e13a675bac39fdd4c57b28b9ad6e86d31d2e5efc5d649dc3b28ecc4f3707d70fc0c9c1a4cea1260fc5ec953da9898dfe66da9b296702952b16238d34602ff8f2108e0f2ef6a1274c3e1bce81dcd3a796b1201620ba0869fb644d8185ad41e2753934b95f6d8455a9c5aa36ff99a7b6a5a532ff90396f6bcb5e7edacd6a662779e97c9553f3bcef033e560b99fe6392bb36323dc72dc21120bc1fd5591bf4ec48a1a20fd81f504d9e95cd1f6f2d424eafff79404b143adc48d283f855a47b5168dc1b7794081d5f385b552a0d8fd612ad6206cc587dc8a00d53aa5f956499b38da58c5134fa6f2a8aac3d1aebe73659c436bc138e5dc430bb48e31b6634675975db6e301e82d1b20c280ed61ee199e9cdb26ca84665f1a69e72171eb65ea147bfbbeed8deeeef28ee32c4b813f5f51ebc6759149c0820cf7266f4ccb8dc17e5b7c82512e11db8073398aef5c118a104fa8c1a7352d71229a57be8decee0f95c0e043f8258fbff77dbdddda50a70838188e7afaaa1a2b340d63e6d9582d37de3da42dff5d7facd38fdaca743b7d11cd5e1ab25a4f26cd080c5c5957281c41e15726fde0c5fe56bd1d04518eaa62e583859c2dda1f133ea337a9af474045b7c337c98fb315e36f67b40ed0006c571e2bd3e25e1c0b6c53b5337cec478f83f162a30002f1819f94bded5a27eb145cc8ee08a7bec5e23f39429d85de0153fc947f8d8d100a390566017823e1f547db3b1163ef7db6b9802aa3e9ebb25cbe4600dca243dd74c96f875d11a4a13e89bd3354b361451daa04ad3693c93b5a0513e3870ea9e207a5a5694818045100cfb6f45866267e80f5b6631c7cbfae2ba54153bb10200bac5934f8486661941b7b6458b56d432a620bcfef9a951dc812b0a57fc004ed1b1cb466c30bb06d57f49654ce038f04d04a29e9b62ed81f1f6ddb104488d636bcfd9f2bcfa7a983d5c0ccb87ff83665ad1ac819ef082e6ae9cbb2326cdfdd60228391ce0240dbe09d33727bb5d5ff2ef6a631b31499b970d10d5bfa4e77de69d0a8dbe36fa0504d287d56bb6d36a94d9b28a5c84fb757620a51e2a14a66454b7ef164c72bfa56ff13c480d941b59917d8103c1757303d2fa182c290e38aaf775e9f67d0158de8877ad6847ac9f0c4c456cab7d6d40f5da13893a3a0a1ea5018751682ed1cd93a6ee5e05c2b95126fb95d8bf31a0a4e2eefa4ae49a9d64335773f3e299bb92add987039586928d5ef3d42ed2ea3808dc3e36d2405a9263254ac74ca45a4d17fca9d0e0e8fd482f7dac8fbd929b11a934ca63f6fa32dc1b943a1eb0515cb8d06a7c03487860f62dcd001ef4072063095d4be2f6f0c93aee0b7bc921f38824ce092f9a0cb1e7cb61bd6c519ab392c499ec9bb0c6593f405fe028789c3e38e3fb05114e246bf427248570a6bce78d5af1093e518a9a035763c9211bc68acb9a59e267dbaa84579bac1b097cfcee5d66a672caea943a3284e7cd97e3f7e2e7d70a5770a4b8bbcd19a75e7e521f488d6b892abad29d9338678e56c56a0edb38b8ddf01ba7f10b1dbfdb0f7660eecf2eca7a7c791c02547a4caf3395b5aba59cff0e642947107f227af8662ac1fcbd3a3612c1414284e0c5cb71ce79ba6ef40f9f3866d90c41390d6e2939ab34c85ada63157b6eacb5798c81918aac62a0dbc63f641c68da871255f088f76f8220117b4b9de19e044e9cb3a9e9ae3cf78636a16760aef81935c74ca0e81378475fbb3f3b37390045536b8057fd1244ed3e1dd808020f8d65b2affb05ef80ac2afe430fe74bf4ff05d9a8c379a288fb0ee48a861535336c729b5c1ef1e708e4991d31b9489a5ea363c4474c4681e3a0b1f8aafb2535f146ccb365e197f70e7079713887493b0fa84f0f632d4ee5f5494755496ed8af00bef7f5aec3256550b1c717dd6b932a7096a43b3b484afbf7e0d32aa6942b1d5969f0d9f8f195b1d7771a01d8b95bc40c8128117c6f4a1d7b8bace72f004a721f9470d3313f730732853ec41bf82dd72066b748d6a358d49044a93310fe986ae49f2ec651ecbfa9a9e2234b177c6e8ccfe4be4d77e7fc0830ed722fc9ffc27834403732e9234212c1591ae268a3272763dd5b201edbc83c0b35fb421e552085aae2466c63e02d0e44f63fcb10848a99ac8177fb247f969eb1badb92be57fac0e9abc402e85fd29311bd90913c1ca7986dfbb3cc278fad6de77bad81c657b6c010571484536103eeae8f4ddc6870977ee055442b995258d514d245e2d06885f0f55c2d9366e0f73d7ff3aa34f384d2dcfd07f08b85101bacc9c731a12725b3d097c4f3b98ecabae3630daea20f802b3c70a281f8cd56d8b7f1829d98087bd80cc2d8911a3033b29627b16bc82c23d224edca2151190cefed303c4590b7201249e1e152219e4ad6d8c795ee18f7d174174844c930b724ff4b1203de88298b93198f6f852426899496eeb5dec2e52defd68e1a8d3ede6f8757aa3c538798e29ab714bef7fc14c5ae01b9b7b59dc58ebf37f4fd796335a41436926771e8972e7044a6c7c30fbfcab85792205a0d5d060d8b6d528e44e0ec73aa7fd760bb34e45423f8e1d80e7385742cb09b1088bd8cd859be6a51e4ad5cee652cb88f142da0da4f93958ab78f5ff616b12ce0b16b2ef84d3fad03ed77214848f2b4a46fd17bfbe7a2ba0d50de3e3648976cf10640b0cc9bf5cd02813b633a31c03f72b87dfd20c5705d397bf199d9ee9bb57455712356db02aaeb94149cecb8b1c8991b64c578f20647463686ba94f0946e0457ffa33a820a5aadf496a001853cc1c08d69a00fa87b17be57c2ada10331cbd1ec70e3037f91ce179e1edea9b72501ea0ded0d1a96696f013321bae9a0b50b3afd3f1b395dc20da1a40a0f064629c9781a0fa45983415a00dba9ffd114c263a6c9e0766364dee898cbc25c51a5dd1227ffb2814e0e1ff14dbf5a0b46f4dd242548a411102c456395b2189951a9d4a47968b09c4c981c85520a9cc7c3b23f1e9321f05af266b3480abd1b3cc1788582cc9ed29f1cf30a5d3910925be170155860a65c0cf9b172b414439e9498e17464239add2ff36d6ce012a7aabe7652848255319177b1e0d08adc28a6f5ec5d357d75bbb17ecf986358465f29fca66e028b8ad11a4214d8a97b0e6808b873068aa7f88c056237029c0e78c58d34fe994447908fb1c6c8e48c393679d9b13069fad6734d838ccad5d9c89f5237d1ba009776cc9114f4a5eb666ae75ab9f86e1310bc00f6ba7ee02ea644c282e2edc48369d03a2e557befa8581326c96d109b6b36990a55db97043915f9bc9f4b17409dbe023129b0a724a338aa859fe12f165e4e4e0a7fa87edfecd6168acd7a051d7bf26e09381430ed91cfb1e832458f2332e778821b7432f99845638be65eace5422f9a40c9f9c986dc4887851f10f0c48456dec791b50bdf6f56d12110738c799501186fa80aa1e62ac00c2ba27b2ce8016a15cd888b88c9cde57acb076b16b3e7e08685a609ad2b619f26076c8014cfb0bd211a3d10aee80e3485e1344d74f41d6b06c29557baa14349606abf6c6bc0fc9890b813a75b21357c76b57763e388a8fbc622b5dcd8364e9ba3da19dc3b9e6802d324f03b460633a5df53c73bab76bdab934f3bed4ec5785e4c7756138503f4690e5f223b9217f941a7e45585947f3a96fc6ae24f451451ab14fe4b3112d041a56977b32b74ad53617830390e8d7289e2181ef80cbf7d8aff34dabf20cc10eaecef3647d0af4135309e7970b995ea7edf3f3a9e55b2dae32c9e7a72c1d36383303d37bd8b7ca96c9b93615bfba73252fc1a80090f781ef5c122eae6ca4b008012996d4b4c6295e1cc2b28888f2893fa61cf0c4146bd5328be23c1385bf7d04d6c8a1fa3ceb3f41772879b8e55ccbfd8eb295190fea5b291fee27a07783f2c02c878d051bd4407bdd3865b9e26c911c1006ba5885fd9f19c1e6ae6bf2602b636f08618caa6e1549ed9f51077b5fcf4cae6b835606c4ead6a3dec6b3447dd8cf7585df8a5ab5521dcc5d1f12bf8953b1c76db5aecebef2de9a0b348e17c4e6c908c8ed7ec87dd642d2f518b0b14a98634e831f2b810ecfcac0dc77bacac87f6be338dc9c07aaf54c58feeb67f0c9b539cc0cfc03c319d880572bead21cf4869c474239833be6fef2c9c296c3268eecc6c98f963ae0bd43bb6a8567dfe1144d1104200171238a198b50d6e48d3abd854e8d1d7873a40b7eef39df7244535c0515e40169a5331be5990c4adbb4f4cdff65c4243752c0885dfd16a9c218aabdce4e1880910e48f8c2ba404198f01e432fe548a0f0fc6ec26315c215398d5d126cb645e1cc858d0ea8cf33ad273ee8176caf71176b96f1c20783f9c61902c9102e758350b8da241ec888bd2db10f05d4b281611bc0096e078082396ca816cea820f5768e4e80a60260a50b912628f388ef9ef0b59d26bc51f3c4e22ceefc73b05712f866e3df76de37bc50230513d43265f5b1b2d098cef8ed856e76bfa67edcc5469c99e696e114652869aa070f1d4e1be7c0b15bbf266cba0196cf289981213da8bac79d3d90a8f319210ef8bc65fa0687f0fefdcae4129778d9b39f1a5b4c44153f7b190308886a209ce0b8ff3a36763248002bdb0c45ab184cc2632e300b640ee6637af3778c818f1fe94720709954b17697198f1cd262742f58550ebc0334e6f01b565c14bb20b5e2aba39720890172a22bd867dd85d1724241bc96e6a3ab09b78da003e0c12d204761fda340ccefb118972f204015229dc2f9e7824180f688324bd9b741c3fad4959dc5581fe59006686cbc9cb80dfc9e8770d2b894fba527d4b23c1496531301ef6fdb4f8dd764e8b5a6446f9a8aba80b1fbf7f02754928fafefbe578948f873e1a71028d9195eab42baf80b423b4ad6884edf18ec57eae96681b3fb013796e3d3675f7ee5676df1fbfba2e32ca04b84766a57a14f02befbf7c576eece526c8ed2cfc184c02c0d668f1b14632629365cebaea15a69390ecba0674e22af71e58447ac4d9f1f8675c7c24edc4b1fe0a5cd63d50e8df1bf6a61786f1021afbbf704d122c54f4334920ddd77ed471538382008447eb08777f33bbbe186fb1e0c1bf3dccd737bc9e161edf7a32591de11ef80090a41282953c29376f33108559911df6a298973a17fe043498660f80f0d70065074e7b6f03d080bc22716d9c005b726116146ce26ca25679fb7be4de71cae6049dde7f2ffeca3be29df1cfcc0da47980a65581f15c7e849fee664591f6c1323437d784e1f6bb64e495adafbed99bc135b9cabd968aba0cd09776c2397d203d5885077a8a710211f295468507fbe02ab0bf627a24dbc1d784b95ed883290b484d29f1d8b36a067bf2b223fee057effe6f6d19e8e0c57d9ea6155e62aa2e5cb57ddaaacab62cb76edb85e6b6d43b27793276e19fc835747245c7775c3cf034642f66683c67b9fe2b9d70270946f8018f1348f58b481d818bfabd72b2ccec45ecf5d70101287cd17c78af656f5381dd5456f49180788417f2080ce504d509ca34ac5bc165ecfde4884ffce2dfb3ecce943e4fd120d800a0737ef6d17027f6d85686bf9f674ea9dcaa6bc92b89f2a3c43d75600ba05207123a2d3c4d89d08c998a5d1c6fc31ccb79b658ee0a5af000f4a696417472c25971aed63391558747943907a415eff6ba6eb0a0d9eb741eb87424e9be708c0b4587a4a884c4903acc80f9d9b52dc053eed1704f479b8d691cfb2ddab237f6e58704a2f5fda2b7918e0ff415f5786471af97ceabfc6dd1d8dbfa8752ca69b9c27d38c4bfc94bfcf5b7cbb59189e40aba854329a65fce2709c30491ea6e2854f7e92fc58d5df26a46770b798d273c0f4e691b6f51c5f616d781ab7cf842e73417819d455a1beee6619de6ab245dff2d8f60722fd94cc339c82c90f011fd1e21e4461b6eb219c0acbf5b52763572968daf273b18d2a68ecf7b858b35db83319b0d9da64ad5596de7ca08186160035f20b74533e1faedc57a650f84ffad2aa5b5725ede647af09d3700764f63ce7de9c30477271f3dab912669fcc130f40b1513bf220a84f64319a3fdef66cc51158107bac55aa08f9442f0ec3c0972d9155ed9f1621534c32d7295754438d5ee969c3e96fddd155ae2a573c1af74eb9d7a990b0658c11d1ced68772e2d2cf35a04a46c700e0bee99a816e61a556c9a86731bbd1c97289b819011f6ca103c3b7cdb0c2679b64571bcbcf4b8779b799ef2fffc66272ed45ed0bbf724c0ef7840b39a4c9a2a2e22eee2674de59f8605e608ea9941e73b578a50f551f41009f333767fbda1179cdd056081cb50e4b6ef8ae142c559fca73258e1ff698aa327da9bd8850125c83c940c1b097dfd0ebc7b32365154fcce70f1f07aee3af23eeafaec724a38e0ce2a76a32f3a340845044de2b5fb9933ad6781e958668280d1d3577df6d90c3d0e80356c0e1efc5c3a5575b7961ec24f4048e2b2d691363e3b6ca08237348f48c196ce84807b21a27f7ccacee00d1d7e58222c1d47a89e0253c9f402a78dc12f4d18b488986d1dbcc286f7a7d93597eb294bb1d664414d56acf3a2ea8ccea27600243f39c6e5d279fbdad2f138e2a3e8657cb4ad1c50967f91f25c441d1c389ccd8db163b45b87a4c84e8df7d143c0e5d399c7bb6b911b2128809172f1c277b8306ea6ce8115ddb4f658da5f534f4b8eecda218ece821e251101a40d8828b396ab38c3b6e3adb54a843c74d687f03642338c7845978236cc2145477c1799516d47a0be3c21b30a988f240978e0a55c94d33dc003ec7fdfac3d916fc7e8fc8f8fd327442efb0b0bc29c92e18a17e5729640d2a0ab9a7a14bef1af2599ac508bbc68a16cf47e65c5ec111dc14fae6ec564273b2bdd5317ac1a6f19873573ca1191669c0c228f715f56657aba2499a824b9ad70b8c608a5d38d38045b16a9c7d31c8c41a984e4ca80e350b67c6e7463677c3b95678640cffa44b7d32a5807f49fc8e7fe126068c645d83cd30268bc75cac5a91247b034cef17d921d150f0e1c4ab23c9297a983b714b5f331ecdffe08b6bc98c7fba2a3a2a4a3f2002dd023fe7c52f16e3a53ef4636d906fddd32ba22d25d14efdceb314294787cd58a7d004eabff27bfe1b5bec71c290720b2cbabee5129d293a5467a6c36f4680278bfe237c60d335c4db0682cd7fca392f41937e1033bff7449498cf2e2d993626a11a3ffa303cd6088d2c9df4ec5c10dfa5c4a6d0fa897ee3b4917614aca3a777d75eeaefa5991c5065548595e60dc5d4f906e248d5d87aa351310d1c56236714e86d1afe5cd26461bc79191879c89f10f2a00a75d14e855463aaa23bd6a35034d23d2547e835940de99a262d369595d4ec14ec54ccc792e000e74cb6fd8338d31408e6696a11ab82e75ee8f59c363aedb55aaa4acb43a222a55b1d66fe801f1c59f93071b8f06decf94136ac136c1ac2eaf48d2afdf7819894ac54d189fe7810ddf0de738b6ea275a2641428c91a3eb5fc8501dca43a127d0dcfa563170ebb90d3ba4b74c76a3db6439e901ff79443dfea1968f521eb1d2768ef9be3fb6135e5b88960098a1731effd1eecc1d901f48223697a546c3114ac94a0e97de5567a9fcdd6305968a5ae44e04dd5173054e31a022682847fc1c7ebc4921dc7de94eabccb3a6aad3ea8b8d8546d8f97dd3c1c21f0f13f91ce1af5eb6a04fafc6c0a56990599c485817d201c319275e405476bbe7a7942dc00d387c474da160fc7015a760c81ba4b11016e514eee5210c93fbd183ad2cd3eea22ac8f3097ec49349ee6ae4e20e55c8ad4a9afc0a3d349f983f5f8876282ecf30b8e7f17d3fb6a88cf5834e5c7ae198e7843640aab03038363cf5d5d7a1555adc799ec56997c51106a38a48c721259fbcea0f9c0e9e29b5eb447ea0f1f9ffc5cb3463d8774ea46879aa81d6ee71d8be7be01fb4b56419cde683dc89a0910f302ca9e0088fe7d8d903c9bc4a2abeda59f2a1ee322935cfb928234b24c90ec6f8343553de2c185d6da1e3844b18e3f0adb1f2c0b9661e3f939012a1279d72f27074450237e82be60e3ab2ff4986b26986b1fbfbaee02878410169328ea90627fb11d351671190b04932fbd945e783f5940b64bf5e46450f858457c6ddf1081f6c96a731b0d5d3b24dae3cab6158e481e6ff78458790cd8038f23196b87254ea15dd71df951b2022adb92f5cc27ad8d317ca4dc0354a828855cdfab33e9ccfb4ee4ea0e7c50b6ed34429703292d6b14184dd6277f57136c527fb067c0d788770324e5b48d53954777b18270b8761caec302c00866e137a243bd926018d72ece6962b82e6f8aaceef21e78431bb16ed83f198365ceef182d2924b6f1ffcf3b0b4cd4dcd9cd37380667d43f9827c992462c4cc4a01aad49dcaa7af7402251722ac8119334568470b6ca0aebab389ce9a2559b7a1fa3c102ae3e15babd3378f8efa31a240a30dfe4cb8db452630516b350534c53fe67658bc601af585682f15fa1aefb6f5196cf07729021475984e58edf082307e815802fba7b2f9308734cd6dbdc8cc570008b5ae6c5fa46c58ae4611326213fd5c5e1cb6ec67dcaed279387007b20fd9aed8f734ca366fee42605f6d8c52ace70db590bc0a2c94110f9dda137880665d6ad96ed907565254e8178f42ee6c32c09c9dfb2257209439f307b73f84832d84ea6151af4a06eacc55fa7e2c11e27e40f158120312158e783841d29209ce66099263635de808dda5c9c1c4f6584c1f5d166d1b5ea5ea08160f699163b6a052bc437f22f32f741d975e6a356450b7dbdd6a7429a61e7f7fa21877e505fb11fad7a7208a36c0450eb87fa6796efcb06f9d5ec5ace162ac108257fa7fd033099737bc0b39e02d591f79fffafe5878429d254e38e62bcf2727b9a9878cb2b37254284e569fa9362378e69bf06541681014312e33d1adeb12673b2b8861b75e6378c205cd175faf7d6fc3b097ccdc7e880a10f235c436b7c7ac76aa54be92111f306f03a651d28c67cd209b9539be60105ba0a042c561c57d703e1d3408974170d5e63db517ceb1f4a558745706a267e46be29d28d584ea838d645686858a1307ca94d0bca8f5165ed7cf967f34aa4e6c629d39217579445d95d0a624ccc4308780cdb6547b2472d27c42ef38be1a669b6868bcbec3476904dad864c4381311849f74b211f5446fb004619343ee04fea56ea61b540879f0231a944f90e6c1dda69d58dae23db724b7dd9e903f46f534f675725635f669cda36b9b87cc10e6125edaa6a37a5661e693c13bec57fbb08503cba81bf7fb94ee48a1f80c4c0453de0984d60f7516c896973cf606316a72fdacf08f08407cf0b34d8eec8613875717ef0bb9221dfd8982d9f46718c3fe94d48f794af30e0683dd0156ed26545c18b938564c700316bd5adf19f9ea4dee6aecd65285e989eb7a45b604b5dd3ec958da96e23ecab05a7930a4a5ce6869a30fe8662573beb64939516566c338e2b1cf25c8eab60507deb0f89d9bdaba7321e3b4bbbdf95b8c9dba29e147645d1134ebb846f65c1041a3a4fee14ad87434fa981377463b9e9e0669ff20708e629dfa118af3f2db4426c2740006a92c86efc25672200d6ec2d0add94b99bc2d88d8c979910a55b6d277b13bb6ccfb9ad05d2d3cf89d9b6a8f187fa3dd6595b12ae7b6e4983157a86defb4d2449bfcd8e643063432c63223938fb63301c6f3f480aec292dec34ae24d171e322aaf1ba823ad073f7c50e460522cc24eb71f246eb386d09d36963ab9a43206f1ec6bc094cbf11fec0263360e3086dd76b8fbfe3e3b85b0c7e6aaf3518d5365311d3f37666a5b754fb20c9a354484c90684d18904e1cccdc595c2ba71082b0f873f5933a3f12513a966164fe0cb5e667c45b46ef83c171d4c0d1f4f4dbba08b36755c0ab39b5b20b8fe2d6a1b86c20849dd2a2c1b1d77c73904bb493ce3994d5c958837183d2a7b8e7b3c9d4112628cea59cfebb2c33e0aa205cec640dd55ab467ba2f83cc662d3f574733ac5a3e1d5c1104e847b82b64f978e70e86ba010b34230ff893d6cac719b85cf57bd56f86776e5d4884174cf473d31cdc5424e7904360fe98b1905347fea14f36bbd873d1135f76d65cc2ce95cc1b8c772d863ac9308377b38a0e13dbfb3ae8fb15bc58397d35820b9034023803930215bfdf46961e9bd33be529011b56a5ecd6fb91aea5765b4d89fc47229dca7bb382e321862afd3dd974924b47a13ffd747e8bf3e782bd8b5680ea7226282aa0f15742e2b97a7cf51834d497a922bd1b5eba5867718d2a6864cd933048d0a1345841f0c9ed18597facfcdadd45b45cfe0d64b079b1a57c0eab90937a32443f0de3da21f816feb5401804626804fa650b0bde5d7b7cff50ed07a2236b04e10953bda96242f6db3e6d2530ba47ca34011884d77c0cad55b88be24ad7349785e2934c1641933287012f0750a3ddc5322854fb2180a825b1bd8dc5e65525789f3c386763fa17d1f59b2f4b717ee8b313a45bc99b6a11268c85d42a2c1e34ae928c789b3085fa772adc12c775473de334f1d7de6d8d29ff6a3802722a9a5ceef5bd5c7958ebb9ac55211fbaafadc8f01c1c05f76c40e31e36997651e4b5b4cb32ba501374d0d5467f0c202e8d39ffc200e5366fa58ace5520b05663746f8a700e167ab213c12c9e699b93117da20d0ac63017710aef24921715bd2c1c43fa05462e6bd5a9751ab24c7c4347f78f602145f4b3c85a7c22f006f3fad700170043dc79591d9e5bdc459bdef2a46dbc7350d2835188e060cb42fc1fff951191df379edc83c150228874057f928ab933a56377836eaef3f5de44a330212e3e6b330e7f2e54402a73167d4bf9d33efd6ff199618af1bccb98ac19a5651cdfb271b113bff55e180af0484812e494a867b5f92ca8124dcd4aa8a25258528e3e37e7033b60472853ff5912a43d10b67ab20bc3dba625fb307fc28c488e0babf70899dce5d64dd42bfd5cf150f639d3fb65d023e3d527ba1a91e3e8271ccb97195ccb51e3cd6d8c02dfc66b9359f1c2cd5b5bf38062a385838f374e2afd9df08f31639b59b11047d1985b88f4fca81b4149fa8604330e9f4999c31ae11fd2d64d076701f755c1b72fcc3a1644ba6169a5afc7d8782b853173c6911684362be7b41404d0aba2fd5c474cf0e17b707844430ffba048c87d7205bde99c997560d0b6b04121f7d89ffafe5e4f1b961827caca860c5626acf3ec9c31b8bed1c6d6a96b5bfcf407417423df3ecfc6a0ecd76358107dd7ef8e15419f98e775cea3dbed31538b97090e4e2cac6cebabaf324dc8060d2ecc463858525c817ba40045bfe6a482851810c785929dd857fba5447295b1eb2eac76d83cd98c8261e7723d878625718e8abd6c256b9dff42b8687e761097f4532abbdb543c95456f7df2e1edb454e7b36a30b4485e9edc0cea9c9952cbb5cfaaa358e651a9bbb0305dae0b70588b33561e25a0ad1629d41f761e36259f35b9fe6c11882fb90226ba026c38f01fda5936cb939908bdabfb686ede573b6ba1efd42c7071e375a03da0ac6d1cca915ae578ab3180cce999a158b89790d60d8ea51f6d4cca5bb896ada892ace4b65554a4769b975aeb33e264e54c1806e4640b8eeac71a4f43a949a210e151ee14a47d2e268f1d980cef2184f3dbd6a2f33fd1f7700a1403481b3f81afb150d0c520c0e568cdebce0bd1d8ccac1392a3339d8ac01f5c2fa197ca446905fc2dc3b55bff14ea90124b0269f90982b59ee18896b54d9dbd12d778e1a21a6d847247337b0e0e04d5be6ac569a9e01b5be5ab2281a5c96ed3112df682aa7325fc2417e30ff680ad07e41ee3623d3e76e0a837c99fa21d5571d9283c7cc9e723ab5021e17b508d0ee2f322448db786e3c8b0857f570dc165d5e1e37e66d79a640e25d7c64241cbd2ac1d41a996f57ab50f3115c6d80ba2477bb3ebee0a4c39520b22df0ca951fe09cfa25926798b876c8aa9f8e97b36f9c35800eb043578c12a477241f086b50516ccd733abfe77dc926ba46cda88672ba8a3b5ac53f94703d6486f78abee17ea4a05f484f1728c87468bbd211b50f11d38048fe921ce75ad3624149b0c8481d4a203faff178c4ffc2171845f4098c32eb0c9362174f8ebbe520d729a84eae1adf28c6e7e6cc985d61f17615ddd7d0d0dc874234aed80ca5908932a84a4970b69daf7322dc520bfe3268073d97130b4c39788fb4683fc82c7bbb6ee602c9a66cca9df0349fcf05e094d18a05b770574380dcc8a5b42d0731f84fd5492e9a8b4ee18501cd3922bb83a021918c0268a2f88a450846f9128f210c68e3c683fcdc32cca7886ebad99a4e0b96b2882e74f5d93c340c52092aca18d81f98a242dddca97b039ae3026b0a8f225cfa2ff02ab833fe715aea826346a61a3b1a69f5ebd8a2511e9cea941e342914bb0f2b76bf96c507e5b4aeaa0b3ad2a18160732f78e201cb4c13edc8d48dd0bfa878c122ee668c3f0a810f9c680a5f7d46e7f345b18b34b6eb8dd5f8541fe1f82f958d3ff17b173813832f2823aa015f2461f9263de59fa60774c77013a8480f78d087330b72df7038a4a67c453a2e0ea29a36783b82363fd972669c3919e774b367a2f0acb69e31e310b0cf73e3bae59de8c0dab378b9ac2570e076530bc877e9b62f95f73be8ce406d8fdfff2e5751ad99bdd8e204ab8ba77618fb1c2a83f9b63e27f91f7d5f5a2267ee0ece001a1da18965c5f906dfc660780c0fd4475bbb0c95888b136e7b34869a3ad3dc07603ac2376eea6ff34284d1a74e07c6c2548df5b8a9fffea6b7ed60373aa74922ccf534b4982e2ce6a2769c57a702f8b7ce0e81603b702a0a204b76519b1fb2111638764e9fe079089493ddcb7507ce78e9d1b86752852b5e62f0cd5b1d1a83d0f5d41d8e84e67a06e4a9b74ccded6bb2a1a6a0734c0ef6df9a30b0e75e1fcac594319a584932bac3e33498e097d1e9f9d09d3e9cdaae22ce5249fad901ab78bf3627f129f16d18b9431873973ecf9bd6d5166e812512cb069c0d32fa841bc8659333a3fb63488b4d94945803d7367b7213fde0b8bc1a31c37af598603c5a98c943c325f232c4ee7f73f7c0753aa1298fde9442df2c9c00fbcdd0258ddf61b68dc923b5292f90541ca3069c51b7015b15f8f11a585b5e08386302264367a8fd91ea1e624bdba7b6f77078ee575bc1b1ff744a501642aa62aaedb32849b650ba3cc147e093348caa659ae5fa44fe2fa81e54a479d5b06bfd4d30483c2522bef422765d3db14869a4d175501c33b86b2eba62b317d4da89673f88ddf147eb73df6ffc942eec633a618bda8f4ec92b5c22c4836fa66e5fcc3c3c3d37448df2f4fcc50a6895899d0c34709335b5bd5fec23a5a27b9faae6bb43c6b96159b0e57212b004253e9bb307f6caae5dba496ffba7e4a72e485fa4f80b0593681f1595b2b556940f7ce9cc15cf847240c6b7fb40f6083bf798c037f581058fdb8bdc81850793dbec1eb38b4d262fff31079dbcf0123e797952f8f78ecb360afa50cbb13c476bfa2fac8ecaf1f2cbaea8e5d73a054517c95aab552fc6e4a6beaeaf4a233c64ff63bce1078da1a7faa0a00a49e5a5b02fb4ed05e3f164b6bcbd6253d0213f3f41fa8422aa7398f47469dcd47289425b5fc9f350e438fd89765a8ed07bbfb1b25fdb23cad3b1be5b456ff8de570963a5f420bf3b789f1f17eec38470dadceb46af4fda34f101daeb16c12ec7ecebb3d3f765261acd6c5472b88c0570d0b65c800db8484a3650168415d81ba2da2c0837ca909b253ac7b46f24f5f6949b653b3cb9afdad672f2b3a0b753ae644a00bf2a7960c7bc5c691f544dee054adc92734cdeac53d857623f9fd7b97c143865b5c77debf51cc109bed7c435e6a4227b8b95f774618b1ede626de529c5549d0721d523432b826f76aa9be2ccc8955ee5f2ec56d222f22e67746db33505cf5d93f2e687f06217bb975f41a5b054782eff601f0ef7fd1e80229308fc99d36cac0e8e4ba7b672f58a51178c265a5cc8c8b83fd81691af0ad19ec5b2c2718289c310cd24968819d1c6a16c05e3e0a0af344c4f74289c35aed27e613a9c70ea39055507d08298cac0b5a70559ebefb66e6c8c81d8a289bc45a628fe48314e5266f37535dac1220b51fe6676d7ea0aa4f277e2467ba4a9f0e91887f122e7aeae59753a5eaabef613d93b74caf697981fb21a763f17b7c112011a72af25dc32468d96642c00f80578cbed59f47071da7866c7bab7e01a8617c57168527c20741c76645c8a297a03baf57fe306f42a35c3b8bea7f6d03350aa2e00780a20878e4e02fd9a47c38f787057fb85994564a0f96e8d16d8aeec517a5412e9c4451850883b98a3bcb8ffec19f5c80f1866805725b2e7e18e3b36aaff43f114f16b9a3f1ea7fa76d31fbf41a216b8ea6d1cb486d867bdecdcd005118f42984dcd09ca40ca59d20a3b301a8797dcff39b1291ea4a333324880d693263375dbc9bfe1bb5640fe724233ea0e319068aeb6bc90640bb91d9247e127d9ff4dcda75d5c3c1265ff7818498ce2864a49d0d7387e5bb1510c7c5fff779497c63378920c505ee6902ead78623c17083d0171568c4628be900d799530553856e75d754eda24bea77aae433d764676039c2b5ee03d2ff2f1a7ea06363246ab2f35a3b73f189e06d3ca40bba6380f9839bebdc0dcf279e34ea75c1518be650b978c9960e956e25564c308e4321965a97119adcbca883f13e1e2ed960eec93c6f892aa8fd929199196e5713f6ff8912a46592b69ab4d9e8dec3edb8eb64f3db9bbcbdf35aeac402840db3d55b02ace35344b1264703a30d742f29381a26b19574f374baf97cc41a3466bd5bd51a1c07b29063f8583d77c4c46bc629aece7068fce4071aa8e1e4dfb5e73b8b1f748a614f5fba289c580a3f2e14c3ce4c4fe80b1174fa71b90a3ee9b7793e613cde8a73fede2abdffa5d877327b41de046a5b5c716c7f87bd27bb006fd8e4e6276301e361647eb5bf9861861d9d2848267cf5a0cd5533a1b9cf3d5953e5b5169703c10919c975e1accc55f521c3ef0f09e38e16a4d71b73b80045ef82921b3fbbaf1bbcd2aa326edbc845572e0ad9e28fda0673fdabad9868bbbb056b532f07a5c73740ba13d6375ef36445124b6abe860e1c5c26f5910178d4d947cdb890ed9743b308faceb8d6f434b48676b5118296dede5b6e787d030af15cb8809c741245848375bd1e21e51be3fd50a44cc1389c95950dca6b02d0195679ba71513225939217dc09b58533e20416eeb6c713d93658f9e00485079b37b896db79433ac393aa4b044676ff0f2bda648c259440dd601ea38e9b38e2f04c78edd9f8cdf653d01c7c42314223c368b7f3accbfc59e8412a03d180edb203384eff289c68acd4b98533e783f4ccb1936d8b1f1e5d6a192666c2e0564b8bbabce78adbadecd87b6c05da9a49ed616227477037baae9480b465813190f7a7b60df9812a8f2a624d6d9331cd2da069ab6c053cc88a4ca5a2bd71cbe0ee360141e2bdda6a4b0c3e5cfacb2d04e0c9db9dbd63dd550fb4bf35e63c967495e8c71b01c18cc6c85dc761c7477e0073369a5f5b87d1609607e5184726622ad68a9316a3b2f260d5f804cb4d9c2317bd3a44f8ca00c572d32b55f87d56bf369141185f75517aeec76c1ffd69b00006e0358bae0f48ea410eebb10a47cb47c21833bac923386e1a9a54fac7dc7bf98910acd43c5fd2559cbc8f5aceced3d8f3531d293b332f554fcccbefa834cc5306ae5d33ba26081abd990ce0b7f5ed329b0dd01dda789ec6c38af10cc923fee667ad0caee51ac4da2adaf47891ec6cc1ef5868cad5e5deb8274f69569ce36742a5526e8c56f68462832babe929967040f9ff2a15221bda163f7d193f9026442cd5ce9872f3b09f39a1b81780726964072ec0d8b7bde789a889629f7d9b1f80223e56ac1fbe2c95c2983acaf6611f1f8d4269bd383b562c1792697e0f3745055f534acc14707547bb1af05f98686af0c79b0b6b6d97bdb09366b811cb08510eb63b0c7c2a0a38febfacf5dffcaaefa96f1f559c0ef70f935da7b838ad490e40aec1f28a561841adea0180f0e5220c25d279a90ea22ac0742c4f3a090ddda5056c9c894ab9af8f4fe7879c60caafa7dd1c95d522157187bbd059d936910231cc698eeeb6e30ed07ffdc84c564ca0e02461b5b258646d5829845649ca7c7ed83988035b972e64e43ce56fc7b4059c49ade591bc99e562c7a79beff6b769b9c3ad17b9fa966514f58aa366c4ffd0fdd655c0af4364abd0e28b26dff927c699178c97dcf64416916a12fc507b2f9b5aeeaf4b7c6e2ccb05a5846b5d1cdbe49e501949e42b00addfbe7450d75ec4164e561eb45da2eac8fef7fb7b9a71cbc77cde1f57bf36329a8cda40dc0db091801c1cc157a8b8f4819ffa44c73d736618dbcf2a1a9079ba095</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave"></span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算概论C</category>
        <category>计算概论C(21 fall)</category>
      </categories>
      <tags>
        <tag>计算概论C(21 fall)</tag>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>必读：如何看加密文章</title>
    <url>/2021/11/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>当你点开一片文章时，如果发现长下面这样：</p>
<p><img src="/2021/11/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/image-20211111025338844.png" alt="image-20211111025338844"></p>
<p>注意，这并不是一篇没有内容的文章，只是内容被加密了。中间那个横线就是密码输入框，在此处输入密码并按回车键就可以解密查看了！（手机也是按虚拟键盘上的回车键）</p>
<p>如下：</p>
<p><img src="/2021/11/11/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/image-20211111025449872.png" alt="image-20211111025449872"></p>
]]></content>
      <categories>
        <category>计算概论C</category>
      </categories>
      <tags>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算概论C》常见问题汇总</title>
    <url>/2021/11/11/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在当助教的几个学期里，发现很多同学都会问一些相似的问题，这些问题的原因和解决方法都是类似的，但是在答疑时可能就需要反复的讲很多遍，这是非常没有效率的一件事。为了解决这个问题，决定在此开一个常见问题汇总，将常见的一些问题记录下来，方便同学们查阅，减少相似问题的提问次数，提高效率。</p>
<p>同学们的常见问题大概可以分为以下四类：</p>
<ol>
<li>编程环境上的问题，包括 VS Code 的使用，电脑上的 python 环境等</li>
<li>代码的语法错误，即由于写的语法不对造成的 syntax error</li>
<li>代码的运行时错误，即在代码运行过程中因为各种各样的 error 导致的程序 crash，没有正常退出</li>
<li>代码的逻辑错误，即<strong>纯粹</strong>由于逻辑写的有问题导致的得不到一个正确的结果</li>
</ol>
<p>其中，第2类错误是应该同学们自己解决的，当你发现你的报错里面出现了<code>syntax error</code>（即语法错误）的字样时且你还不理解为什么的时候，你应该去看ppt和老师的示例，对比哪里出现了问题。</p>
<p>而第4类错误是一个纯粹的debug的过程，不太好作为<strong>常见问题</strong>来总结，之后可以找一些同学们的错误代码来写写一个debug过程的示例，也欢迎同学们投稿自己的错误代码。</p>
<p>综上，我们在这里主要总结第1类和第3类错误，其中又以第3类错误为重点，因为第1类错误往往在前两次上机课的时候就会现场解决掉，所以不作为重点。</p>
<p>关于第2类错误，我也会<strong>随缘</strong>更新点东西进去。</p>
<p>如果你觉得有什么应该在这里写一下而现在还没写的东西，也可以积极来找助教提建议，建议采纳后会在对应的条目前加一句“来自xx级x同学的提议”。</p>
<p>随缘更新中。</p>
<h1 id="1-环境相关的错误"><a href="#1-环境相关的错误" class="headerlink" title="1. 环境相关的错误"></a>1. 环境相关的错误</h1><h1 id="2-语法错误-syntax-error"><a href="#2-语法错误-syntax-error" class="headerlink" title="2. 语法错误 syntax error"></a>2. 语法错误 <code>syntax error</code></h1><h1 id="3-运行时错误"><a href="#3-运行时错误" class="headerlink" title="3. 运行时错误"></a>3. 运行时错误</h1><h1 id="4-一些debug思路示例"><a href="#4-一些debug思路示例" class="headerlink" title="4. 一些debug思路示例"></a>4. 一些debug思路示例</h1>]]></content>
      <categories>
        <category>计算概论C</category>
      </categories>
      <tags>
        <tag>计算概论C</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 1 滑动窗口</title>
    <url>/2021/04/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>本次实验要求在一个数据链路层的模拟实现环境下，用C语言实现三个数据链路层协议：1比特滑动窗口协议、回退N帧滑动窗口协议、选择性重传协议。</p>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>通过阅读实验指导书可以发现，回退N帧滑动窗口协议是最重要的一个，其他两个协议都可以看作在此基础上的一点小修改，所以本次实验中最重要的一点是实现回退N帧滑动窗口协议。<br>在回退N帧实验中，系统和我需要实现的函数的函数交互方式如下：</p>
<blockquote>
<p><strong>等停协议和回退N帧协议：</strong><br>当发送端需要发送帧时，会调用学生测试函数，并置参数<code>messageType</code>为<code>MSG_TYPE_SEND</code>，测试函数应该将该帧缓存，存入发送队列中。若发送窗口还未打开到规定限度，则打开一个窗口，并将调用<code>SendFRAMEPacket</code>函数将该帧发送。若发送窗口已开到限度，则直接返回，相当于直接进入等待状态。</p>
<p>当发送端收到接收端的<code>ACK</code> 后，会调用学生测试函数，并置参数<code>messageType</code>为<code>MSG_TYPE_RECEIVE</code>，测试函数应该检查<code>ACK</code>值后，将该<code>ACK</code> 对应的窗口关闭。由于关闭了窗口，等待发送的帧可以进入窗口并发送，因此，此时若发送队列中存在等待发送的帧应该将一个等待发送的帧发送并打开一个新的窗口。</p>
<p>发送每发送一个帧，系统都会为他创建一个定时器，当被成功<code>ACK</code> 后，定时器会被取消，若某个帧在定时器超时时间仍未被<code>ACK</code>，系统则会调用测试函数，并置参数<code>messageType</code> 为<code>MSG_TYPE_TIMEOUT</code>，告知测试函数某帧超时，测试函数应该将根据帧序号将该帧以及后面发送过的帧重新发送。</p>
</blockquote>
<p>可见，系统通过反复调用我实现的函数，通过<code>messageType</code>来标注是什么样的操作要求。因此我们可以考虑通过<code>switch</code>来区分开不同的操作，每个操作进行单独的实现。除此之外，在运行过程中，还有数据保存要求，所以我们需要全局变量或者静态变量来存储一些数据，考虑到每个函数功能的单独性，用静态变量实现会更优雅，在本次实验中选择这样实现。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><p>正如之前所述，我将以回退N帧数函数为基础完成整个实验，在此部分进行一些代码细节的说明。<br>首先，定义的一些常量以及结构如下：</p>
<ul>
<li><p>两个窗口大小的常量</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_STOP_WAIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_BACK_N_FRAME 4</span></span><br></pre></td></tr></table></figure></li>
<li><p>表示帧状态的枚举型</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    data,</span><br><span class="line">    ack,</span><br><span class="line">    nak</span><br><span class="line">&#125; frame_kind;</span><br></pre></td></tr></table></figure></li>
<li><p>系统中定义的<code>frame</code>结构</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame_head</span> &#123;</span></span><br><span class="line">    frame_kind kind;		<span class="comment">// 帧类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq;		<span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ack;		<span class="comment">// 确认号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">100</span>];<span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame</span> &#123;</span></span><br><span class="line">    frame_head head;		<span class="comment">//帧头</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;  	<span class="comment">//帧的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义的用于存储帧的<code>Buffer</code>结构。其中<code>pBuffer</code>和<code>pFrame</code>指针指向同一片地方只是生命的类型不同，主要是便于之后调用时不再手动强制类型转换。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer;	<span class="comment">// 向`SendFRAMEPacket`函数传的第一个参数</span></span><br><span class="line">    frame *pFrame; 			<span class="comment">// 存储的frame的指针</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize;			<span class="comment">// size，向`SendFRAMEPacket`函数传的第二个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Buffer</span>() &#123;</span><br><span class="line">        <span class="comment">// 分配一块储存frame的空间</span></span><br><span class="line">        pFrame = <span class="keyword">new</span> <span class="built_in">frame</span>();	</span><br><span class="line">        <span class="comment">// 将分配的地址指针赋值给pBuffer</span></span><br><span class="line">        pBuffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) pFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于储存frame的工具成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">char</span> *_pBuffer, <span class="keyword">int</span> _bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意不能是复制指针，而是需要把内容复制过来</span></span><br><span class="line">        (*pFrame) = *((frame *) _pBuffer);</span><br><span class="line">        bufferSize = _bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>一个用于通过指针获得<code>ACK</code>的宏函数</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后，回退N帧测试函数<code>stud_slide_window_back_n_frame</code>内定义的用于存储数据的静态变量如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_back_n_frame</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="comment">// switch body .......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中各变量的意义如下：</p>
<ul>
<li><code>lower</code>: 滑动窗口的下界</li>
<li><code>upper</code>: 滑动窗口上界的下一个</li>
<li><code>wait_queue</code>: 由于窗口打开到上限不能直接<code>send</code>的帧的等待队列</li>
<li><code>WINDOW_SIZE</code>: 在本函数中的窗口大小，每个函数中可能不一样</li>
<li><code>windows[WINDOW_SIZE]</code>: 用于存储各窗口发出的帧的数组，大小和窗口大小一样</li>
</ul>
<p>此外，需要注意的是，实际打开的窗口的<strong>窗口号</strong>下界为<code>lower % WINDOW_SIZE</code>，上界的下一个<strong>窗口号</strong>为<code>(upper + 1) % WINDOW_SIZE</code>。因为实际窗口号是在一定范围内轮流使用，例如<code>0,1,2,3,0,1,2,...</code>这样，但是如果将下界和上界直接这样表示有时会带来额外的麻烦，例如当窗口大小为1时，只存在一个窗口号<code>0</code>，此时<strong>上界的下一个窗口号</strong>也还是<code>0</code>，刚开始实现时就是因为这样，导致回退N帧测试函数不能直接修改<code>WINDOW_SIZE</code>来用在等停测试函数中。</p>
<p>之后便是<code>swtich</code>中各个功能的实现，实现细节如下：</p>
<ul>
<li><code>MSG_TYPE_SEND</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">	<span class="comment">// 保存帧的内容</span></span><br><span class="line">	Buffer buffer;</span><br><span class="line">	buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">	wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">	<span class="comment">// 发送等待序列中的帧</span></span><br><span class="line">    <span class="comment">// 当队列不为空且窗口大小小于最大大小时进行发送。</span></span><br><span class="line">	<span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">        <span class="comment">// 从队列头取出一个并发送</span></span><br><span class="line">		Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">		wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">        <span class="comment">// 将发送的帧储存在对应窗口中</span></span><br><span class="line">		windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">		upper++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><code>MSG_TYPE_RECEIVE</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">    <span class="comment">// 读取收到的ack</span></span><br><span class="line">	<span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">    <span class="comment">// 从目前的打开的窗口中寻找seq=ack的窗口</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">            <span class="comment">// 如果找到，说明i窗口以及之前的窗口已经被成功接受，则下界应当更新为i + 1</span></span><br><span class="line">			lower = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时如果能继续发送则继续发送，该部分发送函数的逻辑和`case MSG_TYPE_SEND`中的对应部分一模一样</span></span><br><span class="line">	<span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">		Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">		wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">		windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">		upper++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><code>MSG_TYPE_TIMEOUT</code>:  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">		Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">		<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上便是回退N帧协议的实现细节。在实现中要注意的几个点，从<code>pFrame</code>中读取数据时（在本次实验中要读取的为<code>seq</code>、<code>ack</code>、<code>kind</code>），要注意大小端的转换，直接用<code>ntohl()</code>函数即可。在这种实现中，实现等停协议只需要将<code>WINDOW_SIZE</code>设置成<code>WINDOW_SIZE_STOP_WAIT</code>（即为1）即可，此外<strong>不需要任何的修改</strong>。</li>
</ul>
<p>选择性重传函数中，取消了<code>MSG_TYPE_TIMEOUT</code>这种类型，只需要对<code>case MSG_TYPE_RECEIVE</code>做一些修改即可，修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">    <span class="comment">// 读取`kind`区分是`ack`还是`nak`</span></span><br><span class="line">	<span class="keyword">int</span> kind = <span class="built_in">ntohl</span>(((frame *) pBuffer)-&gt;head.kind);</span><br><span class="line">    <span class="comment">// 如果kind是`ack`，和之前的处理一模一样，此处略</span></span><br><span class="line">	<span class="keyword">if</span> (kind == ack) &#123;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果kind是`nak`，则将帧中的`ack`表示的帧号找出来重发</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (kind == nak) &#123;</span><br><span class="line">		<span class="keyword">int</span> nak = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历找到缓存的帧中seq等于读出的ack（在这里用变量nak表示）的帧</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123;</span><br><span class="line">				Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">				<span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，该实验结束。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>不熟悉实验系统，实验系统对一些错误也不能很好的反馈。例如刚开始的时候，由于代码实现中将<code>Buffer</code>这个辅助结构当成一个<code>class</code>来使用，写了析构函数，并在析构函数中进行了<code>delete</code>操作，但是由于忽略了局部变量作用域的问题，导致了某些指针被重复释放，出了错误，但是在实验系统中并没有报错，只是单纯的卡住不动，最后因为过去的一点点经验想到了可能是指针相关的错误，最后才找到了这个问题。</li>
<li>还没找到很方便的debug方法，在做实验时还是通过最原始的输出log来寻找问题，实验系统中的单步调试功能也没太用习惯。</li>
<li>对大小端转换的问题还没有形成习惯，漏了好几次转换，运行出错了才发现没写。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>由于三个函数的代码重复性很高，而且前面已经给出了详解，因此在完整代码部分删去了注释。代码说明见前面<strong>实验细节</strong>部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysinclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SendFRAMEPacket</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_STOP_WAIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_SIZE_BACK_N_FRAME 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    data,</span><br><span class="line">    ack,</span><br><span class="line">    nak</span><br><span class="line">&#125; frame_kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame_head</span> &#123;</span></span><br><span class="line">    frame_kind kind;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ack;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frame</span> &#123;</span></span><br><span class="line">    frame_head head;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer;</span><br><span class="line">    frame *pFrame;</span><br><span class="line">    <span class="keyword">int</span> bufferSize;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Buffer</span>() &#123;</span><br><span class="line">        pFrame = <span class="keyword">new</span> <span class="built_in">frame</span>();</span><br><span class="line">        pBuffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) pFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">char</span> *_pBuffer, <span class="keyword">int</span> _bufferSize)</span> </span>&#123;</span><br><span class="line">        (*pFrame) = *((frame *) _pBuffer);</span><br><span class="line">        bufferSize = _bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ACK(pBuffer) ntohl(((frame *) pBuffer)-&gt;head.ack)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 停等协议测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_stop_and_wait</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用static变量来持久化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_STOP_WAIT;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                    lower++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 回退n帧测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_back_n_frame</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用static变量来持久化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                    lower = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 选择性重传测试函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_slide_window_choice_frame_resend</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> bufferSize, UINT8 messageType)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> queue&lt;Buffer&gt; wait_queue;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> WINDOW_SIZE = WINDOW_SIZE_BACK_N_FRAME;</span><br><span class="line">    <span class="keyword">static</span> Buffer windows[WINDOW_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_SEND: &#123;</span><br><span class="line">            Buffer buffer;</span><br><span class="line">            buffer.<span class="built_in">save</span>(pBuffer, bufferSize);</span><br><span class="line">            wait_queue.<span class="built_in">push</span>(buffer);</span><br><span class="line">            <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MSG_TYPE_RECEIVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> kind = <span class="built_in">ntohl</span>(((frame *) pBuffer)-&gt;head.kind);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kind == ack) &#123;</span><br><span class="line">                <span class="keyword">int</span> ack = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == ack) &#123;</span><br><span class="line">                        lower = i + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!wait_queue.<span class="built_in">empty</span>() &amp;&amp; (upper - lower &lt; WINDOW_SIZE)) &#123;</span><br><span class="line">                    Buffer buffer = wait_queue.<span class="built_in">front</span>();</span><br><span class="line">                    wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                    windows[upper % WINDOW_SIZE] = buffer;</span><br><span class="line">                    upper++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (kind == nak) &#123;</span><br><span class="line">                <span class="keyword">int</span> nak = <span class="built_in">GET_ACK</span>(pBuffer);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lower; i &lt; upper; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">ntohl</span>(windows[i % WINDOW_SIZE].pFrame-&gt;head.seq) == nak) &#123;</span><br><span class="line">                        Buffer buffer = windows[i % WINDOW_SIZE];</span><br><span class="line">                        <span class="built_in">SendFRAMEPacket</span>(buffer.pBuffer, buffer.bufferSize);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络概论》lab 4 TCP客户端</title>
    <url>/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-4-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>该次实验主要包含以下四部分</p>
<ol>
<li>设计TCB结构</li>
<li>处理TCP协议的包的接收（实现<code>stud_tcp_input()</code>函数）</li>
<li>封装TCP包（实现<code>stud_tcp_output()</code>函数）</li>
<li>实现<code>Socket</code>的几个接口函数</li>
</ol>
<p>需要注意的是，本次实验中只实现了一个客户端角色的TCP协议并使用等停模式。因此客户端的状态可以做以下简化，如实验指导书上所示</p>
<p><img src="/2021/04/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E3%80%8Blab-4-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF/lab4-1.png"></p>
<p><strong>然而这里的图画的又跟后面实验指导书上说的有自相矛盾的地方，具体的要求当然是自己去试试怎么样才对（？）</strong></p>
<p>所以本次实验的核心在于定义这些状态并实现这里的状态转换。</p>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>本次实验中，我们首先要定义一个TCP结构如下，我们并不考虑选项部分，所以可以认为<code>urgentPointer</code>之后都是数据段，我们只要原封不动的处理即可。</p>
<p>需要注意的是，在本次实验中，TCP结构统一用网络序表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;</span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;</span><br><span class="line">    <span class="keyword">uint32_t</span> seqNum;</span><br><span class="line">    <span class="keyword">uint32_t</span> ackNum;</span><br><span class="line">    <span class="keyword">uint8_t</span> headLen;</span><br><span class="line">    <span class="keyword">uint8_t</span> flags;</span><br><span class="line">    <span class="keyword">uint16_t</span> windowSize;</span><br><span class="line">    <span class="keyword">uint16_t</span> checkSum;</span><br><span class="line">    <span class="keyword">uint16_t</span> urgentPointer;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debugPrint</span><span class="params">()</span></span>&#123; <span class="comment">/* debug用，这里略 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，我们设计的TCB结构如下。在本次实验中，我们TCB中的数据以本地序表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;             <span class="comment">// 套接字描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> srcAddr;       <span class="comment">// 源地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;       <span class="comment">// 源端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dstAddr;       <span class="comment">// 目的地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;       <span class="comment">// 目的端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> seq;           <span class="comment">// seq</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ack;           <span class="comment">// ack</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ackExpect; <span class="comment">// 应该收到的ack</span></span><br><span class="line">    TCPStatus status;       <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">char</span> *data;             <span class="comment">// 数据段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>TCPStatus</code>是一个枚举类，用于表示各种状态，如下，与实验指导书上给出的状态示例相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TCPStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CLOSED,</span><br><span class="line">    SYN_SENT,</span><br><span class="line">    ESTABLISHED,</span><br><span class="line">    FIN_WAIT1,</span><br><span class="line">    FIN_WAIT2,</span><br><span class="line">    TIME_WAIT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作为客户端，需要处理当前连接的状态，我们可以在客户端的本地使用一个全局变量来存储状态，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCB *currentTCB;</span><br></pre></td></tr></table></figure>

<p>该变量记录了当前的连接信息，每次操作时会查找这里的状态。</p>
<p>另外，由于客户端可能会发起多个连接，拥有多个套接字连接符，因此我们还需要一个机构存储多个连接信息，本次实验中我们使用<code>std::vector</code>来完成，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TCB *&gt; TCBTable;</span><br></pre></td></tr></table></figure>

<p>另外，在实现各个函数时一定要<strong>非常注意</strong>字节序的问题。</p>
<h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><h4 id="实现用于计算check-sum的工具函数"><a href="#实现用于计算check-sum的工具函数" class="headerlink" title="实现用于计算check sum的工具函数"></a>实现用于计算<code>check sum</code>的工具函数</h4><p>该函数主要用于计算<code>checkSum</code>，在本次实验中，我们采用所有数据均为网络序的方法来计算<code>checkSum</code>，在实现时要注意。</p>
<ul>
<li><p>首先，给出函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getCheckSum</span><span class="params">(<span class="keyword">char</span> *pBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">short</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>pBuffer</code>传来的是一个<strong>网络序</strong>的tcp包，<code>len</code>是这个包的<strong>总长度</strong>（包括头部），<code>srcAddr</code>和<code>dstAddr</code>是<strong>本地序</strong>的源地址和目标地址，用于计算伪头信息。</p>
</li>
<li><p>计算伪头部分</p>
<p>这里需要注意的是，由于<code>srcAddr</code>，<code>dstAddr</code>，<code>len</code>都是本地序，因此这里要做一次转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪头部分</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr_n = htonl(srcAddr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr_n = htonl(dstAddr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> len_n = htons(len);</span><br><span class="line">checkSum += (srcAddr_n &gt;&gt; <span class="number">16</span>) + (srcAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 源地址</span></span><br><span class="line">checkSum += (dstAddr_n &gt;&gt; <span class="number">16</span>) + (dstAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 目标地址</span></span><br><span class="line">checkSum += (TCP_PROTOCOL_NUM &lt;&lt; <span class="number">8</span>);                  <span class="comment">// TCP协议号</span></span><br><span class="line">checkSum += len_n;    </span><br></pre></td></tr></table></figure></li>
<li><p>计算TCP部分如下，由于<code>pBuffer</code>是一整个结构，而且本身就是网络序，因此我们可以直接转成一个16位整数的数组来操作，会很方便。需要注意跳过原来结构中的<code>checkSum</code>部分，该部分对应<strong>第8个16位整数</strong>。当TCP的数据部分是奇数字节时，我们需要在末尾补一个全0字节，因此需要特判奇数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> *TCPBuffer = (<span class="keyword">uint16_t</span> *)pBuffer;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">8</span>)</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     checkSum += TCPBuffer[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 注意长度的奇偶，要特判奇数</span></span><br><span class="line"> <span class="keyword">if</span> (len % <span class="number">2</span>)</span><br><span class="line">     checkSum += ((<span class="keyword">uint16_t</span>)(pBuffer[len_h]) &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>最后，我们需要处理高位，将高16位加到低16位上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除高位</span></span><br><span class="line"><span class="keyword">while</span> (checkSum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    checkSum = (checkSum &amp; <span class="number">0xffff</span>) + (checkSum &gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>最后的结果应该是现在计算出的值的取反，返回即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (~checkSum) &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实现stud-tcp-input"><a href="#实现stud-tcp-input" class="headerlink" title="实现stud_tcp_input"></a>实现<code>stud_tcp_input</code></h4><p><strong>注意！！！！系统调用该函数的时候传进来的地址是网络序！</strong>（但是调用系统提供的一些接口函数时却需要传本地序，果然很奇怪啊）。</p>
<ul>
<li><p>首先，将传入的<code>pBuffer</code>转换成一个<code>TCP</code>指针，便于之后操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCP *tcp = (TCP *)pBuffer;</span><br></pre></td></tr></table></figure></li>
<li><p>首先，检查<code>checksum</code></p>
<p>这里调用我们刚才的那个函数即可</p>
<p><strong>然而，实际上并不会有这个东西出错的时候，而且实验指导书上也没说出错时应该怎么处理，所以这个不写也没问题（在该系统上）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (getCheckSum(pBuffer, len, ntohl(srcAddr), ntohl(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略了一些debug显示</span></span><br><span class="line">    <span class="comment">// 实验指导书上没定义这个错误？</span></span><br><span class="line">    <span class="comment">// tcp_DiscardPkt(pBuffer, checksum_error);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后，检查<code>ack</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查ack</span><br><span class="line">uint32_t ackNum &#x3D; ntohl(tcp-&gt;ackNum);</span><br><span class="line">uint32_t seqNum &#x3D; ntohl(tcp-&gt;seqNum);</span><br><span class="line">if (ackNum !&#x3D; currentTCB-&gt;ackExpect)</span><br><span class="line">&#123;</span><br><span class="line">    tcp_DiscardPkt(pBuffer, STUD_TCP_TEST_SEQNO_ERROR);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后，是最核心的状态转化的一步，如下：</p>
<ul>
<li><p>当前状态为<code>SYN_SENT</code>，接收到的<code>flag</code>为<code>PACKET_TYPE_SYN_ACK</code>，状态转换到<code>ESTABLISHED</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;status = ESTABLISHED;</span><br><span class="line">    currentTCB-&gt;seq = ackNum;</span><br><span class="line">    currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前状态为<code>ESTABLISHED</code>，继续进行通信</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;seq = ackNum;</span><br><span class="line">    currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH);</span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前状态为<code>FIN_WAIT1</code>，接收到的<code>flag</code>为<code>PACKET_TYPE_ACK</code>，状态转化到<code>FIN_WAIT2</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK) &#123;</span><br><span class="line">    currentTCB-&gt;status = FIN_WAIT2;</span><br><span class="line">    currentTCB-&gt;seq = ackNum;</span><br><span class="line">    currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前状态为<code>FIN_WAIT2</code>，接收到的<code>flag</code>为<code>PACKET_TYPE_FIN_ACK</code>，状态转换到<code>TIME_WAIT</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;status = TIME_WAIT;</span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实现stud-tcp-output"><a href="#实现stud-tcp-output" class="headerlink" title="实现stud_tcp_output"></a>实现<code>stud_tcp_output</code></h4><p><strong>在我们自己实现自己调用的该函数中，参数里的IP地址均为本地序（主要是一开始我以为<code>input</code>那个函数中也是这样）</strong></p>
<p><strong>另外一个需要注意的是，在第一部分的测试中，由于该部分会认为没有实现<code>socket</code>接口，所以不会调用相应的函数，也不会有创建<code>TCB</code>这个过程，所以在调用这个函数时会出错（空指针），因此我们需要在这里加一个<code>surrentPCB</code>的初始化。</strong></p>
<ul>
<li><p>初始化<code>currentTCB</code>（只针对第一部分的测试）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">    currentTCB-&gt;status = CLOSED;</span><br><span class="line">    currentTCB-&gt;ack = gAckNum;</span><br><span class="line">    currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">    currentTCB-&gt;srcAddr = srcAddr;</span><br><span class="line">    currentTCB-&gt;dstAddr = dstAddr;</span><br><span class="line">    currentTCB-&gt;srcPort = srcPort;</span><br><span class="line">    currentTCB-&gt;dstPort = dstPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个新的<code>tcp</code>结构，并且将<code>pData</code>中的数据复制过去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line"><span class="built_in">memcpy</span>(tcp-&gt;data, pData, len);</span><br></pre></td></tr></table></figure></li>
<li><p>构建<code>TCP</code>头，<strong>一定要注意使用网络序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造TCP头</span></span><br><span class="line">tcp-&gt;srcPort = htons(srcPort);</span><br><span class="line">tcp-&gt;dstPort = htons(dstPort);</span><br><span class="line">tcp-&gt;seqNum = htonl(currentTCB-&gt;seq);</span><br><span class="line">tcp-&gt;ackNum = htonl(currentTCB-&gt;ack);</span><br><span class="line"><span class="comment">// 注意低四位为空，头长度为5 * 4字节</span></span><br><span class="line"><span class="comment">// 二进制格式0x10010000</span></span><br><span class="line">tcp-&gt;headLen = <span class="number">0x50</span>;</span><br><span class="line">tcp-&gt;flags = flag;</span><br><span class="line"><span class="comment">// 注意这里也要进行一次字节序转换！</span></span><br><span class="line">tcp-&gt;windowSize = htons(<span class="number">1</span>);</span><br><span class="line">tcp-&gt;urgentPointer = <span class="number">0</span>;</span><br><span class="line">tcp-&gt;checkSum = <span class="number">0</span>; <span class="comment">// 预清零checkSum</span></span><br><span class="line"><span class="comment">// 这里要加上一个头长度！！！！！</span></span><br><span class="line">tcp-&gt;checkSum = getCheckSum((<span class="keyword">char</span> *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后，同样是进行状态转换的判断</p>
<ul>
<li><p>从<code>CLOSE</code>状态转换到<code>SYN_SENT</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN)</span><br><span class="line">    currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从<code>ESTABLISHED</code>状态转换到<code>FIN_WAIT1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;status = FIN_WAIT1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>之后，我们需要根据本次的发送来计算下次应当受到的<code>ack</code>值，以便于之后的校验，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">&#123;</span><br><span class="line">    currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    DebugPrint(<span class="string">&quot;---&gt; Status: %d\n&quot;</span>, currentTCB-&gt;status);</span><br><span class="line">    currentTCB-&gt;ackExpect = currentTCB-&gt;seq + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后，调用系统提供的函数进行发送</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcp_sendIpPkt((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)tcp, <span class="number">20</span> + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, <span class="number">60</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，该函数实现完毕。</p>
<h4 id="实现stud-tcp-socket"><a href="#实现stud-tcp-socket" class="headerlink" title="实现stud_tcp_socket"></a>实现<code>stud_tcp_socket</code></h4><p>该函数并不建立连接，只是分配一个套接字标识符。在<code>Linux</code>中，返回的其实就是一个文件描述符，而<code>Linux</code>中文件描述符的<code>0,1,2</code>已经被占用，因此我们这里从<code>3</code>开始分配（虽然没什么差）。实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DebugPrint(<span class="string">&quot;---&gt; stud_tcp_socket():\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果TCB表为空，插入三个NULL</span></span><br><span class="line">    <span class="comment">// socket的返回值应该是一个文件描述符</span></span><br><span class="line">    <span class="comment">// Linux中，文件描述符的0,1,2分别为std_in std_out std_err</span></span><br><span class="line">    <span class="comment">// 所以我们返回的值从3开始</span></span><br><span class="line">    <span class="comment">// 另外，我们希望能根据sockfd直接定位TCB，因此这样实现</span></span><br><span class="line">    <span class="keyword">if</span> (TCBTable.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TCBTable.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.push_back(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">    currentTCB-&gt;ack = gAckNum;</span><br><span class="line">    currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">    currentTCB-&gt;srcPort = gSrcPort++;</span><br><span class="line">    currentTCB-&gt;sockfd = TCBTable.size();</span><br><span class="line">    currentTCB-&gt;status = CLOSED;</span><br><span class="line"></span><br><span class="line">    TCBTable.push_back(currentTCB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentTCB-&gt;sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-connect"><a href="#实现stud-tcp-connect" class="headerlink" title="实现stud_tcp_connect"></a>实现<code>stud_tcp_connect</code></h4><p>需要注意这个函数参数中的<code>sockaddr_in</code>结构是一个用来存套接字中的IP地址信息的结构，内部一定是大端存储IP地址，因此需要注意字节序转换。</p>
<p>在连接时，需要发送一个包，并且在连接时设置<code>currentTCB</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr_in *addr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">	<span class="comment">// 注意这里的字节序转换</span></span><br><span class="line">    currentTCB-&gt;dstPort = ntohs(addr-&gt;sin_port);</span><br><span class="line">    currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">    currentTCB-&gt;srcAddr = getIpv4Address();</span><br><span class="line">    currentTCB-&gt;dstAddr = ntohl(addr-&gt;sin_addr.s_addr);</span><br><span class="line">	<span class="comment">// 发送</span></span><br><span class="line">    stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_SYN,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line">    <span class="comment">// 等待对方发送的包</span></span><br><span class="line">    TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">    <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收到服务端的包之后调用`stud_tcp_input`处理</span></span><br><span class="line">    <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-send"><a href="#实现stud-tcp-send" class="headerlink" title="实现stud_tcp_send"></a>实现<code>stud_tcp_send</code></h4><p>由于我们之前已经实现好了<code>stud_tcp_output</code>和<code>stud_tcp_input</code>，因此这里我们直接调用即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">	<span class="comment">// 当前必须为可以发消息的状态</span></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB-&gt;data = (<span class="keyword">char</span> *)pData;</span><br><span class="line">        stud_tcp_output((<span class="keyword">char</span> *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="comment">// 等待对方回复</span></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用stud_tcp_input处理</span></span><br><span class="line">        <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-recv"><a href="#实现stud-tcp-recv" class="headerlink" title="实现stud_tcp_recv"></a>实现<code>stud_tcp_recv</code></h4><p>在该函数中，等待一个对方发来的包并进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 等待对方发来的包</span></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(pData, tcp-&gt;data, len);</span><br><span class="line">        <span class="comment">// 调用stud_tcp_input处理</span></span><br><span class="line">        <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现stud-tcp-close"><a href="#实现stud-tcp-close" class="headerlink" title="实现stud_tcp_close"></a>实现<code>stud_tcp_close</code></h4><p>在本函数中，要注意关闭连接时的四次握手，需要注意我们的顺序问题。</p>
<p>首先，应当调用<code> stud_tcp_output</code>发送一个<code>flag</code>为<code>PACKET_TYPE_FIN_ACK</code>的请求，之后对方会先发来一个<code>PACKET_TYPE_ACK</code>的包，接收到之后会进入<code>FIN_WAIT2</code>状态，然后需要继续等待对方发送的包，收到<code>PACKET_TYPE_FIN_ACK</code>才正式关闭，因此这里应该等待两次。实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line">	<span class="comment">// 在ESTABLISHED状态才能结束</span></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        stud_tcp_output(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_FIN_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">		<span class="comment">// 等待ACK</span></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 等待FIN_ACK</span></span><br><span class="line">        tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = waitIpPacket((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stud_tcp_input((<span class="keyword">char</span> *)tcp, len, htonl(currentTCB-&gt;srcAddr), htonl(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，各实验函数编写完成，并且在系统上测试通过。</p>
<h2 id="实验中遇到的问题"><a href="#实验中遇到的问题" class="headerlink" title="实验中遇到的问题"></a>实验中遇到的问题</h2><ol>
<li>实验指导书上很多比较细节的地方都没说到，例如函数输入参数的字节序问题，在之前的<code>ipv4</code>实验中，参数中的<code>ip</code>地址是本地序，这次要求的<code>stud_tcp_input</code>的参数就成了网络序，但是提供的接口函数<code>tcp_sendIpPkt</code>还是本地序，我之前在宿舍自己写的时候觉得这两个地方要么都网络序要么都本地序，因为之前也是这样，但是去了之后因为这个问题头疼了半天。</li>
<li>实验指导书上有一些矛盾的地方，给出的一些函数（例如<code>tcp_DiscardPkt</code>）其实一直没用到，有些迷惑。</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码再次给出（包括了用于debug的语句等）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* THIS FILE IS FOR TCP TEST</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct sockaddr_in &#123;</span></span><br><span class="line"><span class="comment">        short   sin_family;</span></span><br><span class="line"><span class="comment">        u_short sin_port;</span></span><br><span class="line"><span class="comment">        struct  in_addr sin_addr;</span></span><br><span class="line"><span class="comment">        char    sin_zero[8];</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sysInclude.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DebugPrint(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DebugPrint(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// ?</span></span><br><span class="line"><span class="keyword">int</span> gSrcPort = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> gDstPort = <span class="number">2006</span>;</span><br><span class="line"><span class="keyword">int</span> gSeqNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> gAckNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">tcp_DiscardPkt</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">tcp_sendReport</span><span class="params">(<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">tcp_sendIpPkt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, UINT16 len, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr, UINT8 ttl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">waitIpPacket</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getServerIpv4Address</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP的头占20个字节</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TCP_HEADER_LENGTH = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// TCP协议号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TCP_PROTOCOL_NUM = <span class="number">0x6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP结构</span></span><br><span class="line"><span class="comment">// 永远用网络序！！</span></span><br><span class="line"><span class="comment">// 永远用网络序！！</span></span><br><span class="line"><span class="comment">// 永远用网络序！！</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;</span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;</span><br><span class="line">    <span class="keyword">uint32_t</span> seqNum;</span><br><span class="line">    <span class="keyword">uint32_t</span> ackNum;</span><br><span class="line">    <span class="keyword">uint8_t</span> headLen;</span><br><span class="line">    <span class="keyword">uint8_t</span> flags;</span><br><span class="line">    <span class="keyword">uint16_t</span> windowSize;</span><br><span class="line">    <span class="keyword">uint16_t</span> checkSum;</span><br><span class="line">    <span class="keyword">uint16_t</span> urgentPointer;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debugPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========== tcp struct info ===========\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;srcPort = %d\n&quot;</span>, <span class="built_in">ntohs</span>(srcPort));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dstPort = %d\n&quot;</span>, <span class="built_in">ntohs</span>(dstPort));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;seqNum = %d\n&quot;</span>, <span class="built_in">ntohl</span>(seqNum));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ackNum = %d\n&quot;</span>, <span class="built_in">ntohl</span>(ackNum));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;headLen = %d\n&quot;</span>, ((headLen &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flags = %d\n&quot;</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;windowSize = %d\n&quot;</span>, <span class="built_in">ntohl</span>(windowSize)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;checkSum = %d\n&quot;</span>, <span class="built_in">ntohl</span>(checkSum));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;urgentPointer = %d\n&quot;</span>, <span class="built_in">ntohl</span>(urgentPointer));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TCPStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CLOSED,</span><br><span class="line">    SYN_SENT,</span><br><span class="line">    ESTABLISHED,</span><br><span class="line">    FIN_WAIT1,</span><br><span class="line">    FIN_WAIT2,</span><br><span class="line">    TIME_WAIT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输控制快</span></span><br><span class="line"><span class="comment">// 这是保存在本机的结构，永远用主机序！！！</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;             <span class="comment">// 套接字描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> srcAddr;       <span class="comment">// 源地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> srcPort;       <span class="comment">// 源端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dstAddr;       <span class="comment">// 目的地址</span></span><br><span class="line">    <span class="keyword">uint16_t</span> dstPort;       <span class="comment">// 目的端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> seq;           <span class="comment">// seq</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ack;           <span class="comment">// ack</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ackExpect; <span class="comment">// 应该收到的ack</span></span><br><span class="line">    TCPStatus status;       <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">char</span> *data;             <span class="comment">// 数据段</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;TCB *&gt; TCBTable;</span><br><span class="line">TCB *currentTCB;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">IpAddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c1;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c2;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c3;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c4;</span><br><span class="line">    &#125; ip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAddr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">IpAddr</span> <span class="title">ip</span>;</span></span><br><span class="line">    ip.num = addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, ip.ip.c4, ip.ip.c3, ip.ip.c2, ip.ip.c1);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约定传来的pBuffer是网络序</span></span><br><span class="line"><span class="comment">// 其他几个应该都是主机序</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getCheckSum</span><span class="params">(<span class="keyword">char</span> *pBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">short</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In getCheckNum():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; srcAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n---&gt; dstAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(dstAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> checkSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 伪头部分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr_n = <span class="built_in">htonl</span>(srcAddr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr_n = <span class="built_in">htonl</span>(dstAddr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> len_n = <span class="built_in">htons</span>(len);</span><br><span class="line">    checkSum += (srcAddr_n &gt;&gt; <span class="number">16</span>) + (srcAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 源地址</span></span><br><span class="line">    checkSum += (dstAddr_n &gt;&gt; <span class="number">16</span>) + (dstAddr_n &amp; <span class="number">0xFFFF</span>); <span class="comment">// 目标地址</span></span><br><span class="line">    checkSum += (TCP_PROTOCOL_NUM &lt;&lt; <span class="number">8</span>);                  <span class="comment">// TCP协议号</span></span><br><span class="line">    checkSum += len_n;                                    <span class="comment">// TCP长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> *TCPBuffer = (<span class="keyword">uint16_t</span> *)pBuffer;</span><br><span class="line">    <span class="comment">// 计算主机序下的len</span></span><br><span class="line">    <span class="comment">// 遍历计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        checkSum += TCPBuffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意长度的奇偶，要特判奇数</span></span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span>)</span><br><span class="line">        checkSum += ((<span class="keyword">uint16_t</span>)(pBuffer[len_h]) &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除高位</span></span><br><span class="line">    <span class="keyword">while</span> (checkSum &gt;&gt; <span class="number">16</span>)</span><br><span class="line">        checkSum = (checkSum &amp; <span class="number">0xffff</span>) + (checkSum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Return from getCheckNum(), return value checkSum=%d (hex is %x):\n&quot;</span>, (~checkSum) &amp; <span class="number">0xffff</span>, (~checkSum) &amp; <span class="number">0xffff</span>);</span><br><span class="line">    <span class="comment">// 返回取反的值</span></span><br><span class="line">    <span class="keyword">return</span> (~checkSum) &amp; <span class="number">0xffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传来的是网络序！</span></span><br><span class="line"><span class="comment">// 注意这里的srcAddr和dstAddr也是网络序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_input</span><span class="params">(<span class="keyword">char</span> *pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; len is %d:\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; srcAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n---&gt; dstAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(dstAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    TCP *tcp = (TCP *)pBuffer;</span><br><span class="line">    <span class="comment">// 检查CheckSum</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getCheckSum</span>(pBuffer, len, <span class="built_in">ntohl</span>(srcAddr), <span class="built_in">ntohl</span>(dstAddr)) != ((TCP *)pBuffer)-&gt;checkSum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; check sum error\n&quot;</span>);</span><br><span class="line">        tcp-&gt;<span class="built_in">debugPrint</span>();</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; your ans: %d\n&quot;</span>, <span class="built_in">getCheckSum</span>(pBuffer, len, <span class="built_in">ntohs</span>(srcAddr), <span class="built_in">ntohs</span>(dstAddr)));</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; correct ans: %d\n&quot;</span>, tcp-&gt;checkSum);</span><br><span class="line">        <span class="comment">// 实验指导书上没定义这个错误？</span></span><br><span class="line">        <span class="comment">// tcp_DiscardPkt(pBuffer, checksum_error);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查ack</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ackNum = <span class="built_in">ntohl</span>(tcp-&gt;ackNum);</span><br><span class="line">    <span class="keyword">uint32_t</span> seqNum = <span class="built_in">ntohl</span>(tcp-&gt;seqNum);</span><br><span class="line">    <span class="keyword">if</span> (ackNum != currentTCB-&gt;ackExpect)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Error!!! ackNum != currentTCB-&gt;ackExpect\n&quot;</span>);</span><br><span class="line">        <span class="built_in">tcp_DiscardPkt</span>(pBuffer, STUD_TCP_TEST_SEQNO_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == SYN_SENT &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: SYN_SENT to ESTABLISHED\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = ESTABLISHED;</span><br><span class="line">        currentTCB-&gt;seq = ackNum;</span><br><span class="line">        currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Transfer data at Status ESTABLISHED\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;seq = ackNum;</span><br><span class="line">        currentTCB-&gt;ack = seqNum + (len - TCP_HEADER_LENGTH);</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT1 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: FIN_WAIT1 to FIN_WAIT2\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = FIN_WAIT2;</span><br><span class="line">        currentTCB-&gt;seq = ackNum;</span><br><span class="line">        currentTCB-&gt;ack = seqNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == FIN_WAIT2 &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: FIN_WAIT2 to TIME_WAIT\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = TIME_WAIT;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约定传来的是网络序！（指pData）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stud_tcp_output</span><span class="params">(<span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> flag, <span class="keyword">unsigned</span> <span class="keyword">short</span> srcPort, <span class="keyword">unsigned</span> <span class="keyword">short</span> dstPort, <span class="keyword">unsigned</span> <span class="keyword">int</span> srcAddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> dstAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; stud_tcp_output():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; srcAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n---&gt; dstAddr is :&quot;</span>);</span><br><span class="line">    <span class="built_in">printAddr</span>(srcAddr);</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">        currentTCB-&gt;status = CLOSED;</span><br><span class="line">        currentTCB-&gt;ack = gAckNum;</span><br><span class="line">        currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">        currentTCB-&gt;srcAddr = srcAddr;</span><br><span class="line">        currentTCB-&gt;dstAddr = dstAddr;</span><br><span class="line">        currentTCB-&gt;srcPort = srcPort;</span><br><span class="line">        currentTCB-&gt;dstPort = dstPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">    <span class="built_in">memcpy</span>(tcp-&gt;data, pData, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造TCP头</span></span><br><span class="line">    tcp-&gt;srcPort = <span class="built_in">htons</span>(srcPort);</span><br><span class="line">    tcp-&gt;dstPort = <span class="built_in">htons</span>(dstPort);</span><br><span class="line">    tcp-&gt;seqNum = <span class="built_in">htonl</span>(currentTCB-&gt;seq);</span><br><span class="line">    tcp-&gt;ackNum = <span class="built_in">htonl</span>(currentTCB-&gt;ack);</span><br><span class="line">    <span class="comment">// 注意低四位为空，头长度为5 * 4字节</span></span><br><span class="line">    <span class="comment">// 二进制格式0x10010000</span></span><br><span class="line">    tcp-&gt;headLen = <span class="number">0x50</span>;</span><br><span class="line">    tcp-&gt;flags = flag;</span><br><span class="line">    <span class="comment">// 注意这里也要进行一次字节序转换！</span></span><br><span class="line">    tcp-&gt;windowSize = <span class="built_in">htons</span>(<span class="number">1</span>);</span><br><span class="line">    tcp-&gt;urgentPointer = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;checkSum = <span class="number">0</span>; <span class="comment">// 预清零checkSum</span></span><br><span class="line">    <span class="comment">// 这里要加上一个长度！！！！！</span></span><br><span class="line">    tcp-&gt;checkSum = <span class="built_in">getCheckSum</span>((<span class="keyword">char</span> *)tcp, len + TCP_HEADER_LENGTH, srcAddr, dstAddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == CLOSED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_SYN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: CLOSED to SYN_SENT\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED &amp;&amp; tcp-&gt;flags == PACKET_TYPE_FIN_ACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status Change: ESTABLISHED to FIN_WAIT1\n&quot;</span>);</span><br><span class="line">        currentTCB-&gt;status = FIN_WAIT1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB-&gt;ackExpect = currentTCB-&gt;seq + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; Status: %d\n&quot;</span>, currentTCB-&gt;status);</span><br><span class="line">        currentTCB-&gt;ackExpect = currentTCB-&gt;seq + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tcp_sendIpPkt</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)tcp, <span class="number">20</span> + len, currentTCB-&gt;srcAddr, currentTCB-&gt;dstAddr, <span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; stud_tcp_socket():\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果TCB表为空，插入三个NULL</span></span><br><span class="line">    <span class="comment">// socket的返回值应该是一个文件描述符</span></span><br><span class="line">    <span class="comment">// Linux中，文件描述符的0,1,2分别为std_in std_out std_err</span></span><br><span class="line">    <span class="comment">// 所以我们返回的值从3开始</span></span><br><span class="line">    <span class="comment">// 另外，我们希望能根据sockfd直接定位TCB，因此这样实现</span></span><br><span class="line">    <span class="keyword">if</span> (TCBTable.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TCBTable.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        TCBTable.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    currentTCB = <span class="keyword">new</span> TCB;</span><br><span class="line">    currentTCB-&gt;ack = gAckNum;</span><br><span class="line">    currentTCB-&gt;seq = gSeqNum;</span><br><span class="line">    currentTCB-&gt;srcPort = gSrcPort++;</span><br><span class="line">    currentTCB-&gt;sockfd = TCBTable.<span class="built_in">size</span>();</span><br><span class="line">    currentTCB-&gt;status = CLOSED;</span><br><span class="line"></span><br><span class="line">    TCBTable.<span class="built_in">push_back</span>(currentTCB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentTCB-&gt;sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct sockaddr_in &#123;</span></span><br><span class="line"><span class="comment">        short   sin_family;</span></span><br><span class="line"><span class="comment">        u_short sin_port;</span></span><br><span class="line"><span class="comment">        struct  in_addr sin_addr;</span></span><br><span class="line"><span class="comment">        char    sin_zero[8];</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct in_addr &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    in_addr_t s_addr;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr_in *addr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; stud_tcp_connect():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    currentTCB-&gt;dstPort = <span class="built_in">ntohs</span>(addr-&gt;sin_port);</span><br><span class="line">    currentTCB-&gt;status = SYN_SENT;</span><br><span class="line">    currentTCB-&gt;srcAddr = <span class="built_in">getIpv4Address</span>();</span><br><span class="line">    currentTCB-&gt;dstAddr = <span class="built_in">ntohl</span>(addr-&gt;sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_SYN,</span><br><span class="line">                    currentTCB-&gt;srcPort,</span><br><span class="line">                    currentTCB-&gt;dstPort,</span><br><span class="line">                    currentTCB-&gt;srcAddr,</span><br><span class="line">                    currentTCB-&gt;dstAddr);</span><br><span class="line"></span><br><span class="line">    TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        currentTCB-&gt;data = (<span class="keyword">char</span> *)pData;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>((<span class="keyword">char</span> *)currentTCB-&gt;data, datalen, PACKET_TYPE_DATA,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line"></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">unsigned</span> <span class="keyword">char</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">short</span> datalen, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(pData, tcp-&gt;data, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stud_tcp_close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DebugPrint</span>(<span class="string">&quot;---&gt; In stud_tcp_input():\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    currentTCB = TCBTable[sockfd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTCB-&gt;status == ESTABLISHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stud_tcp_output</span>(<span class="literal">NULL</span>, <span class="number">0</span>, PACKET_TYPE_FIN_ACK,</span><br><span class="line">                        currentTCB-&gt;srcPort,</span><br><span class="line">                        currentTCB-&gt;dstPort,</span><br><span class="line">                        currentTCB-&gt;srcAddr,</span><br><span class="line">                        currentTCB-&gt;dstAddr);</span><br><span class="line"></span><br><span class="line">        TCP *tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line"></span><br><span class="line">        tcp = <span class="keyword">new</span> TCP;</span><br><span class="line">        len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">while</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">waitIpPacket</span>((<span class="keyword">char</span> *)tcp, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stud_tcp_input</span>((<span class="keyword">char</span> *)tcp, len, <span class="built_in">htonl</span>(currentTCB-&gt;srcAddr), <span class="built_in">htonl</span>(currentTCB-&gt;dstAddr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程作业</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
